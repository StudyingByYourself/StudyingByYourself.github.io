<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言灵活使用地址偏移</title>
    <url>/zhoukaiqi/fa7b019af148/</url>
    <content><![CDATA[<p>本文介绍了C语言地址偏移的灵活使用。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((type *)<span class="number">0</span>)</span><br><span class="line">(((type *)<span class="number">0</span>)-&gt;member)</span><br><span class="line">&amp;(((type *)<span class="number">0</span>)-&gt;member)</span><br><span class="line"><span class="comment">// 表示某个结构体成员在结构体中的偏移量</span></span><br><span class="line">(<span class="type">char</span> *)(&amp;(((type *)<span class="number">0</span>)-&gt;member))</span><br><span class="line">(type *)((<span class="type">char</span> *)(item) - (<span class="type">char</span> *)(&amp;(((type *)<span class="number">0</span>)-&gt;member)))</span><br></pre></td></tr></table></figure>
<p>测试demo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>,*<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DataEntry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_ENTRY(item, type, member) \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(item) - (char *)(&amp;(((type *)0)-&gt;member))))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DataEntry</span> <span class="title">e</span>;</span></span><br><span class="line">    <span class="comment">/* 使用node的地址，获取key和value的值*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DataEntry</span> *<span class="title">p</span> =</span> NODE_ENTRY(&amp;e.node, DataEntry, node);</span><br><span class="line">    <span class="type">int</span> key = p-&gt;key;</span><br><span class="line">    <span class="type">int</span> value = p-&gt;value;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>arm64常见汇编指令</title>
    <url>/zhoukaiqi/88508989b720/</url>
    <content><![CDATA[<p>本文介绍了arm64常见汇编指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th></th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov</td>
<td>mov x1, x0</td>
<td>将寄存器x0的值复制给寄存器x1</td>
</tr>
<tr>
<td>movk</td>
<td>movk x0, #1234, lsl #16</td>
<td>lsl：向左移位，即x0 = 0x12340000</td>
</tr>
<tr>
<td>stp</td>
<td>x29, x30, [sp, #-112]</td>
<td>sp = sp - 112，将x29, x30依次存入sp的位置; <br>x29充当FP寄存器，用于保存上一个sp; <br>x30充当LR寄存器，用来保存函数返回后的下一条执行地址</td>
</tr>
<tr>
<td>ldp</td>
<td>ldp     x29, x30, [sp], #112</td>
<td>sp取值赋给x29, sp + 8取值赋给x30, sp = sp + 112</td>
</tr>
<tr>
<td>str</td>
<td>str     w0, [x29, #40]</td>
<td>w0寄存器存入x29+40的内存地址</td>
</tr>
<tr>
<td>stur</td>
<td>stur    wzr, [x29, #93]</td>
<td>xzr/wzr分别代表8字节/4字节的0, 0x00000000写入x29+93的内存地址; <br/>sturh(2字节)，sturb(1字节)</td>
</tr>
<tr>
<td>add</td>
<td>add     x0, x29, #0x28</td>
<td>x29与0x28相加后赋值给x0</td>
</tr>
<tr>
<td>ldr</td>
<td>ldr     x2, [x1]</td>
<td>将x1作为地址，取该内存地址的值存入x2寄存器</td>
</tr>
<tr>
<td>eor</td>
<td>eor     x1, x2, x1</td>
<td>异或指令, x1 = x2 ^ x1</td>
</tr>
<tr>
<td>cbz</td>
<td>cbz w0, 0x687f70</td>
<td>与0相等则跳转到0x687f70</td>
</tr>
<tr>
<td>cbnz</td>
<td>cbz x1, 0x687f78</td>
<td>不与0相等则跳转到0x687f78</td>
</tr>
</tbody>
</table>
<p>保存入参的寄存器：<code>x0 - x7</code> 依次对应第1到第8个参数</p>
<p>保存返回值的寄存器： <code>x0</code></p>
<span id="more"></span>
<p>以demo.c为例，分析arm下的汇编指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FuncC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x900C</span>;</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="string">&#x27;c&#x27;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">40</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-完整指令">1. 完整指令</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncC</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncC:</span><br><span class="line">   0x0000aaaaaaaaa8d4 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">   0x0000aaaaaaaaa8d8 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">   0x0000aaaaaaaaa8dc &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa8e0 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa8e4 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">   0x0000aaaaaaaaa8e8 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa8ec &lt;+24&gt;:    mov     x1, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa8f0 &lt;+28&gt;:    mov     w0, <span class="comment">#0x900c                     // #36876</span></span><br><span class="line">   0x0000aaaaaaaaa8f4 &lt;+32&gt;:    str     w0, [x29, <span class="comment">#28]</span></span><br><span class="line">   0x0000aaaaaaaaa8f8 &lt;+36&gt;:    mov     x0, <span class="comment">#0x8                        // #8</span></span><br><span class="line">   0x0000aaaaaaaaa8fc &lt;+40&gt;:    bl      0xaaaaaaaaa750 &lt;malloc@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa900 &lt;+44&gt;:    str     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa904 &lt;+48&gt;:    adrp    x0, 0xaaaaaaaaa000</span><br><span class="line">   0x0000aaaaaaaaa908 &lt;+52&gt;:    add     x1, x0, <span class="comment">#0xa98</span></span><br><span class="line">   0x0000aaaaaaaaa90c &lt;+56&gt;:    add     x0, x29, <span class="comment">#0x50</span></span><br><span class="line">   0x0000aaaaaaaaa910 &lt;+60&gt;:    ldr     x2, [x1]</span><br><span class="line">   0x0000aaaaaaaaa914 &lt;+64&gt;:    str     x2, [x0]</span><br><span class="line">   0x0000aaaaaaaaa918 &lt;+68&gt;:    ldur    x1, [x1, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa91c &lt;+72&gt;:    stur    x1, [x0, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa920 &lt;+76&gt;:    stur    wzr, [x29, <span class="comment">#93]</span></span><br><span class="line">   0x0000aaaaaaaaa924 &lt;+80&gt;:    sturh   wzr, [x29, <span class="comment">#97]</span></span><br><span class="line">   0x0000aaaaaaaaa928 &lt;+84&gt;:    strb    wzr, [x29, <span class="comment">#99]</span></span><br><span class="line">   0x0000aaaaaaaaa92c &lt;+88&gt;:    stp     xzr, xzr, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa930 &lt;+92&gt;:    stp     xzr, xzr, [x29, <span class="comment">#56]</span></span><br><span class="line">   0x0000aaaaaaaaa934 &lt;+96&gt;:    str     xzr, [x29, <span class="comment">#72]</span></span><br><span class="line">   0x0000aaaaaaaaa938 &lt;+100&gt;:   mov     w0, <span class="comment">#0x1                        // #1</span></span><br><span class="line">   0x0000aaaaaaaaa93c &lt;+104&gt;:   str     w0, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa940 &lt;+108&gt;:   add     x0, x29, <span class="comment">#0x28</span></span><br><span class="line">   0x0000aaaaaaaaa944 &lt;+112&gt;:   mov     x2, <span class="comment">#0x28                       // #40</span></span><br><span class="line">   0x0000aaaaaaaaa948 &lt;+116&gt;:   mov     w1, <span class="comment">#0x63                       // #99</span></span><br><span class="line">   0x0000aaaaaaaaa94c &lt;+120&gt;:   bl      0xaaaaaaaaa770 &lt;memset@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa950 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa954 &lt;+128&gt;:   bl      0xaaaaaaaaa7b0 &lt;free@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa958 &lt;+132&gt;:   str     xzr, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa95c &lt;+136&gt;:   mov     w0, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa960 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa964 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa968 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa96c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">   0x0000aaaaaaaaa970 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">   0x0000aaaaaaaaa974 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">   0x0000aaaaaaaaa978 &lt;+164&gt;:   b.eq    0xaaaaaaaaa980 &lt;FuncC+172&gt;  // b.none</span><br><span class="line">   0x0000aaaaaaaaa97c &lt;+168&gt;:   bl      0xaaaaaaaaa780 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa980 &lt;+172&gt;:   ldp     x29, x30, [sp], <span class="comment">#112</span></span><br><span class="line">   0x0000aaaaaaaaa984 &lt;+176&gt;:   ret</span><br></pre></td></tr></table></figure>
<h6 id="2-开栈">2. 开栈</h6>
<p>sp从0xfffffffff9f0偏移-112字节到0xfffffffff980，先存入x29，再存入x30，同时将sp赋值给x29。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) i r x29 x30 sp</span><br><span class="line">x29            0xfffffffff9f0   281474976709104</span><br><span class="line">x30            0xaaaaaaaaa998   187649984473496</span><br><span class="line">sp             0xfffffffff9f0   0xfffffffff9f0</span><br><span class="line">0x0000aaaaaaaaa8d4 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">0x0000aaaaaaaaa8d8 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">(gdb) i r x29 x30 sp</span><br><span class="line">x29            0xfffffffff980   281474976708992</span><br><span class="line">x30            0xaaaaaaaaa998   187649984473496</span><br><span class="line">sp             0xfffffffff980   0xfffffffff980</span><br><span class="line">(gdb) x/8wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0xfffffffff990: 0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>
<h6 id="3-入栈时存栈保护canary">3. 入栈时存栈保护canary</h6>
<p>adrp指令这里不展开。以下指令主要是将栈保护的<code>canary</code>存入栈中，后续出栈前校验。（编译选项：<code>-fstack-protector</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa8dc &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">0x0000aaaaaaaaa8e0 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">0x0000aaaaaaaaa8e4 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">0x0000aaaaaaaaa8e8 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">0x0000aaaaaaaaa8ec &lt;+24&gt;:    mov     x1, <span class="comment">#0x0                        // #0</span></span><br><span class="line">(gdb) x/gx <span class="variable">$x0</span></span><br><span class="line">0xfffff7ffd7a8 &lt;__stack_chk_guard&gt;:     0x9af4bd74875a3200</span><br><span class="line">(gdb) x/2wx <span class="variable">$sp</span> + 104</span><br><span class="line">0xfffffffff9e8: 0x875a3200      0x9af4bd74</span><br></pre></td></tr></table></figure>
<h6 id="4-将0x900c存入x29-28的内存地址，对应代码第3行">4. 将0x900c存入x29+28的内存地址，对应代码第3行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa8f0 &lt;+28&gt;:    mov     w0, <span class="comment">#0x900c                     // #36876</span></span><br><span class="line">0x0000aaaaaaaaa8f4 &lt;+32&gt;:    str     w0, [x29, <span class="comment">#28]</span></span><br><span class="line">(gdb) x/8wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0xfffffffff990: 0x00000000      0x00000000      0x00000000      0x0000900c</span><br></pre></td></tr></table></figure>
<h6 id="5-申请8字节内存，内存的起始地址存入x29-32的内存地址，对应代码第4行">5. 申请8字节内存，内存的起始地址存入x29+32的内存地址，对应代码第4行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa8f8 &lt;+36&gt;:    mov     x0, <span class="comment">#0x8                        // #8</span></span><br><span class="line">0x0000aaaaaaaaa8fc &lt;+40&gt;:    bl      0xaaaaaaaaa750 &lt;malloc@plt&gt;</span><br><span class="line">0x0000aaaaaaaaa900 &lt;+44&gt;:    str     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">(gdb) i r x0</span><br><span class="line">x0             0xaaaaaaabc260   187649984545376</span><br><span class="line">(gdb) x/12wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0xfffffffff990: 0x00000000      0x00000000      0x00000000      0x0000900c</span><br><span class="line">0xfffffffff9a0: 0xaaabc260      0x0000aaaa      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>
<h6 id="6-对应代码第5行">6. 对应代码第5行</h6>
<p>字符串长度是20字节</p>
<p>前12字节：为了字节对齐，第一次拷贝8字节，偏移到第5字节再拷贝8字节   from <code>ldr     x2, [x1]</code> to <code>ldur    x1, [x1, #5]</code></p>
<p>第13字节：字符串的结尾需要赋值&quot;\0&quot;  <code>stur    wzr, [x29, #93]</code></p>
<p>后面7字节：用&quot;\0&quot;补齐</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa904 &lt;+48&gt;:    adrp    x0, 0xaaaaaaaaa000</span><br><span class="line">0x0000aaaaaaaaa908 &lt;+52&gt;:    add     x1, x0, <span class="comment">#0xa98</span></span><br><span class="line">0x0000aaaaaaaaa90c &lt;+56&gt;:    add     x0, x29, <span class="comment">#0x50</span></span><br><span class="line">(gdb) i r <span class="variable">$x0</span></span><br><span class="line">x0             0xfffffffff9d0   281474976709072</span><br><span class="line">(gdb) x/4wx <span class="variable">$x1</span></span><br><span class="line">0xaaaaaaaaaa98: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">(gdb) x/s <span class="variable">$x1</span></span><br><span class="line">0xaaaaaaaaaa98: <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">0x0000aaaaaaaaa910 &lt;+60&gt;:    ldr     x2, [x1]</span><br><span class="line">0x0000aaaaaaaaa914 &lt;+64&gt;:    str     x2, [x0]</span><br><span class="line">(gdb) x/4wx <span class="variable">$sp</span> + 80</span><br><span class="line">0xfffffffff9d0: 0x6c6c6548      0x6f57206f      0x00000000      0x00000000</span><br><span class="line">0x0000aaaaaaaaa918 &lt;+68&gt;:    ldur    x1, [x1, <span class="comment">#5]</span></span><br><span class="line">0x0000aaaaaaaaa91c &lt;+72&gt;:    stur    x1, [x0, <span class="comment">#5]</span></span><br><span class="line">(gdb) x/5wx <span class="variable">$sp</span> + 80</span><br><span class="line">0xfffffffff9d0: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0xfffffffff9e0: 0xf7fffac8</span><br><span class="line">0x0000aaaaaaaaa920 &lt;+76&gt;:    stur    wzr, [x29, <span class="comment">#93]</span></span><br><span class="line">0x0000aaaaaaaaa924 &lt;+80&gt;:    sturh   wzr, [x29, <span class="comment">#97]</span></span><br><span class="line">0x0000aaaaaaaaa928 &lt;+84&gt;:    strb    wzr, [x29, <span class="comment">#99]</span></span><br><span class="line">(gdb) x/5wx <span class="variable">$sp</span> + 80</span><br><span class="line">0xfffffffff9d0: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0xfffffffff9e0: 0x00000000</span><br></pre></td></tr></table></figure>
<h6 id="7-对应代码第6行">7. 对应代码第6行</h6>
<p><code>stp     xzr, xzr, [x29, #40]</code> 连续拷贝16字节0到[x29, #40]，可以考虑用SSE指令加速。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa92c &lt;+88&gt;:    stp     xzr, xzr, [x29, <span class="comment">#40]</span></span><br><span class="line">0x0000aaaaaaaaa930 &lt;+92&gt;:    stp     xzr, xzr, [x29, <span class="comment">#56]</span></span><br><span class="line">0x0000aaaaaaaaa934 &lt;+96&gt;:    str     xzr, [x29, <span class="comment">#72]</span></span><br><span class="line">0x0000aaaaaaaaa938 &lt;+100&gt;:   mov     w0, <span class="comment">#0x1                        // #1</span></span><br><span class="line">0x0000aaaaaaaaa93c &lt;+104&gt;:   str     w0, [x29, <span class="comment">#40]</span></span><br></pre></td></tr></table></figure>
<h6 id="8-对应代码第7行">8. 对应代码第7行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa940 &lt;+108&gt;:   add     x0, x29, <span class="comment">#0x28                        </span></span><br><span class="line">0x0000aaaaaaaaa944 &lt;+112&gt;:   mov     x2, <span class="comment">#0x28                       // #40</span></span><br><span class="line">0x0000aaaaaaaaa948 &lt;+116&gt;:   mov     w1, <span class="comment">#0x63                       // #99</span></span><br><span class="line">0x0000aaaaaaaaa94c &lt;+120&gt;:   bl      0xaaaaaaaaa770 &lt;memset@plt&gt;           </span><br></pre></td></tr></table></figure>
<h6 id="9-对应代码第8和第9行">9. 对应代码第8和第9行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa950 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]           </span></span><br><span class="line">0x0000aaaaaaaaa954 &lt;+128&gt;:   bl      0xaaaaaaaaa7b0 &lt;free@plt&gt;</span><br><span class="line">0x0000aaaaaaaaa958 &lt;+132&gt;:   str     xzr, [x29, <span class="comment">#32]</span></span><br></pre></td></tr></table></figure>
<h6 id="10-出栈前校验栈保护canary">10. 出栈前校验栈保护canary</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa960 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000      </span><br><span class="line">0x0000aaaaaaaaa964 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">0x0000aaaaaaaaa968 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">0x0000aaaaaaaaa96c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">0x0000aaaaaaaaa970 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">0x0000aaaaaaaaa974 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">0x0000aaaaaaaaa978 &lt;+164&gt;:   b.eq    0xaaaaaaaaa980 &lt;FuncC+172&gt;  // b.none</span><br><span class="line">0x0000aaaaaaaaa97c &lt;+168&gt;:   bl      0xaaaaaaaaa780 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure>
<h6 id="11-出栈">11. 出栈</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) i r <span class="variable">$x29</span> <span class="variable">$x30</span> <span class="variable">$sp</span></span><br><span class="line">x29            0xfffffffff980   281474976708992</span><br><span class="line">x30            0xaaaaaaaaa958   187649984473432</span><br><span class="line">sp             0xfffffffff980   0xfffffffff980</span><br><span class="line">(gdb) x/4wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0x0000aaaaaaaaa980 &lt;+172&gt;:   ldp     x29, x30, [sp], <span class="comment">#112</span></span><br><span class="line">(gdb) i r <span class="variable">$x29</span> <span class="variable">$x30</span> <span class="variable">$sp</span></span><br><span class="line">x29            0xfffffffff9f0   281474976709104</span><br><span class="line">x30            0xaaaaaaaaa998   187649984473496</span><br><span class="line">sp             0xfffffffff9f0   0xfffffffff9f0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>SIGSEGV信号处理</title>
    <url>/zhoukaiqi/fdd668922827/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ec520e3c2ef324906049c7ac107e7aa888c3e592a41e2bdde7827030ea0f3e06">99d0bfde9dd2ab8d25abe26dcc2e7d985e6417f404416eead608e24c1b72e5fdfbef3e6ffa307e450866eb12db82c616cab732356615290df0e9b9b99def14cfe1ca712453c7e1cef605ee85eb741163d0f620828e96647cf27f00845297ae9bbaada70c57355e2047a2955c36af039ed75c020cec6a1769c9918d507f13165a1193665c067b7310a720ee5a59925c7ac13be6f64f1344fa6ae12af11145ff86db3397602b7bd6f92c0ea19ee1a1b99ce031906a1c968eadc5b34a7cf321ce98ea19829d01b07b0059731a2dea7c7b81394b16d72ba549a21b0cec47fcc4d26d8a57cacddff0a596bc5600563ca64db3414b74a93919e083fb83935452e4c4b5e1386bd7136a00033f4a9b148362ca58028561fe744701f0f20036bfbfc217f37ef61a37b50f539d53a5808fa7eca90cbfc2fff33e8505d0020ae9d2fa69bb718f22d404d08d2197233977da31767555264c2dffd248e6b04b1815fbbb14bf6a9c3688b26b397e6c183c314874ed654e71b957c103c30b1f01f4a5836819e6ac06e465fda205dbbd25dab38a6986c042dba0097a85fd034c6d9c84ff41b8f0dfb1d5ebd265df19501bb028869170ac4e7b0849e1969725e3c8e27bbf18222279b984f536eec712946e40ac1c908c86b659a642b47ce0e1d7231ec5407a94db8892e9f13d45f0f2abc9e8806b5252a07540a8d6ed26396332d777d555fb8567d9bf4e514b8da50b3b60956e12457c4cefba412f98d3f128c1a7bdcabd3a3f23dbbc53354d428ab66fb94386b46bcaf64025efbf3a3eccb12c4ba66456638c16e18f38b291d577ab4d76caa67a201590b2edb0308a52a475beb6c314c30b524d389eaeb8e34c410804856994ce64a664a91861bcb6f11a7b850b911785c19bd073d913136ecae8b68c62e37216fcb90d2924bf55e721dbe96d055f5bb62ab967414f486d4d121bf199a483c94e23e1f588f3b4a08bb1fccef98c814a0234643a5d528ef5fbc11567bf5fb41278d7663f5736e722afd0d2d6a018dd7da32cb11ccb6fed9cf38e622964f86714679fa251823a205a91487f8d6a301c8d3d399dd8f1222a915fe82864788851e45034add72e79b0b4ab9e3d25c06524bdad11f587e82ff19e2f55f2b7b4ee94a3a492a80385fda5cab4a6ef3866ddd1cc46c8a1a86e684e3614e4aa62b446e6a78254753ba01270a83a16dd9ee03128bb9a82d99bd657ffa0a62586ca5090ccfa7e8cf2b7b319bfdc0c12e788200349c01d4409828faec564d5e9d718fc9a0f9505069e9149df9e5cd3aca3efa1e92f394fdd4ce1fe9f926b4b87ff7489e0c5e095aafcb5efcf15a7b4ca155f32d773f5db5767b6cf8cc64f4fc265c2977f01fecf57cc4484578850dbf91f9b0d53a5501cc56cbf39810f790537bfff1a4623364aee132b9be4e06e5e58c24919746871fe79542fd7ea006d1cb3c8d44508d4a822dfd6195606b2788979a94391be8398dcf9d8110d31a5eb1d914b7f813c0cd97ac71750bb185c54ff4f9a674c83a62e1ea315daf17337631a15575e49d1fbaa7d55045a94f41d7e110242f95b809390c382bcc2a291a25ac7142e30c1291133bb45b1cc1c9ddbe1eb6402945389db467e43f04dc077b80fa4d54e2fdf48328afd596e6c50664a97aadcd03e356a16ce231ba096b87b38acde82210a61c8bc64c426f12e75480c7dc90de728f51d6a106d1ef20b78e644cd37850f1261382dba34d050a21706edbecad7f992f653a163ed859a4e8cbf9d09f3fd0b867a5dd01497faeff474ba879532302bef865081aa54d1e669a3f2adcfab5c4bfa7b1a6ec174b019493f630289da459f4c834d956af7e00a55f4c82b156ecc168895f3ec21d270cdbee31b2c27b9b931683ab4b3a7b1c6de8ea146e9cfd7d6d507baa06c30e9fd86da5dfe5a2db1ac9a97d9df122b5d0d6a066f32cf46f7c41ab7a371934e25b437300c2e9b3388c04974f2753e718fe3c772edc1d9bed4d8c8b2b8efff094004101880c6987f748d06c7b52a819ea3ca601045d4133147590b10f26088b3693b1238c11b477af7631ee18bbaefa72e122544bf744d37d0e0f0cc9a1c43ce88bf76166e3203a5ddaa94e8254405bc3beaaf477d1c58b8b34a43cb353ab66aef7fd56a193404e77045f06146921c62a337d76b8cde7c6140805a5c6179026eac6362293d66b3fff34e94c7a2a766dcb386b938dd864fb1872d9eed11cc3e86051b9bfba49158d02cc4dbc1955155edd61fe1c4b7f3fa989343e394f8e4bc095ac85420a5e07f88c6e21c0aa85a3ad1035f8524baf8207c81e7662395cca4eb54abe784cc84032ffd98a4c2510e066a2e108c901a1060a33d3ec3398c62e98cd6601cc7c9cab7c7367d568b9f1d6ce98a808f6d2f3eaf8227b374f305e672006942a0bae5f633f11c77f23372c87ca8b06584d69c4d5a9212ea1053eb7bfaf724c55d10fe237aed060115af3d4e848a7538c0f1176f1d9281c4344df3fcdd1b8792c32fa9cf29582d1852a662af84547e9ef5bec4f65c689c2b2fe69f08f24ad91ca42bb9dbd923dca60e5ebfc9e2a1a27536720f82ffb07168db1d3f87d9b2d1b2caf116e5896ac1f2b7e75ed2c2f0dfc5fe51d85122eb78ea62d7cadd2b23ff9e6bdedfb5dc4ab3c64b6df1d01c759f8cefb1dedae6de3923ad34f018b600a72151f1e43108b7ab49161e4996118600d172617ff9df6bd5e85afe4511f21b57273953a70dac2b079e54c38612f4f203e933ceae0fa20af88b9c3d1f9067b98bf68ee29f7839bc10b30dfe1a8a3877f14c07120f763180cc299bb45d3d9e4cf971ee6cff16cf8afcbb6ce55fd09a86279a00c5f2f1844b0b9fd1375a449305aa334f35c9524bec9b650e4a3e17e931d15b1773cb5099e70c333a7d2b6d1625fb4c123a3f4d3946ea3607a2b8b6865018c1a2f21e5e95aa398f83b1424859636b8d04116038abb6f80be0bb63df455433cfe72315d96f844fdf6a789763df33fb85d40e1501062df6e9d78d76a5755f7b1c458c729528b5e33110c523a55f7e4d02edce5aad1af2f271bf5c1d48c6d8ea055adce576a63bde9ed667f3ca87a3009a43564fcd290a942c230c731a17f61b9713f0bab3a47d831a54b9e2e993d250d271e818609aa0ba1cf01d9ca9b2dab4400598747551691b9e7fb133633105fc0fa0e45df283f11fefe329766bbce2da1a5a81b682f7155aac226378bbb48856150b956a5701bbb5877598db954169d90e1fc35613231558fd6eb42223bdd94111c7e1961d0e17a333cb739c86f614d12c771356d5314cacd85e512836a0431e7e30125385dfd16e69773f1aba7c8c36d000709a458f82e574273456c21a40046414f747dfd7c8edf8eefa331accda9a9462b67263823e1cd1f55f0a5bf4d2aea5c0b6621fcf0b1c2a50ac2fbf0ea5c7ae3754f8f7286a629e53569a65bbdd1b144ef3a55b6d94d0e70aee067acbba56bef09a4487e1204ea0a0ff824981628a6984dfd394d6cfcb0a2d003aab9bfb59156791f5ad592800f7f55b9c92268c5d91ad6d543468a0381de4c51a839d99ba71eac32a5fe48e95e0116f071a2115f5e50042c35198d04e699585122e6828266ad4d00a9c79f0e29ba7aea2c0f7833d1e9b91f74d5370d175ed84b28d041802a2e25d78edffcd8cbd94ac218c13eefaba51ffdedb72d7eea87c54c422aacb0e25f3560842f8cecc76d3ffedc07b7a798aaf86d2e21ad89d7802c3ad050f7c49eeecaef530088cb59096dcca0be4f774799efb32d28f4d158ee1c9a0d98f80f17821fd290c8169e4fa1ed60b85fb3ddc3733eb163ee4972e6a763803bb1efb2b294eb4ffec155e30eb689c8a34a31f8942adcd057d7b21f1f1198fd522588363a7f85a2b1a32b0579989cebcc73e70835360736aa20e36bb06385ad60da38c1f93f1d7d62e205fb6475fc74fc07fb245a3eedd6cf100d4b52aeb163737276a863a7e9b5e6f16ec98967b19f586fa027ee53376d95dde616e99ca833c44e5dff600c5956a0fc1e9d9861453e94ca964df4ad2914c720c06a5feb41df1ff4c3a87a35cbafa2f575f30566e2aacd291501d380ba5f452157241820bee184fd5cdaa8d52bcacb21d1dd3c8d794311abfae293f0bb6f78ff060d6e647f06dc5b7a3c86d29062d95d215a3096348d15442aa6d64d052eac32f41f5c061aa1bb485e84df33515142f2221b26ed5fc02df75024a3e435858d847b2b59fff8b330a24c41ac81f8b881fa54571275317c1b8d5d2fddd1c51587100c00d6f064fe4c7bfbeaba57921999dd2b1ca4faf7fec974be4c5dea676dd9cad29896df7e65a04d713fc62c5290747aeec8fc89991326db56eee5e0b87efca08b5915f6021eda75979d3a54ba1fdb6d9ec2a36d3a3e77b07e351ac47e54e388dfbcf130eeb05e24ee759c1aa0dfa9ecad4d9d761607c973d882277dae06f47298dd00270f6f9096b86946d65ce617c40f0d65c143a40288b6a0236d32a0dc48704e2e3fd62a7874e595c7edd0e580fc075a8ea277e8ca5861ecbaccc5fedea6b7f4e18919e4edf235f47a9eee235b0e0406d0a74990ecb8ddb78c725e0479cd07002ac65c4ce2635edca464de97fd28eb323dea8a9436bdf323dc81aa3655dd787c06a5633dd83ce0155063ab352c57b4b6866d638030bdaeb92267e7924838e37dae7127923a19837b4741a91db371653745f01eb5408ef51707826a6498dd9b827ff54bb114ccf4d700993d151fed20d417d1ea0654ee852875795a56f6eb09221a1dbcb0f975bca73b9acc62723490f674280615eef39cc7c1c2e974400ad17ee444e3d3d12afd5100ae9f946fb6b0da26ee26662be35849fc14dc608e740c69b7ab8fbfb2cb9701c296a93ce15f6d03e703d3f31de05fdd1a746e2bbaab9cc240c9525b14b226a92ff08303a7afec1c5839a7bea4d8d3276b27f8e95dcbf747eafc9836bb85f1d800bea14ed86284f26c0327d11bb2b0c4fb4d6b773c644e0b8eb8661bcb6f6f34779c35922083c7f0be7959d62398fd663c3b1f7f0ae7b5d7bc8a60baddd13abcf64a1a444d6a3bfe7f83244681c075abbc98cd21c4fa3fa15e571eea4b59c64cf4946c3d209595d1c0cb33e610300a13ebe69cd462ad4bddfd3e4b474faa9da45db0fa741a8cb46a889e14afff411a213baf11f31cb0032a7bc8ac52e23e97006b48a8e6ddcc8ea1e8054f2f60dabd36a115df56f804fc879f710a0ff5583ed34b9c8ce94cb7642aeec4d2e9ac872ca86359957bd2e7c750dc7f2fa442fca8a8c1cbc35f1dcf1ccc99552fdc13ae350f95eb9b8de36792beaac4be1d183e0f3927001377790e879d33eba803a3a289eb80fe10e212df10ef43b081aa3fbf274af8b2665b76310ce56878c6c48f8ac80c9abc8d8e7d04fa64a596028421e827b66c216385f0975b3be988bead8a871d6da6a26a0f0f4286acafdf3367c78914e996a4aa7afd1231d920834296dca3b3f2292386deca4892254e3b3d0789ace8eae0245a8e4eb71d53b9a50ca4d7c79c395a87647cec718ed7b973e841ff7f87cbac58a06cddcf64d656369c9e8febbfae60567dc6dc2de880e984570f0a219fd29f51c4d6201a9ff6c54b92ccf4de4c94f54631455ade317c9f7d81bb351a19c38baef73ea8bf448359afc4e72e7aac192dcdeb969e0089ac8714edeffd98544728a8c677b962734c8263826bed525c0c8fa4450978b501984283ce5e12f1d281dc93b2a7443015214000c2188e47ee15cbd1a5d0fd68e876fcfa918cea4cbd174e9da31e23c5f9270deaa3a8b66ff602687866369a136b006d8080d87e6a28976b3e250fef9f344f3bac538a7ffd952e64160b008c89cc5ee10c1f9f91bf8ac2cdf84269f7f0374a1882578cea3b16c8f056e94be544c3d7be2bbe9875eda83cc787aed341e7a7bc9bcc30a103dc60a08877726532261b6bf1a92c723d88dbb54801101b527f598805685e5370a4f5c703fc292f31426804cd8f24a2902ebfcff6bec42fb08692dfa31c03199eabf01f5940bca46b81f13ee2d34f3fefcd35750ab9b5b85900a327f552d7296f1458785d1ed8fd787ef072c9ec88b8b1ce09f2f17f32e3e7818e84067efed2cd3d5db75c0112dd50170f5e0239e7595eb72d93f668d0c8d1dcb292988826afae1143b3fea79eb5ac95bd882dacee66797216cd7989493d1e7babee4005fdd5dd82250d20ada3fc431f7e39af938c4752752281c9772ce5ffa26e2b2e81e6d4ae0efe64395a5a30ad1f226953f291df64ad1747a08eaaa0c35236649e4c3f206209ff70d84e5617f812b8bb781766f4d86d34dd40d46a270ed9a59342199d66261df1d05f665d05b36bf6900df4b820210c17923e314c479f1a0b4a069dfcb142bf3593c2c8c550fc726a5ff2827be0ba9595da4b634f6d848defacd9291727b651ccccf434de49e186c62133210799448610882284f84e9b92b253933a696035350b0ed3cca8ad8658a1cf33dd54b06a98a4b62f01d25595f8faf5bfd15ebf23669208079a574db491d8d9f73a80203e33c564fa50f9897b84f311401da934491a542d2a2555fc59bdeae5f84f11ba16553b8ea299444c496706a11ac3de9b2822a173f7fe1e137af27c9ba8f4e66bc3cff7d3e7748c72d542936460d338b2bb22e3cb98aeab4fd05a44e1c07dea2dc74734990d49a72f0c34514cee650169bcf25c2fafb550a79f43be0d0535e90dce1d509224d894cea880dd381a43836a8f978206e29ebe7cd4ca01ba21cfc39244b258f60db0c0be9d3a0a5a2ff24bb33f12f84c79c534292c2daedd4ca35d758b23a8f67abe7739fb18dcd5f462587af94ce296e770c780fd6837ef4d826b1dd8624bc3addd0b681b7f8b95aa2d225a10b49472abc938b34329e81a3631f4540b06f239f4c781ff6f30df46e5fcb877644b727591060b945ea5983e4f79e35ddae22c574309d3e52c10cdc8bfde9dd9da2eb469f55d47f983e48520fcf388584da69791c7d89ab6e562e9fd5381eee6b29297d694ad2ab9f31f011c5e1cfbc08b2282c835b7047b8ca57657f20eb5dbf508cc16c69153887e4f788693820acd8e2020e315f255c33682f59de1834f7331631524ec6a220f47c5de2206b4c0f644ba9b13ef43fe88f5bb6b011ef3973da5b688003c871f20ac5836aa22dc5410b113e1a023d819d1788591483a02af3a5f4f9aad7a20fb417337a2d124c01fe8d7613a4e19fc11b5b15cd86d03cf35f6be0539928099accc787257d0a8b0e70a73bc9cb4b7510f862313a0cffae42bec31cf2873a4f00d7e84638375472f0056580ff6a5889287e43cbe4abdbf14fd30b451c7e6000a1f95e9d9d15b65b429c07902bafa053145bdd7233471db748a7af41dbe67f3b4a8a3eceeb5dd33d567783679c88168d8cf00070e85c5fd5c070f97b97dd9acec5fd5f51edba13e80797cc7b2c735ee4d806f5dd3b891ccdfd07832949050a92fd0ffe311c04e833479f5ef0740bcd0d9defe865e8d37fcb4b47753974dbc73599fc71b4dea9bac8c7d6e45cd664c805de21cf149c4105bc3d532f0c7effaa8d33d90ee720600ae700b620988dbaf63d41b35889c3962142b1db0e427564f358ff89f3e517b8565d9392e82c3f9d66bbb38786fe60c20d3b60ba555730fa7b74f0e54c5525e46b930a037e8cd4c7841fa4c4b93e2285045d4584125db3e997af1aeeb590e6c59561c831718bfc12ed8a08de09412be00d65e52fe6e22adc416337f6dea1f5d47e7e19eb7169e7db951b8824e9c0a689633d33108f8e1be24d4107e92fb63ed091d16dfa8044fead5f605fecd9881876f91c90ca1f3ff1b1e1efc42666349291d42f353efdf899652dcb2455a7981a9ccab5072b60052a83aaa577030c4808f25016b6bdbf073266655f718a23ae2b78f8ac1643ff6f0ad1fba0eac925d263b73fd5399e9cfc2e81b0cac59dbf6f56ffcdf228b7c7c74996ea01ad6d6b7b47ea29b9ab7addf902e2aa4eaa880a7f74f89cce793bb79f3c95abfa9a886f5d372ddea5b425f22bbb94be743dd4af247e2920db651cf27998dc3ee718a00514905be2b6ed7b10de9ca405284e7e4df470383ad42baf56f8269e105f947d324f758d968cd6a6777dcc7a4b2149997697d1ddaf3dcc69a6967c2f4ffbf6eb40213120660dee768aae596b0e6156334088298f738cfb07f4831d57b072862627fe7c2a031be13fddce99cdbb01ca6d7bd2c22f400ddf8d5191e190284d71d557d0e8ab3dc2f11720ae7797979c1510016cc2f05a4e9e6778ef98c22f89ace82418c6a155078bbd6ecef742427884f76cfbb33c31f9bc364726f3d951bd94e03524b84ab383b6aef59e7384aa03e493f59d5687bf63964f98d3b4b2553d74860f4871772c494c33cf13610617a12025d70016eab196ff40132db2133c395a0335b1a1313aa7ea67197e7ab116a6e47532f8f2d981ae7a8f9cdf3b43a1f6d7161738f838c780b1b612f2e9fca4a7e39b82864b2eeddb03031ed2bbfc3275fd4d48035bb48758a7cfb6e4d5832292ac79c4b0a6ce92e0784c4d94c4959b53d76023b03bc62d8b397d869fc851a577cc5287c99ab4831467c6b426de7d0fa881cc2c49d9aefc5fadd629e1538555f3d8442a4852ffdf0adb6ea2015f753513bc57674c512d688b313a9dd2582fac9d1963f7dcefb1f9c9e9467de0af608ac28f41de917ce3edf4ef46cbb94acfc8220fc3a4781bf5c91142ebe0bc54ef1b1102a9605134ae56cb03bca0f10e3f99ea586d3c4a8c3d192fdd79104bc499b2ea55bf8fe59eea98264eaec88938cf7ef8e556ab35c8d78b1f29bd9b1d9235a0316d2289d261409f2c1f66652cc53ece1f2b28abb7f78b256d0aa7fac41b3f3677269a4918f14f29a4ce6a7b6231bd2c61ebfcd59138c2b5d26039084c43a78d11b387c8b0b9700e71ca0c71e2aabb648ec058234f5ebad7068eb955f28ba3322fe152b9f278bf721bab9915af296e1a2f78c661675f8bdf912daa221284a00b7a0f6c725b05c90daa5a4f19fcc9554f3463514ffd7bfb95398a8f4327235c02e8471fd299ff04bf6808006629068827f9a7af75afe6aa8d4dd72dc9b4396d1bc4b407145cf974052f13153206c89e4d0ae06190e688ae64a19fe1a74ab0c95a1487e519010b628dce1753ae47af2cfe2295c035518f3bb74134eb85e253bece7b6438c5f1b33ca5466f95229eda12461169e0b93316e6246350b15bf018fb43fe0197300cbd3f587778e63d4a1599b2e05cf32a490779f2412c002790c3cb6de221112b727891c579df44701420ca6e6a0f588f26b9db491c0e194d04641b95eb8d3a0b94cc4cb80e82ffc903b9caa536442c0788c788e0f84aaef1eddd8b0425bf837fef62531c195e124aef980f2c4520e32e50f9156f8d2cd728d0afa3207a0836029dd2a86754df3132670b5a77af3f0ecc70810853b505c46fb420058947727f5c8f8734918e88b3007fb3db0f49157b195f568bf670155d4af8e994ca12f79414977d7e9e5bb1ab897d219643afd2445513bb0d296c1b56be9cd8e1bb8bdaabd8e30e7d5615a00af932c417d0b755af0faf91e2c5feaa46584a176431a30894f3979635f39cfa75a217a6c531eb17182f028e3ce06306539baf19476c47200c915822efbff1fd35652c279f738d1d1242613d2f3e78ad59f89322ca996c418a911c97ae38b60f63960588dfa26f490ecebac066ef31a14ae568311dd6706ee32bfdbfb866a4b73ef07b62430f2bdd32022bf8093d01b760ba3b94bf214de3428933d99e488c2e4b81c1c7ac05084c4ad6d1a95157094995804f0ede27b2425415384f0f028f9d090ca2902ac3b6a5e61aa43e015da9a7089dc2f4f40d45ec3af876166ff79cd502038c0d520d80830a385a75792c052bdb5fb74fd6b0adbadbbf64ffbe63901dbaae9df1410954a8e04a04e61b41a7761547f2f72d23dda892bf3a4c13776cc160462b9459264ed0c1ab006a8dfee6d73f8898988212d685fb7d1dcd3f785509b2b92016fd58922df0f8d64e3570122693f92d4cfd404ebbf99f080cbdea428e1cea5d42fe67ca7740d93e4c591ba9ae8e1d388839e6a3250980ea690a21fe5af06eb761d74ea065131366611e276f284f135ea77e192cba451dde07c0110edbdaf9db8a426532a348621a07da593573f2a7970a3209a08135e8c94bcf00af8a4d1cbfdb50fc09de3abc5d933ed2bac9cdacf6624ddbf45a7159069b702b3c8813793274d8f20ddbe8292efcada438ac5fe7914459828102ce9a2b1ead38ff1566990508eef6d998dc076f8e6a90540ece2950110b635b514f09f16a63f8973ab9f886937724a1b7e47b19a21531c7d8f17aee3e1a09beeb4090883fc59689ab1080ca114a600a569f1f0bb6774b4ea5e4ed31477d3287a5aee36ac86f2b35b7240a6e5492effd06d68867c6448b2bf813fc71f6fe346f96a25ec626f24c49f26dcdf3fd06211f3d493e87296e27961768e16237e678c4ee271259d7a880e9af9c19e34f345d3c5078a7ebf9dd17b94482b5e6316982fc22c878d59dac0ba6bbfffbdadc92520c1624e7270f3d221129771a3d7732c48e24187a27596f96d33d2f99e5755411cf6e2644dfe3b8b2d3dfb3f883ad4740beca72422e2176b98cfa45fb96a1ed061f31e0744de5ca39f36fdf5e231d767755eb7386f3ebfd1f8927215aed52d4550b0bd35a1141b3b89bf4b5af3e1f642c6a3a1bc084d75e8684556e3061e3d6d592a2d85eeb9f1b75b309bd76eb93831246cf3f86ae602d41269c61063bb3510db6db3d19049901a28cf36193a1ea26289af79dc0c9f9013821eb1d97717a9ce255fbeac559fbb89f348559ded6ef24f2b943f5d984d1d0716d0aea3b54e3cac21cb3a3beb639a881802d3a90b275bdbc82b76b529a10d9c8bd842ef2787526e26e6f51acdbd2522da819397ef3fbd6822c7861ab5acf7f7664fd6161d5724cc0c02825666e3ef89b4496bab1d0cf3f0de4f5624a61e2a64f4403ae0e92e4376afc62ee93d7775b0baafb47d11cbb689f21728477b97243a481f3a61499cc2aac5f6fb8c8f99fdb40d94dd5705ec1b71334bd866f0db30cc82729f8a95c013aa6e36f389bfeb12e089ce8960084bc04766dfca1038311be9d84f21f6d3353850669470de8256afd9170768d7b9913b193ade5d4eb1f3b61a274971071c84030a6e568842bd9c54ac2846ed2035031cf8c64c8cbb7fd485c1e86da0ed2cdcb7773c0a0e9a211f79d9dd6c0f097001a1ba84fd5cb73305cbac585df510b4113cf014a46617920a558606186b5dd43997343a87a84b30902881462209b034e1c75cf016cfd3f2f88c725b813203e419b86fc3bf27ab30b9e2306c6454dcf6f0f0e98f166601e8101341b3ba36a2d41eca82327403dce4ac3cd42bb76d5af2f1866056f2105757b8aa029829fa122de8cb3fef6367490329a8386a60d7117573e90743f3924a0eac96f05cf3316c48caa985ef7ab215a728f23a3d2730ec552aeb7635fe697b245f34c3aa8e23cda9ceed9f652520cbefdb0e0ffe112076a4651ccd14557c99ee987a757114d9928b965c8a3299ce41b32854e470aab1a31a4b14437e38e2130d8758bfc355d49c06926024cf811d885c1594ffac317ca4327285cee8ff72d4725a945e776ba7f392f4730a8bcde63db71db723c3e1c2ea1121d9669a46300160f11231406efdf0b343cc36b5e8d6cb1a644f55bc42fe9c2b7b302702d12005762a53a4386ab7c609dda6de062eba05ff5eaba4cac6cc46f9a2b34f76b14fd5b5f8c207a24d2b86a586d9aa89d0ca7920c8892b57554e2b762e8106c9e3d67f495d2ebbeb3093df04f39cd57890e26867e17502682536b9e4aeccda1bdba98f4711e72852523a83c830f90429198a633cb2454b0c55230a6e70fd3fceb00fa1732e8cd23a70db4bf294fd2053452fa4a6bc00fa4af288fa48d391a89c82cb46d9064b1d4d56acec28bfd91615f2de7b0ded36e60d53a76021e86a243cfdcd85d849b2433f0b9e506aca23ae30e204848b434f190668638aab4b277e70400e4500dc9be5b96dcd89ce8620f39ddef1fa5cace716944b880d3a9f83b5901c979df5922a49731b01d0ab2a23be6ae8f72c606d5899f6d5c783d01c600ddf9d6cbc808682fc1a0ad9ab7b239b40325f4d36c1033f096ec9bec7176e31efcd73d62005dfdc01ecc9ff8efdb7682225fbb52403fda6bc8bd94211d4a1b653dc99fa0fc38693c746277f387cc9ea4e8f009e3d1b43447c37fbcfd161cb805651f6fe68b27316fe7d6ce0fdc04ea63b377052e9aa193b701c1bcca8110d01372b7522bf718f6d35cadb4fba7d42547a2e92cd6f172ea58f3e3aea9e8e1f678916b24175de53c67583737773c64eca3b4635075962759249fc1080a5c34e01edfcc923eed15351579886f55a68b2f0e0fad64c383ac53a7ddc4e0be4c9154e7ac6812047412361f2505a98afdd7611dba6c1cfd521503835e92a0831f6cb28621374fb30621a440bee2a1c333edcf61eec4c0c419104ade79622641e738a38137e3d21e4cdbee3e8ca045563f860c645c63b65480549139dfcbaec30ad9dc6c38d2ceb8e961805a865c9b80722c1687636fe44b654be892e08301ed7b9d3c82191970c7726d2a9ba3fc9789fa7c05a0ad392d35a044f85983db962834ae63e52bf70f9f363f9d93e575dbb2765afcb9b0f6cd5d7d1e8e760c1f73e1f1ab35eb14cc40cad2fbae6e261d1156929673d2680d0f303c83a59e63e792f47121b7e76e79fa6664675b47e14e56b2a2c378189f33567d8ae6406cd9c3b3d79a0e7131a31f4b4df657b31fafcc7afbe557c87f7110b0e8cbd6f198f5703dd35d83dd7d4fa42ed4110bcb00ccea9194544a2c6ad9c41932ed13af2f219f2efb0fcf50cd5ef707e5a499d5dae3d49f6de5b4816b7c25dedaf83a813b84086f69548f86f477193e318d4db3d29f62cf84f286b0e616685971d642403527ea2a80f641725af934933b0bd1fbef6d2fe7fb8354adad23b46b60bc669c76ca7e7538df4b3473a9d8da7e6ec4ef2f24f6e5fd562816da74740522a0ac745b83da69ed7e512b85dab41fa2bf5ec6e5fb1325630d9fe1f485d7f021f1cbc1f10bb0437b03fce4b9d48133c715de760085114de80e1e6a450d7624ebe1511fdde1afa027ba5c70ec34cf60d3c03aa0578304c2956f613eb290d189697a8beff5ca7c063f1e9dbb06305a43c6b05fc7a7642b0aa0c706de4f7ba0c2c8b2e99331df9b186af329eec868ef7882b9134c1bf0e2580ae2034389fc727317bc6e4c3f8a0a03cafa95700a0b2ae4755ac4fba0165b3df6e877a0b7d5ede1d507f89a062338037b906b251a0d8793633c6327f5059e4b38b7495ece9638ac08f8e1e0edef98df1fe7c870f63905dd9efb3743b5109e3e62b47866ad02531dd8d8c7a6c2f784ba89f3099d5a8b21c6684d02aa4784186053956b9804ad1f5ab5ca1d49fcd91b14a594df5d15e013e0612642c5ef766b7a59f7a0f3c4caf961d00cb8d96c847590144500c9dfe2bbf709022d507f134002439c373c468f573ed685db305be5537006762651a3f71d948fa7c7b3c51717d5e6426b069152de3e1027ec1305686341a7a8c895caa113c0c327cae4a278953f7989c9e42e2b5cb92112eaf9e3178614fca7542d940b643cc7c0036e181916f9772038c8fe31ed5ba145b8c4121f67eaceba884845902a3a8bd04063435a344a1dd9b185ef5b2489ca4404ea012da8b0b0a0213a3063002765c6a714274bd38d229ad0a041b7e0cdc90f8723d6cef7cb3c8d800d2a9718e93dfdefe1e1b6147b44b944f65d762a72a9c32a0452d6d7931aae41476aa70c767b953cdb6ae3eb3da4294a3a0b7c2d2fc38ca8679b6650a2ac45481cfac612031cb5b41f910698af6bdabba458d7329928097d917a4b41185baeb0c92cfb149f2280de3aa44936f97d17ec56b1864985b1d4ba86ab5ad4f57d01b49763368ffcd6d40a46bd6b4e9de274779b4a7cf29414ecf458678c83dbbf38f2716eed6909bff375026c3250adff7ab2934ca9bb60c2c3e9f9f9e802d89fcefe83ad8c0fa64b55a6d48919505649f6a51d56fd1bbf9ad768a3c55479390d001fa44a76af1652ab54f70e9930f8aa4b584194ad01f6afaa89d133d33ca1894815567a25db244b3f22ce5bb14f210f934595a04b33acdaffc45a483fe600b6029972a9b8f28e795813be6388886ff2f334935cfb00f11cba2abc99884951c885460b6ffb097e5ab1adb6dc93577bea1ed6474992b33c5b2f29f7f3a801f92785d148f82f44fe84e9638c18d7d4d0a8354d6b3c2a131af8838d64b149ea43dc25afb5cde7b5ba5e169f1396105c5f1da6b2faa859c0dc1646ae3dd06b2ed47997b472be39b7b1df6f1e56f6757c9450debbcfdfd6b116d118953bcab3fef54086d448a487b873c25074f92b9700afcafd790c1e82df1002f1a601973b875f364b41d9e5794617cd7a14548cf8127d225016e41cb07f52d00e56c09e260c0e211a85cdd783c4e447570039749b3dc5bf4c33792a17961a50792c57fc3044b76b533b742935967a2005ef5a4459bd6323bb7420443580fb6ac4ca6aadbf8662d96ae7f96bc44078fb5990009d06bd5e6aadf892f4aa8e376552587b66b3663a362720f0a204e1a07d8a18c8ede78ecff98d2c7a92bb67f1baaa1ac682bb49a581f8036784192cee4ba4d42682125c2a2d11426ca84929b676e8efd011f3731ec8be7da574cfd4d366f64fc8f70c5d6de7a1ade5e58b822ab13b140119f9bbe80e96e0a166d705dac51c15f80a640b16a144c1ec4633fc37d2b14b64898ac7393c2dfc4fa2a76a2a3287dcb6990f7c7b70a62dd4c123049bb441910c87bc882b5f5402e9b6037c39226507b08f89f80f90310d5d8b5860b810cc743bf49f5af1c38d739a99a9ba4d2b44aa7de938e7e7fed17f952ac2bc96bee9f7955996e4d3027131b8592d9f6bc68d0e2ff64a49f5bd97a24370f0d119345dc9260ceb47a5b6bf5cfdfda8cd0d1e3ca029be88fddb86c5bb8c03f8141807ea40bc18f1adcebb0455264b52cf83288965cf34c33e7ea5abe7025e0112dee257050a8e3df26786cc09d80fc7f733d99d4a867dc39e2bf87889f7f8cc29e8975e87fdc960d8adb516eec1031d0f700695232d2efd85575d585515f37b9a625fe6ab709e733654076e55c802b9f60bb73bb07c5fe32a2aa24cd764b95a84c8bc04806c3ae4c7ef87287868e781be0f95075346672bae9cca2ec82b0b124d0cf5dc171ac8701a13e46fe589a4f2e0e890c3fd409c3a06087d33fc9ee100b2c6f8449a268334e4b14e46f94191f639bc8713091db85c869bf36a93b9f46f84df2183e44df4be233d170ae9653e4860fe8a378fd910bb7dc31b3445b37a1d2853dcb545f910cc7af6753d22277d5bb435c57b597c8a0ba8d8bab15bf19176f6da1e89536d763021dd81740e874a3bc7b3718d889a7975ed590203fa44be9f1b742cb3b5791a1267ab7943cc6b85da3d0e7d4d262e827f86f82682074e9d24a80acfb29e8738ee4465af9434273bbda802cbf5cc6ed5f68c4d7cd592fe873d7b31c13169d228e1219608fa8ef605ff788db1c67f98a3e0847253bafea6d5f7410a7e71d3c14e439d22c0ffa9f455460e87d04014229b7a8c8fde21aa01dc26ec5938b980e704835984970b9d9883baa7eb7f5e31b4a6e8dbc8322a2f6b92ea131a57c92b2c1edd24c86f8cc73310db986f78bff68f842de2ff296e173c5715641892e925b3cb055652015e182580013f87363445c73c84ca4f681ff5c8bd02836a679ba605a5e0bc8e541e9e69f025d63239cd902bfb748799b1b13da28213528d4d6ae120df311447611d3297ff8a7ad16c9292596fe825cff5fa03a3a3553d70ad4baffe00241645b3f0c5daa9e7dad9cfd9c4c1755917c029517a904216e607be2a10bf1d6dfa545880f6bee713e6d7c87450aea14a53e68b82da92181ff17762ad44b4d2897657555182ecb388369b2eb7118dea2465e63ba7ea4d71e25f88f8e053aee0cb7d843fa05be46fa21ef50776d97c409ece719a3527b218a1c95c3843b4406d6c57872cfe21d9e32d83bef83c7c9e401b000403d2bc129959631175a93cbe355dbbf1bb54b527d7f081b3d281f4e8392362dd1f7e221f69f21e66c479bd47db6324e3d3eb7a662ff72ec9ee750e867ecbea6cfc69ecc43c0ec831eaa057abf8c840b215c0833270161b48859e17406a365cbf9439370b6873a5303dc9b6d3195fbed78b86edf9e9e44912ac9a8dc534cb404a15ee401d296fb88bcb6e7eb314139789efc624abde37e29770c0e96b1a4131aa2dd835c5f050efd875ff9bfe4193966c78c6869deccb45710dc39eafc2b1323c6e5ae23cb624811e06dc32b60c20d69f8cf497ad67ebdf2e3f81f8e06f8d140a442115113b0f9033377293e85093db37d4b475c803cd5301a8b1689b0c378f65e225b1df11f2d68327fad9dba25356cfbd64cbcf3b9048f4c29148882141d7141b473dca54eb622ed6dcaf1058b6a6ed0064d3ffb9e26c4dff578451af3442ad78cba2bc81236d91544e64bf4f718a3a8399d7ac12629b87efb6c8b3754aaedfd675c695195d19ba9de32065769714ec028f665190e87c3671d9a44523eb5fe7ddd77fe63e5c251a791785f3de5ce86e7b5ebe18194faaf4c57079569ecc9009d307480362a4843c84c75a286b326a3b8a69fcda2ecaf025fc1179734d22cd7c2220b753c418c442d01688c2064c0745b38e8b094cfb961b8637fbea5733e9fcae3d47af46e733e731e1e918819afeb20eeccd01a78512e09e883e26063ded7f90df9aec98439a1689cd904609dea6919253191a13ba4e00470a12a21d844791bed4eb5a39f7c1089bf099d7108e4ecd8405573dad68f68599cb92f784d5fe76b44e2f20c9a3b5db7bab3f40ce2573f64b58edce4ca5b5ee719b9f1494a5f0b4399086331f1310400cadd14771cc2e64d4d5b167394c70110099d50912f1427b5f34c6100b0e8e8644ecce727e2aaadd192a601b051269e9c102c25851722f8bc61a1de5750f3a59c1f213bd711b7c7e67f1733e27465100c4abf365483849741d38fee10bdf98f41bb2464df2d8924b8e8ae37c4de18c869909c8eff992b58097e327f65690c466836a501893dd65679b7198896cb6c9c12cf6d3cbf5205bee708126b251f4d429d2b53d78e610cfc7e21421a4adab978974f3cfb8c8352f7cddc8a51c7e313e9aea893c3d772e2d6a437ae1e71ecea0633455849cde6422b7cba13eabcca3665dae6102c8ee15db6def333ffb38f04e1587d66e13d552f641c5a88879a81af853d5c88c00bc794e2994aceaad62cbf83c3563808994be33fc346ab411a6fc516f28c60166f6d5d889479f49b3323c5ba391cf6de93bf701d723a0beafd81a6d9c1a2109b61c250c8cf84f88d50633a3b37c69e4cfe5b710b78eb05adda59fa6d2f0f59ede4eafa1550fd5c33a18ff2c2a31f8b96fc305a7e46d8ecf142152e8ce2afbb44d8a6a3d90d67fd1e71ae98f43ccbdb22372994635c9b8bdd02f329fb5a2a1ef6623c88d7fc9b1b1f965e7bb034cb6cf509ab1920bc17d63c15cb2a9dc1572b4faf1a2fa7a59026c4ce25f8657202cf719143a8aec03fa84531ba32bfae69ed2ca0a6f8c31a8388d4f955da86a4060f4a3c6042ebd943bebd0fa818a8e10da24aa8375f98488e5476bc695bf59f449bc41eee7bc71a48e6aa42f1436905250a5877018ca2a6905f9ca64afe1738ee1236bed9462d19178b67d8b5a6c3324281f9edde4ca279934c71d934ed2e3960ee4da9fc1d20882b839653293bba8c370805a7aeb1cf84a864010e44f4914875a4b2ce90ff2853c80ff9329a43533fb7d941377875d7556f8cc98cf636e80035001b6f59edc318a217370858583184eeaa123383c869d1a293004a91b8fa5d65b90bfa3e7fdd9827a1de36c5d159ce18b0202e8fe68081a173a234d31b8fe4e99ea1a197dfcf917e3029b9ec44432d506dcf8326637157ac1be0dba3652b89ec63293e3732d8845e8ecf440d8b57a66dcfd0c5905813cd447129b3ae7e156730373b85f1333dc45ca43b68b86e8ee7b0fc64c45aebba1f0612a36f4e313706dfdb59140b1538b6564c51b4f41c244bda9f3c13e7c2092c8567e83ef89ab6b9b558e98868ad6266294ff3c8c3fb5978d2247118c689e7c4ea8825a4a7b1c87b0ba8f2dc9f66d3bfa36a216eede50da6599ed15e4b3d409987aa0f4afa7ceffb490b34c64c52c830249e46b83d17ba333e625eccfd54455d2b11ca13cf109cff4e46766d38f593ffaa9d57b0cde8debfd7b430eb3777daa85d47bcf3880d05efd6d55cb32a0083088aae88daa15e0178e6fc5a2f682b14f4316b2d41f4eed712f2b4f761b246efac77864d9d5753572b852578050fbae13e65bb3fbe23f46cfcc918419766ad001ed1402af5e53577dd02a6673d8e3fde790c00c034ba0894bbfa694650e32cbd35ec4c0be8cd740942842ed672f65a91d07de0187f8655342725e5d277ab5d7e1618d2649874f5b4e2c68747cec5bca7c1d9fa3ac4bf4b07ea5e8b4417f1c3f9d61c7d7d042928b756d9520b1a6b9af1eda3257936cc0054076aafdd5053061d00bded0446af8de5e90bf2d1da18d141891f886225136568a7914d47fca8226be009cacc9b2c0aa8a7abcc5cad5b0bdb22b38b909082fee62358fda86a4408063ce722a3e149498615e978eb215272fa56bc71117d5d7713ca06201a5d189d3f1686de54843a52d397075ac33d11e50c8f3bb167d112b39b74aab09a1bef50c9807d7c088089ea4d0328a9b81125a853b7045cbc5844ac178a3bf0b2b9c34f9b76d6eeac7a932aa37e22ae86062bcd83cb5c0a234f5af307d2c5ef36713974ff51f70871a06854aae507b0e921d19fd66dcfeff570abb6cbcf31fd006ebd7591196d084c3f7f34fccb14c7cac9016768587ee7455626e8731328273c0c201ed56968b4d577833037ad3ec274955be0606dbde9a05e4effc3b33757cdae568b108764dbd9dd8cea3a472e1abe15da7f3cbf4e36b3ce7f8da087d3a92be51f3d3cfeec8091733a7e9c0bbe669e411c67ab67dc932225f622de78751b20c0238015c04bdfd249eeb8275c7aa384ff7e231490eed411254aba0bba1860fb8f07f8ec4d907ad90676a92f28d2ff617333042b236410564ab8dc1b8976a1ca147eb37a2d1d6ad7c7e305bd3c68b9c0d89fcb28d87383ca6164001f324affa6bcb3a56a5ac60735b4767beea683ee6d273c781cbac5c21f17dd5388315c3bc571eaae482aba9deb58818c051ecd8038389ab114712ad2399d5388ba3297d23aa0234e01ee8f212ea9aec80b6e68cc0f695902472b03f20153d6940daaebbb07b03e8e6f6e11e07a77f42d509d4a4ec7970bbd5a5d21bbccf701ddb7d4d652b13356f6e214b18d7f34ecd4d096895057d82ed9ff376adb1bbe3b649036147abedd665d80161676d1cc53d4dfffda255468cbb2d8e65904a74f45e331ad06df0fb120beb2ed6aeba66a02565cf078a1b5687b972006de9249a3ab5f6b4e5673dfbabbe9d87b62970c9f83f571d1643ac25d8af494bd48b7b5db6bf7e723b9b62e8712e259e94a6a2328f3227ff3e88dc0b31d63a79a3a39d5d2ad23f5a76c8e36a492aa28f773121cb58effb53dd5eb1ab9b5f78d487579d6dff700f6e19acac7f4ea00c76673886b0e9a0b0dc03914854a8b15b38bc090977a9e80b7f3717320e30c3e84b617a3e12eb553689eb712046795d1e1bf5388cbdf17589aac33d0e45f209f2085bdfdd47fc52f8fa89e82c298d4b9440a76f2ad53cfaa65ad9fe94b39cdbe3affd6286468c3e4a5b2055b684ea235a5e9c018c9092bf8344f3dd3f8e36cdc408185e396203180927791a068af8a15957842bc06530c086c4ca0a2e349f094a21e441f8fd7375d5a552e60a254ad59acff1d7c436a5a00bdfb5adf6908af249610e695c4500cc1ea9c1fdca9b93b61537bd842a4259f039c8360f2f601d2d61d0d72122f75f147b03e8f8d7a24215e9a038b1fe29e3e4e171219b4aa10d4450279c2354b4bcc4dace7927864bf5d56631769c722cd59cb515e62b00a1816f7b3a129442e85383e06877851d7dce7b97f2837405004156759d397dffb381141bbd313f5af86f98e91a2608d170284ced9f7e5c47508ad325b96d8573ae541ad237ceee39f4785beab7b3030441094fd8e8d53aae523aa534dbd8a6b4ee77423accaad993272e633969136152bbc64a1c6670ffdd3d5fae1e6f0f6394a986cfae9c16eb2b4123870e9b3ff4638244dfd54e01fe151f4d3bc038d67e8928a2acc76d5e808afd183e70858c609e088d5197ad919facf3e731ae927383de31f44fdc0547388568a3cf9cfd8af0e6d477ccdc5e943b7e2f1744965215e899d7b67cdcea7f54993b88b48bf78f6933662e763152586c759261a81b769a8c3d162bba756d2c3499cc09376678988ca42bb7041562f485fc01bd6c0f8a009f453aca9507ef122c3c2221cf49b2a5b5d5474c177db90819251774031b59303d61017a7a9ffad2703ff537a60418cf08bc5f96f6b39d9b3c4bf2f29082bfd06aefd25218fd6d084557059e8b77081e325a525e019a3a0cfd85bfeee02437aa97d75b8f1b45f0483cfca333ca70329ee3eef3b272f21aeab18331fd563e1d4548e710e99816f73f642797871e403a0a30335bdf8a54a74fe4695111b5e06d1e922e1dfd4b09d90cf2eabe790891e9c1b5fdb3b756854b36e5cd5462ef39bc25aa31e3d77e6f1cbf7d0447c61f6998d55e7d53d6c4c3198fd692dddc45e08c4a07aa7ae7ced1c6388df3adcd02b29d2c90c4102ee4fe2d02cf13bdd8027766a201fc14b1ab3e8ad8548b7b218d0cd43a946f43dee535797ca13f27f9b2e4a3f0776e8728178a384d0761336beb4f518bc064cba6101fdb0bc3cbf65c78b6dd4961a057a5288c65fe3f0ff93383c440b69c0968fa47e7d5083b975ebb44947c0a446e7d2f88d370fca8fde6a5449fe457d860dbab3187ed8021926686733e9b5ccdf68b05a33d189e209ec58f7fef779bc54bf85dcda02cbb1f8236349a219de8264c80e7abca1d2e43a4eb03ed865e232df89d7eeeffe601462cd659a8bf97c2d253b4ececb111b04a8413c0185a6db5ab17ba1b2f5e909ba9bcbc01683e2f1035e07c63bc787b921b06075c15456a126adfdb478ec709b1e6bd5c3c931eee87e962d298cde2e8b588e264daf4c4c001107384e4ffff601146eac9e8c32d073afec6df4f55abf23e8f18973b265db130eee391148a2dca4e1461c2496c2099234bdd6db98d2c25c813685120cd7d10a00abfb99fe20265cc91c71a18bae92b4a4001ad5d78faa4d741c1a6b43b5ee2e45c1a8f7eb7d321f9a9b7d1f7a7444708e99a0f8291932debe06d8fdb377c8bc4ca13087e2ed048c8404a3dce15554c4148215db7def738e55bcb2e3a219a9d3d7a07d15e3dc1ba3de522246bc691cd6152c1ebf703368c3a261e422b2abeb163a8f86734310c37d86d4ff7c0ae46cb9952d16397cebdf2c7103fb2129a6e1324f66cc323744ef3315ca82d7bdde0b3862d80bbaeab51c02e7a92108a291018b8fdfdfa9ba3e6ab598e92ee3a016ad38683da42f4e613f66b520e01e8fd4758045bddfc5750b571e56b771e107fc5cb1e24cbecf949843b707f860e1aacb2a3d7c4f7a09dd8560725c21ca0f746a6a068fc3f1ddfc2cf11fdd80e80d40d26cf2c7e9491b300ae551a518175ca6dcfd78894e2672371c7fe2dc1e85d16cfa83c68ecfa7379360f8a5192739e4e9d67300b00f6c7de194ebdfcdfdfcb7c23956f149b5c018657d514780e6619a3c8b119f13b8a290182b6ae5a6a92be7f646cceff2e6875353a86fefbb20ab6318d28c27e11a7eecb10bf3d67c10375bb5eaf241a213b24f776cd5714eb52e4605c564eb8002a52b525412701f82eded2374714fa0f69024561819cf1e0b1b24e14116b45b766078147a96a64d0c3124a3c6547944eb441cf2f2055aafa78452e0bc47f19cfede62d48468cb88d6faa5f96538a7de15aae23d67ff38fc4cc312677ccd29b2a625d206e2974f0c74e0593d0ba7a2372fe66ecc0b8cfcfaf99b8ccb35cd806934b52706e4473d8b7d563c6791e8cb119fb5fcfdffde77bfd700afac5a85ecffd3ab61b6d35425364bf23a9c916d65961de90e0ee203f1f091f792f8d22cfb935cfa30336c7491d35a1e6da792f696254632ae4fabd7752e39c317651524c5799947b40060cdfecf4e40925b092f9676d6ea0add7b8a550702e6150eba89a5bfe2ad0e6717631158fcbd818196ae6f80270b8059ec04545aaa387901a2a9efc8734122ca45df1a2c2f10b07aae6402fdf2e5f3dc6b33c176d89c3d1dbcecff2b0ad126757f7f1df46343faa0dd09ee4367c691f86fb6156e1dd011e8551253563b2820f9a8f322507c1e7a6975d08e4704536733cd57815c386ce2bdb70951ae10e12c5a8f16a56742a6dbe80f4a66b15bb32798e3a3de971ff17e81752288e324f270e0d62f77568ae1e5423f17c5883b6685fa87c4126d1c5b965c67bd0a30b4aa7667650c6a46e90b1e6694580ec0be1e503dc2d4c05acef035d677c57671aea2446eaf47356430b11370154a8a250e23369d09e3b30bdb51e0e5d89859f7448eb8d97d045ab45a88999b07a150d6f75b344fcf3e7d36d49025f5e3661fa51b33f01b76a7a920a1df6be83850bbd6e4f11dfdf290309ede7710ba3a8f99ec35f287ac84b6f162ac34346ae4f0e5a3c924d14c0472b5677ea78cf536bc1e7d1d5323572b826498141ba9f0771a3045460af8c5c234281b8d96f36b5639aadb06dc101dd40c4f91616503423e412f4f8f38adf5167e06aef8d0daac9486081c73d800f034d0fc6da2d86c23428c0ea52f9e43896a7c26f66f0b3ed3bb7752f71ce73a2a8386a431f5bed096e089b51296ff52fd83375c7e9e6c9f301c212f258ed4dfa982be3495e38004ab12351395711c8bed896bfd945bdf37394a600db63e9e66f937d6500ecb3d0be55238db496a34628a8aee8d26940998f5abb25f91ee7adc74c44af20a4aebc960fc6f4b9093d0df746ba57ec2977278421981b028ea399d430ee96d99d8eea3044403236e679dbc8279352e0e6286b9896caef93b7a3e6411c65df19f5dab6e8554ac710a40a17f5c13e44d46f23cad5e18a643083ae85edaa9c2273894d4b2089d7879c9a2305caf6417ded6a3eabf77cdea0f9fb359c59291b2e724e3baa68394d929207d389080138b6ac8afb97f4136a79e4f64eb777f610ad5bd6f1779d74f80c37489f1d9c1bdbae20187023ee05de3066ccff441941c5c8b0402d40f049408bdc88a4ee7d476f4dc995ea0909c8086c744ff723747b30ef87797d3cd3a616516ffe42c1071fbac517deb925b91b54e6ce73a8ba3928805ba5fefb9da24b0822763ef8efa2cf0c9384fae9b7223624751fa7fddbd890626d7019b203bec6b25602b1d7521a731d6af0eb6ae3e584662b160ff5fd5f4809d80b821cfc8d46c0c5be84dbbd22085c6d6bf51b26ac1bf1de294e5597994b03c23852a8100c561a7863c6392fb872407e63fe2a193dce2802cf44ba4719c7932f06127c26d9e8f40a35679840b98b1fff61eaaadcf46d3ce60384f6a6be5ddb2207f6409f5b5e1ed50ffc11a67baeb8f98a96ecfad9833994b4905def8a4fc724ecc047d8918863c7b7556e9b2e09079369d66994fa0197c79e93ecb41b240ee7d6707d8dd34fecfaa503e748515a66ed08b8e214693d5635083f3f20a0cd195e697bc3a1667888c19075ea7060e302e2c7391bc5c5d55c4769a9cbdd1fcff0e719d5326fb0f0aaf455625a2063ee23c5a9a37bbd1cec39621c201a0a90abce1cd8196a43011385774d603fd43847148cb9032631b71300da99a974592295ef4e923bb37fdbd8399e58300d23998ed6265da0d4baec287ee63f7c6521c03018778b1f5fe111e306c98a9b038aa5ff4dc32182025de89743070cf559c37cd9390b362bab5f8dc1b5eb63ba4a96e36d73927c09a4f1ec186e5cfa0ad570b82c28ca5a0d51aa13f48fde792c2400e0f0bdd517b52383e5df2bc8e956ba97d4eb0f9f30b4ea0d9595c5b6d8d7f93e97e68b3a93b18e2646858b7beca33d9030634736d7d7afd8e4f3f71dd79c5cacf6664cf16b4ca8dba1d6d61a330ffdda022460c643a08e15cda28c81f291f826998fdf05ffda6f7a126e4eb451b3d97b81374021dcef046e31bb6cd9ad8b2832d5c9c12abc40de393eae0a55034ffa9bd6ba7d6fcb82ca2065c31708bb47e1277771aa5ed8e79346bbee98a5c753f1152691b1ba3859bcdc81c5b297b8b1840882fc5ade722590292100b2568c54fd3398bb5163c8d6e9fbc9e8fa5b8bd630672842d690ff1fdf6e27d731a15080c39b5da677aecf488ccaddf1a561eddaa0d14bbf1fa81ae67cfa8fc65f4b8f3eab042c924d6a456230a2f702fe74e49e4f45f781cae1146c91d984f0072234a202a70758e2d2eb357ea143710356f1718270fcd3b1b3b65115eb9368f268e8f061da7c927f0b8c90943a1d7e98865809b91a66ed905d55647b184c249bc261d9ab33fb06929bff203d0728d0eb13a04592b46b622b7f344a73ea08bb990fcb4070f2c7a8912c02fc0bb9746a769ef01acb63f333d10aa942a9201433d5473167ff0671c68539fcb2e48f1f7e5c9b1d19f6b04ea8c591763c104d22a0c8c39cde455acdffa792d84c440cf351432aba2cceba7a92c89c084a9ce3e77b5b4ee5ffc7a22c35ffb2ddab7c817ce68a5919f61471420e897f334b716344aa243e0fb34ba64c03a331a64df7a08d5b0d055fdc325507a6ce5f4d7e794eccbd1ddfc5d861fef00bbffe05c40351143b5a623341065c7034d3e638cd6bde65f5ebf26de1a810b7e982e868d3d4612cd2922dbb99704f1bd9603c4726d918e280992a3e54b5679bc628225e2268c8726be0bafb46ceb2faa0bcc5af8551e10ca587aa9bbb083e1feb4b2640e1b760221a865efcd4d90592708a33ebd05accaa2987e0077ca72c8d2d86d97e2643b7a2ff78ec9356a2d7c1d4f507f1b56801747dbf45e9a933f9681b7dd9ac29fb586d11a91429b9fc75f16a86cfb7dcd70234673ca48614a6d695fec0ba80c97779dd6fa0a4604a7e222cc3db0f45e7b8445f316e413bc53f118abb49061a431469eb1f63e98d371e87fdc3a39105b70e119f7933291a3d4e270e73b184340d48d20cb942860b4da058a5b7845f22dafd6cd88ec08cd2fe316c821dc7a05dc9327837f8eba5881a42fd162e250e4f90eda2ecd346d70a9e77a79264a6d5f0ecb5684eb88633012db74d80882560f44bc744c8fb8622cd87f5f14909f557e8f2db31ca61709bf3d178f295764172217a1e0905b47a597131ea2a7e522a4362e028fb376140e6a8c01377fab629af3d7e65131117b0574734d77cec8c7350a440b76d75485b34e41e8a6b0cd9cdf0fb8b48a08d53f3e04ccd5930d59e331f8ec508915e8dedf7fe1e9da5a72f79d6fcb66cc4617bd40e581511a7d77df23fb1b1fb4b4b9752657b9fe53d2a30b215c90f18d7c297907844a2a073860a70da008c27ee3008196617c247c354370527d3b300225324b7e752a77a30a87d822824d0a890f3eb2bdce370ee28bf9b510133acefa0adac7997ab64df3283f10bf669e80d9850ba1e4d40ff029d0c7098387a9786437d2289419bd7022e0c46a550d14de4343f9c75ddc11965e412ef086b68f9ae99f4631e8d9cb3323dfb5bc074b224ebf0464cdb40837949efa946e4f9607ab129697d6c6c73c906998b130f8bd26c75ba94be0427afc13ac4d0345c9875ab5fa5bfa69058ed90f5a6e86caa729f5f5f00ad2cce5b2c125267ff6ecf9451c473abfa93350ce81488d9ba2ff4060b8393809ef5998d56fc0811664649be696498c28bbbcd93f8e0f64c972bfb89f58ebc5735ef02d465cfc95095cce0b5066c51a03bd108678c59584267a7b11e7e7177a748accd786a43e955ddc2dbcbb0207765a73ef7d0741fdee741f658a3552de51093f047a0a1b61dc2d96b119d327d425f381c070a156f29922863d2dacb79aae7ce0bd5253eec370eb376e8ea8a041ad03fcf90fc1ef46defd76d64e35b9021e536290456bcbe99343431cf22f9aebab6a526021d9487abbec710d9393bdd9d46a7128bf3633be208af2e549c28103f24dd302f600e010e36fa9c321bbd72e1140d452d53c2d6d060a19cbb0715847c8706869d20480a6bbb55b80ab1c428d2b2d538b81e026a4c41c82eb257d486a35dfae15a89b2643f2fcee4baa35c8d67ecd79cb08b6b7661709809d0474235b455e13983306eeeb6cbd9bff25f6e7237049237b1b50225718d0caa961118ad1471ffc47ca97d08d635b64fccfd94824413d42343b2f8fb0276f3fab2fecb679dc5269c257ae4ef0fe47af278fb147fced2d7c600c0ef8549bad120e3130c8cb6346bb01d5439cd6ab8447ea7b7f2fd379864397461217b4cbe4cbad58b073328561b3098a5792c1408c4dbd59fd228efd0b14fb09df4b8cf48d2e5faf87e681b68823ccd1c45c79dbb11cc7fd8760f165e96a1e518c4693f44a1a7f6947d4ca29a5420c08e82b3d3c321e46dbdfff16c9aa37521e4913987ad63f238bde5ffcadcc354ced98c278833f9f9b28bc8cebd011edbffe144f1dbf11d79eadc1ccccd46eea31c69e2f5a1de998ebfb2f8509f7eec6208e0679212e2a8ad55b62531b399cf76685722faa1f6ab63d749db3fcc3074f30f71672de919aa8d9525a734ecf176ae92c85f09e586693b0597596e1868eb73385875a4146a0f693de07256eb06ee45754d9667bea87c49f35ea539f619018100eba2c6383d68cf8b060e82fab0a27fb22fbee8d3765d5dc2c89c758c61fd97aadaea2092c5526d41f888db1f4d2a37740cc64eb003d911b42c79e6c693ffa35f7e77d7202bb484ec2c39aeb6bcff1ee105ce9c66168d806f0ea4b5d300c0dc9e14a5cf59c90aaf88b234ee55de1540e832bdfc030b669bc99b9782a082c5391f0b54f2e4d09a64c5ee73c1e9e113d475dfaae796628d7391a4434955ecf816eadfd87f8508ea01bd4834980d7077c9cd457ab4857966207384bb32426c7d617db13024158dcd87a83b60fb3431c4339d3fdea60e89922981b79d1fb195f463a59029dee5e68d0646728fb664cae76d42b99b5c49093f166ef7a38ed565b43c3b45cbdce8b463dd69b60122f7f7dc5ae6339528ec84d41ba6bd112c720d8175bd998dae1b2a0e670306b2eb7b7cbd2d464f475832c3da48508070368b526a56432be27ec5a9794ae8bcea09c4d01aaf4589d70567571b5f1cffd52c3da04ea234db45e480513fc22604ef5caa75b0b2373c655cd97d714756fb39ef2f2209134ade6608d9d6ee728dc492d492a27d5e9c5b54e0e458d8e8e809d72f892673fa1118b9a0a45a060f8130b1b5af77335cc1dc7a52727159bc3008568cb5e4f6bda1fa5dc87ffb0dcc27ebce1bd6ccd7c8193925a520ffa7ea3ccb9cdc192047ccbcf450ca065fc0c2d5ecb56fe2707103743f61f93122b6cbb75a2a8f545f9512d69f0faf60bbddc46be115b26a2c6ba0095d4f4925dc429c9be51c0baa5da1a516907039b4ac50d58b83535f3ebfa6cd1161477fffd05f35699ab2388a524349a8cb230a02508d4ed5e2e181f1c001c07f78dfe2f105e538e23ce30d3c32c46fb91db446503008a8a3932852f93cc920deca4b4963596b6c042cb2c24deb4aacff732c9304eecb5763150d3109559443e6528da7b3acfe06bd5bb218f14c340266cde1011c6beb4e3a824f15b502a7fdc4ef00295b38a9cd52ba6b98eae3969bec465f887718bdcf94a66a8f93b73bafd84045c42596b12e4dc7f3bd6f4e854ef583aa84d64ac2dbd0c90a8fd2afd31c7065b6fb5ab56bdf86e3a6e15ac7ad6e0baf78a360dd3c46f0713b4ffa823e2e88f80c8b5fdf7be9c55f84b63479998cad650ad327b71868a550c0519e12ded615a26b0c68eb663e76356d74b9bd0cc2936e62065a922923d847928799f1c20dfd336dfe5de6b64bc56476759703b2e0514672088397468f4579ad87d9b696c3a53a1d308c380ec17257f7acd4c8063c0a34aefa5d43107e4b23e8cbe42c12b7260ab6b65a864f30b0583fca695e350eb56b73b1425a36959531ec847815108cc9c6772643872bfcf3305948a087b51efa11c1b446b6fd14a23ab0b2a96e99487ae8023b315615955b1d01a726efff749744b7073a58135def56dfd70ecd7ea0c57ff5d0d89935fe4be8a9cf729e43e6556a3ecf477f87d8f8ebfcfa694bbab7ba5b2d0016a0519f3011d7ddea5100aad1acc3cbc4ba789b10ec6a2d28ddc78dddb45e777715e947b24b60a287d6d84c80f237ba8d11768fe51b6dd9845d67266d478a822574b76042ec72da4a81a721b0f6a949d036cee4e1b142205b810b867910fdea077b9b101f198c9bf1813ffda86d499a453a55956e150a5ee418248591cff69c9a9c2ed42bfcaecf45a5e7fc1aa636d68c70064e0db63285952d0145cc4307d06d93151672ff2717691762f39eb7d1a1fc58499e343fa0a37558c9e66536ebb47c90f3626f49b4f21aacbf8f2ca12cf00e0dfc59e351ce171a412c64d310e51347bcf1cc22dbcd1c2888dce8c9b451869daa21991a63186a547acb4eccc9a3157782ca18a1e3e056b73f7875353dd66b9031358a0a27ad362444e94d6e9c51d0da632e782f292429a9bd0f374ef4226b3a9f9b389661cf4c901a8d31a44eb6b7b1b11367fc696886d15128a0f650ee084344884a93532d6e91df12461e2f08058ce5ea3b1ed9b99c6c8da6b2e4cc188dad6795c23fc3913d8116f7a243a7bdc387ed7a4e065a5513fead566feae00537e17e9a4805e4d65913200ac03ec7146d5de6bfa7ac93c5bc856b8c4b64ca628bf53134428016346cd16a7327750cc7bf29f79bc24010a3e5da7a0ce97179e5d6400b82179d004a62ecf2d8abc239de93dbbc421a2be7d372d5dff1e060870a50e64d24a076f1c00e877d1448015b9a60a7205d519d356a0c927bf726331c47b3f40f8355a432f2c66a52b6404de8743e88d0aa699801e161b8eb3ac3b769b9f168a5ea4341f7adaf20229b5e2ef09877fbea2a0d31fd7125294be308a58af8921808b32a7d846f5cacbfe0ddde2cd6c8959f7a62fd112d53a6d98eafaabb6116b3c5783e377e27709a2cabc5c3f4bf9c522c66f39df3ae4de3f2e66dba6b3d4e4afc564ee5546df8993c1cd837d2e03db2ccf0133a36f0a2ea3f877d88b214f8e5675c17f3451e7597e734456cb70fa4b119b88b715d1119e8085a550627fc8ea6b78fcd65ac8d71448a4de01acec86bdef02231a9b0be29c3f0f23a4642fe934d4ca961411d1e3154dc43f80ab19affd3005c0897ae948c39b8f26d86e60f72f538e1ec9b6b0f0dfdea2f5d119169aa9b7c9c29bd874d3147cb99fe63ef274827f4ffd68a74a1dde63de993f1624f46f6916702c167a35c98789f2c3c95342c5aac7095669fab08f2b9353f015409fc61e5c68eba80c8678692acc540e70fa2529edf21d562802572a37f0c2c494eae4c44254cfcb3f82977558f9cab6fe795558e29947ed03dab72831cbce0d4606b730dc2bed2fe5c589692fc498752d2f871b6c23fafa69eb8c0a2b991b403333f2b6fbf2d7bff38bdfa338c2cbd04abf2ce7dd4a5633925cd3460f5ddc3349fdb584619aa14ecd019dc46f7c180e37c253dbc2167d6582108ae2f7ba0a62a5938294235182c7113752f761068782c608cf508ffa530bf0341953e365245e700a84f30906b018973ea4d5d9edfca15d5ac351361992ba5b33ea0ae9caa9b33b79a26b6659841be208881a4b037518ac4f5004d7625fe8fa0cb70411696d4497a776481b2a373fea67e383a0ac7771872d4ce0f20131d35bf9d37d3a6a1f5e6ce2796cbdccc2176ec159eac970c7eb6a360b70cfed134a5881ab97084f2c0cbfecdd7e278f3d315cab697d9ba67d44abdd95074fcba3a644057ed1fe7dba30fb105c60fd622c151ec20322047b3d563a3c4ffd6be2218c6cbdd47cc07291c9d7f15cb2ab775b6bcc482b81bd9d5a97324dd22422b27a9c99af3838b6cce4fe8d6db1d38879a6772d47960474116a6d152f297a365f5ecdb27f53ac2e3454c9946c7f1b6cfad9550fefb2ecb091d4f1c673e4d79f9ff689650655c1d0b0b51e14e72f7bf65188dbef92bd425ac30cf122d5f61aeb869a7545959da4ffd6615ae10b5f6ee7e261d22ce4364a69d5254c5071be2071ebf056b8a2d598fb2c056e59d6bb29e7030599c6c13b72be48de205a08727adc211615772e63b9f8a52ac748ae7bd3bf56f8bba96f9953a52d4bfff833ce4c34aba04b8e4701602ac0142266a32e68940c4f43cd9f9aec6e25c5825db1f71d1774f7920bc93bd7fbe7e6f3436fdeb29e44f0b77b29ce0c7300b060705b1524bff02e527f7252e22d91df4587a76de5cd8d69375f4f13348b66a48b81095005fcd58f6d946b422d62c5da25d0445a03f9dc305a03653a7769f115ef3011080f3e947e25d0208eee010e8a53319aff60ad815ec3c39cc872c7783a24c03c68e3003ca4ea6c5acd91325adc71999e726589a64ae2a4c6f393e146327e4d02c823e16e353f3030fd97457ec6e9ebc1e2cfa5ae07722a2dca0683ef228a4c9597c8b88ffe9c0bde2fc97f97399e4e3ea50d8b350916b040e95e151d05f3400dd6bf4a177cbbf7d6cc5e7b46994f563f3071cc4a11097a7c915eb6ed8ccdcc93012a4f0d348baac056f4c53e068a66655a4c5889575e713fc8094c74d43032cc388c6187577f54029997b5a8cf08f34f9786a0d985daf5ce63c9a8a42780d54ac28f90a838e35722d62bd256c586872ebf65a12e3500d01afc5d46746aa7b560b4fef07948b5f8d5eebdb86f5c907dcd63e02e87d4d7c2c3cb8eecf19895b1c408bcd918c36a6379f2d3ea2dcb9c38d4c727f7bbe8d174a6004ce25ad2b18b0473b05bef7d036841b458df5359357135be83711d7fc0d10c8c3a182a6e1667eab1217b53d446582049dd076cdafb0701b59a7a841eaa8363a3f6461d7eb054690e19bef49704e391bec3d74dcf9efcf90e3c9335609119e86b56f66619b32eb6c6aefe61dc0c4fa61f367dd2adcb0f4cdf4f459b5e6aed97a7fe136166e299450705035c7f9852e9be3a70588f6c4a463c2ca044c478deb66404c4497e085be158ec142bc355338af7f5b32cf51b4027b0a17ef9408e273fdcc674546d8e05d53b15c2c8ac449110dc9c8285df52bb48fefe64578c4bbd953dc4364fa1047875f6fd29f9b9f2b8c4a50d4d9fa8aeb7c4e3c3a926248c121f85cb1b28f0d16774bbf002de0441e728b3f3617d74ce5f84db4acc4dd09ac1804a97b88e81b30133b203385ccffa3425302802e585670475a3c6dd96327ebf2d4ca0decff42af26e08150937fc63816cf635206e7f542a0d0a1a6e05e6e8c4bb21dc9c77eb6abceee9d3c3063e397d08c2b60d614bfbd0e08f7d53f8ef0369bc4944642a38f927b7e136c8caaf552c0adf7775fdbd985de0572e5751552a2a0a6eabc1cfc13642798c0ca1b2313e33cba53feb364260d6c16c2c5f6a68584b2bc97ad0fc87e9e37423c6c325215b48b766712a14c1e3021e7d68dd4579c2bc78b9f5dfd1309a47e00df9b5bd83df580a2ef1c66e271e3fe286506567154ebbb24d87ec2d15e22b425543e1f5ebc5754e3702e75dea4d7275e685ab627c88ed30e881c7e7b2ce6e2d9cbfa0dadbd47cdf7f1be690f0145e6b432a8cf9cb86d7a6775100b3d4d0ebd08526aa67c7b0a33317902fca25bae95431c8214bb53828949585ae66ca2494305a8474d71f8d5d743eea9bbd4d2bec98602d9179b89a50d077e21f7a5b5d58a3395359b1d8bc3810e50c6a2dc7540b8b3c3f656e00bac28bdd317909c9128688bc045631e2f319bc74ecfef5d1b0b468efa7d4715f77285c00b71a0bf62fa9d128de821efcb76ab8d598f52130587db28e05e3776255cec35da506a8906a36d16adbf16b6aed64cb490a1b283272b7e51a3512263777b1d03447d6f55ca546b3fbe1dfb5f4a93d3031fd7b2000138e6202c5fb467fde8ba17829a1330169b6794803597586b33b2384678b21cd51a3c84145b7d413244d6e126a8ff4f84e4be6ab8a75460e5249f2bddedd1507384d964fcc11606dee77a68da55b831c5e9453b3d002dee9be7ff4592a597e7d7ddddbc3366ad2373cd577b95e78b14a7a9914eadc502dd03b7675a97120695b497dc80ec15e6523917ce52bcf1643d9a1003538c1f8a3fd70397a955efb8fad2dc598c45312adbe71f1a2d0c76ffe0c7fa8d00a4bf4306c57154c8274d8473b5071d301b0e5727e43a285e8692f50b7fa636a2ea4ba69b45c49793fbe0bba0896ee09b0a65fa1e8d1046e9f3d5b452c604d36f30818ab868993b5b470a3170bcc6fa9aa9077ca8e10ad24c6c99cc5140dbc5a79ecc0127235601fb81900e9d49f82d34e74b64c21d370f8e69518d00e7772b23e736801a807fbe2ba7484a6b7dcbc7f7e7b751eb84a6cb68b0f055cd10f109c68fdf380e367836e6ad30ba91504c20ba00f9d7054a8ca67234db77bb5e63b93d628491c2e19fb7863958c4fdd691c8d949ddc5e1482086e423c1fc86caae3596ae26cb82100a3c2a43ebc4fd6ffcab5550ef034e390cc01289f3af0ea20559e61d2d1da9afa6bbe7bed361ef46f273144ab3264b7521061825cf578acdb387fbc1051282303b1a08d94251d49ea153f885bc99b303dc7c81046aee4d4eff6f50a3dee20cf496f3693e7f77df730cb0d71dd7a857972989fc1afb3837d40d08526193891bbe2380dff1a1189d0b4a4f4e27f46b29e722dc1a500fd82e23d81784665c640e7e43e5f056fb8e2dbe2d614b8033bb77a048874d8e0a15c0ce2fa6815358c4622d46543abef75c253b7832eee0efb03ac25228f2bb61baf7b50459fe0cec08017f4a1d78478e83c56ab1e6ead68368c3dd9ce8f7fcbdb5f520d41ec19424765456f7ff3578822e91028ce194330e45674e5f8ed5b3d2b884529b24e606ac4090693961f90a64fad8e651343d65368f8334e5aceec71d282e13bde68c89ff6119e48b094e0ffd41ee80546a71f9f11c5ca5014b73e9c4d7478f14df7fdf0ea055e7f29ba9930de0a73dcd03ddb2abe9d5ce76ab8643e635660b5c887455fa6134ef959664fd4476d7a1de87c3e462b01c9f95aef036f5fea1fec09fd188898da6a5dc7bd5a16cb6eb222f9cc08051957ea927e48b63124e8ca383839bef101824b0a512aba05eddec9fb653a673e2b758dda6e6c516318c03d475f666d5b2f078b6a415cee5da01cd8a1d5cc694080e5ec22a8045cef894ee6ef4f9cd0896ae30519c0bf4f9d325a748dac809e75f6e0ef1f33c477924ac2fbc097488749cc45faefc87b102e995f00412d20927116b985eb629f69eb7f242e1f3dbedf051ce6fdf87c5cfe8653b8c1aea89c4918ea00b4ae96486cf2feab17ba7e83fe76d7cc9a0e60d4676f6367f2ceb31d7a853fdfdc268419fa8b788a3ca3832a1c4e1dabdacfb2052093ea57f59c7aa8b20822072f9460817b8557500b7b6cebbc7da4d0953024fe3086d8e67c68c37b9fef97fa01d99390cd00769fc84185d164ac724b8d9e8986ee9cb38a4a96098f00e7a09e4d87941980c1556048b5a1d4f83528b42638660aa2a5436225b6ec0685ef00121a01bfa439ed38b887922a73f7a14b46495ca70346b06674036467b51be50a444230a95f265147aaee83781f812a9b21d633918fe496edf762abf1ef4563b00360482b63aed5e1aed47b29b0c775ece8eaec66c3b1a52f956d6bcdc97bc4b96cb57d108e11e3ca1b7ff48c6545756ee1647bf272869b0aa6ea49974f1d83df41275682652915115a35d52782747bde6fd0b74d47f7a80b269a95ab3d9efd9374b77f0314f19b226079e1a357a278d61e47fb55a71f90e3973e5cfaabe6467e3da73f8854d4b34280507c4820bc1f01a7e7089107ba4f0e85ecb3a7703a4c5552849666327dc44a9d206c2610bb0c6ef9a46f55201ecf4a1565e582b1049a9b2d37b653b9ece36d8d69c4737f1d77d96dd7c91a5c1d15cc0b60d1ada60fddfccdb70f712b3ee36866bc59737197f22174352a9c3adb2bc2df0997f0520ef4daa5788fa7759a4f614661b6b12d3b973339a5df1634811afbff85522b605c3f83bae76c6ebbe1ed15b1989ab8f71d0a026d6858d67a8efed9555f1e2b214186621c6506a7a23ff47b704c70e8471a838a89b9dade72267a1f6143e2d6e1398a1cb4c46b575cd474a96cdf439b0421bcdd334a560f3fc3f3f64ba0b1c94eb8fdd4e0567f1728094bc322e15ff992e2a1ea8a0819cbce4887f3f26a582ec813cc57452811e396611d92b733a45932de2cfb778b58343c2e4ad8200f9b5c3e0fbc0a0c8e2dd1af56ef3bb65bc5859a486ec1b5b673cdc9113b19a6000d1be4aa793bcc1e1298c69df6bd5f38d9ac4892d05f176b4f4ce374a3e7b4f0977edbbef2ff069697e5407cc5dd3956f14cd3eb7dda9fea42facdda8c4ddbe1687b2f2060cd454a74467a7c8e336a5e29e77feec889c1546059551f2cdf4d397d08d294fd9feefe515efb42a14dc34ca2054c5abeb4ff8882754c75e832211c448652c3aa71c1b538be2d1ff3ac6eb28c28a59aafe79b6a2f0eaa7948b6fffe270a07ade5f5ca99a6445f7fd035f398762501dcda282d69b912000578ecad869bdb6f4450c20f4c39000a60e74b392a7d36c2ee79b80a73b504052d5703a0feeb8c113afeee3825fb1e14c16b0b9cee5aac200c2ac8184974e24c8eca3233048dc302bfbcb414bee2789b83504a00632ac7bd81c9b9dbb0b97ecc969e3c6ff4a51fd2c57512f2b8998c2be995a27f07f4da951eb71ffcab376d2ce4657d9853b2722b1631ce9090556977e29f0f4acb2666a4cc397d9291a6dad1962f1c6ee59ca3c60ec38c8de83fadbbc1a62b030c28f36ffec3a3d8435dd41cd632e043a31de2a34d67e8b5cff9defd0308f0491d3df0e4d8859e54aa436fb2c75eea0c6aed5206865b9fd8eacaa07f2ce7560a9fab9b74852c8a75b93ec9e1152add5bbd8177fec1c11b8262097a3d92cfbaf4051eb9ae43e798914f6f4d92ff655b33792fdaa818c8a3f32f7e86390cf8fe110ae7f548d693267072415fbae916ec4d0bdcd6a765d1766eaca8827349066b6267f17f64893f2ceb351c3aef0f8d5cce7557c34adb195ad09862db2b8ab4bd7527a8164bbfb2526d0cf839b43ada60086a4ffaba20b430350487e3fdea07e333f343db6a7b99c2e1c288ed910dff70a28a8dead1c7ffc03d084e73a7bcfb9df5be558e4b5fc79cc05243bd047a1e8b2c0132494421bb339b528d03e0082917dad64a3d4ba7410a2fbfe42540f1e260626d3b9728675a3dbc16b7aa92a042d62b00a9ffecaed4e039f365ea9a401afc892a89b2c87c76548f232eec9a630498afcfe20d4913d710f1add7d525a0e468a27370637dcfeae844b091333894adad63f6d7d3f7a2a1352b8c9f58bec369cf8b5b8cb62b075156899e243390fad654136b119722139cf92c1e59c9ab3d03fe0ee14141e0636298a70207f1503ded9ef0779e59e685fe2b3d1fa3acf8a25b937e88ec6bf45c02a4f69862b66a36879e76ca506e450378bb4c22efe230d703dc6634436b3085a01266405b7b911e0f4d2decb25ed7abe539f0cbdbe3cac8473a7f8e0cba89dbc0aaccfcbd6c439f576a5912ed6100d8567106ce3019baada837bbb2b5381a82712bdfa6dfdc4975f3f67652ea30131fd3104b7b674813e2bd3aa31b2579e56be5c2469f823256b5c8e69d022fd9c12e3ce20f12b013eb9e0d23af6ee2bfa02a73139cbaa4fc1312ec2a96b187d6f5518ee44cbd02aa6b14fd9c18f46f2bc44db46a12655daaca299ceab98c1e5c4bd2dfaed4f9834404780cb78a55cfa2e99e97404a0436da77e4ae3de57e4dfaed7746bb1a37d1de60440b3a4a0b659ab277be08e1890c42d4b0061744ecf55d05b78426123151e50ef61a1ea49c08bfdcff9d5944d5728a88aeac6e48e2cea4f5516e0c75206e0f1f9f4246803637fcc7dff1f1ff012fea966c3dac013163bc8f8acb45cf45a016154d89100d2bdde93b397d9b0ac9ae7ba57f9fbcb023a1d1fe6dce17acf2ecb47da805805617360ee7a9df3b4c71ed07f288d827e6cce83b8f3ec26d26c87b41bf7c48b76dd451c7ecf6074226e0166dadec3aa883be4b09d9e6702353260f674b094a92fdf209c062c8d7dae680aad504777cade9d2b139654308d1d06741cf2aee15f633c3c3a66b8b695128f049bcbaec193695c720e098807190ae3f8be14384d8ce3cc6c6e0d2206d2df6a5f5b35e7b3082b0435bfe6ac597e6f2fdcabf003a5c86eeddf18d006e9c628e0abeaea7eeb9737a6c2d619a95793e1d08ce6e905b75535e61f282b9bfb8e2a5afb85f4a02d8af7534b5dc6c5214fd305c49970cb802074f1fe28d3765d466a618c208c6a1b2335c0a25917cf6342601d1f4583a5c570a9c8d9cd3ce5d33fe4b9e3f537909099d75f921358e054d78818372988d98bbe0c618e14c8812a44994298a2cd58ce44d363fde1e76a2f32e1006d541ac7b9c4124dddcb24252c5b4ddff32121e5df7193f6da60d6518556b376ee1341cae0cbb201db4e948aaac07398e6489aecccdf4247ace585f3d646afbc3f9ebaf2e7ec30bd3737f39002cee630ee3af93570749a67e8d051cf6e1848f54794e746e5d02b61154ca7ed2ec65e4e8c04a4a42d650aa54c7939d430f0cac26e0309b7e3b0b65b4242275f9f9ff9d6ae6b52024f6f8117fe40325bba7e546057f313c28ffa9109027ededcb9aa3d3c9aac17a91eacfcfcec237c4033e367bd6f5b469564637f4bf186fbed4929a4a31c1acdb2e42d535aaea6965e74d3fa04d884a72923b04c42291ab4179f5a89974a15c75f01b42f49de80a0937823b26d3015e3f8a1cb01c7892a6f6e867daa2185c598be5980a377b0d8ba34f5e14cda3e0c44c842bbc4c5c47f35c27dd4d13c090d40e6b95e466194ab3c0ef0df37ea5f22dd7418a3fcbd96143af79e8fd15f275e182b03f45b27a572a033ef708335cfb6a8b22dbf2ce5de5d31a490ec897bcb4c24a0a00d27cb2156c13a88fbef1e2f7be52b973142cf59942af68fb55bd48a698efd33d8a7bddcd1cf492cd38a59c6a360c0dc5ef5a4b067813c2629186147cd5a7023ff033d7464571ea4ecbc2f2ba4ed77705c5a6da0c98cf162df003daf953bccd7f513a7348befe07dadb98c56f4af8248ba00616e1ab8894f352c0ed82c8dcd48bbd49edd0bab0bd8fdd39a845e81416c6e7e3e67da5e532bdcb2d10481571f0ed494f376bfc2745a0739749c18eeb4ee8586535cc45126eb540a3d1fae99f3e962a88e2ecf74ffeedc83477fe3bfb9cb8727aeab6c4b67fb59bea56a945eaa2d1ea3bcbee84d11029c2dc6a9bade50693c6def294baef1d162a40eb4a60914a64c51e7f8964f823ec8d884a5bef4c1747cea44be8386497bb58d6434802b1bebb9d37a1e4afba56b3bebf95182fcfc6019d44f3f90c63deae666e67ffb19e204acd120f6e34ec449d9d409b3756486776c1c3e75459680501f68faf03e3efd5c862c5141ea4c21d2d67d1c660ef9cc7914be44cb4c019c95c0366306afa20e4220d3716437a4a1fbb98d1d0874584894fc2f34803b3790b814b62fcba60ea9062ba238f5fd4f72f77d056ac9bf5b16f42cc12df0017f50d0a1cd3471a123eb892e567f963102ec762a24468d206fd9371e4e25bb1214d8df5b805f5c3baab9b5cebf07fdf6847a5d53776d4b801e43e8d52aa21ed6945c701cc7833f15a495f67aba7bfcd5673652713bd036bc3b4dd7ab2c07382390504c4659555e77888169deaadd9c1aa5900e5e40d6d77b94d4db53e5c0f7e382f452966843ef38adb37af52085b7a656e708d19437683236deed2b995ced40aa33b8d63877896a423e4bf85961e80a687150f0b4a29ddf5267fe4aac8c25e648fd00beb2f061de0ba66c9168faa042610df7008036f68e8e1f2d2ef3b06268c0b33af7a0ce19f5272bd5b70992a21d8b11718b06d638bcb89cfa9bbf620d3b89f6502b944914184ee01c17b8dc03fa03ca3f7232bd263b21e9c64f71238231d0c7f353a629e36a4869b988126ac14b8e04a126d85f62e6cd408cd816f07edbea290d44b3b03adee623a79380c02c03970327c0057a7860db885391accc0f29fbff27ca47836ec837043ed12f724a30d1ade0bdf1d13bc7822d6df4fa94dccb0f850ed33c5a42614e63324acdd929ae39b9d8e1d38f1da23b5f5e8f71683836ec4634f8dcc5aee3d370ffd7cbd2b44e0a99018c6e63a43b6cd7e1784d733497880fc11e23f9e5d29633f815984a6a44c3c82d2571275af1712c6a1e40b73c7c410f56a41ea07f6b7d5f9110d7538f2f144431dd9d44325b42db3ec869dabd23d19eca507325ade37e4fef0f14e348293012cef245bcc8405cb860bf281ca29d755556ec9569a61e4a7da9cca92036c69508805c462d2c5f27f9ebbda5743d575111bca5811d370a17a3ed518e5c35ed46891c04ab5b13b9e59895559ee7859d63261b3241ab231c840862539b4706cc15dd07e48c235c54d8d74c4fd3334b348d85c176a3e0504871a16db019b1d3f52921fe5c6d025c0253decc090e338bdaec9de794e07ace5f34dfb8068798d9697d8e0132f96e19dad426905bf58eed7cd01dfcb96d825d6a4514d5ac4456873dbb4137682ba8b314a247b97f4596910888da194f5e5cf9f169e176a15274a03adc872211931a76c26cd7739ce39cf7fed1de9072a9d216262c42080ff9402f333c8d16899c1cfb3d48453483c99d68da9795fc0b9bc9ec827f59bc7da8e67e9202dd84e4882736d0dccb3e4710c6bfdd7e9c510e86814f57799c13f35e5751db1654e02852fefd1c21fa2a01ddc79d46f7f64f3841aa3cdab211c10612a4271d3565e833b360af8463f6b20d3798901bdde32ebf167614f6ea549b1cbd7325d7d910df7f859e5df01afbb684ea6cde0f1eecc04c46f2fe44748b411651eafc6b048825e1f630686a763db9ce6626686317ec823f38798ec907fb71f2e90ca741f294b48895d905c3201b6a97460cb9eeb177db5b8b3cdbe04bcfdba8eed81f5a56e88b8df0498c4dc757a21cbaaed3585de8ba0b4650b526337fb625ca13aa9d8d534174c76ea55894243ec594c9ada3af3b435c6a135769dee9c832384b8f7bc2c5001e4aa60d27cc164c6dd15957e80cb93ebe6782e5a7e3e19f2b4763e2a34939787363948f470a559b1ad2e538301d2254d5094a98b8fd392f854c11eca7f9950474c73a74f10aca10a12e8aa1336efee97ab8e9ac1f662afd32b120b0279aea414f85c9599a039edbe4e3ff81fd6ff4f36f05afbcb98bb024cd0f2f410cdeb09749fc2c27c58f28cddfdb603ca72a9c79a9e00429dbf8e3775d671a4c1aec010db4106665d760b08b7a0fc8ff436d689d0c26cf9d55e1756300ae802a8024b78d716babe20ab92a3a36dada9fac41d216350a346a6ee62176ab699d2a1004a7044e7148110a0203b3bc9ce8ddcd894ed4ff58f039586fd24370247b8ec4a0f139c1f60b90d0ef26bf869087c55434ad27fc90dec3b65596adc70ee222ef3a80faf2049941f391580e50a5a1b68db317c278836cfbb1ba821ffe09a81bb826bd9ffe08aa191437f8a1f32e8e37f44e0f643dcf0a66f8648d84bf92a5546e612cc42ca71956eadcccd9d018acc3778dff1d154d4d29a380f3681b45561130ca75844b4e493232b59be4821e3a28ff4444794c936ab29abcbd6a9b8edc79bd2b99ce17acb101561aba9a1017b89c4f5217397ce559f67d0b3574ea46d25df1c857865dff11cf4ded1d03c4decae24d6df30ed78f3126174096de49d56eefcebf768ea51736b453df5dca1f206c081fd0face2003ee112dccb44561342152e23a02a8a2638340084db282bbe09e7ca73615111aceecfc748eadc7bda8ec924354a0970b07466026df75f9b94e9b18d22e1832e66dff8cdf836703d6f65a08638764b09ba45a4d9f9598822815e481ecc6e3250d41e46756dbaf6c6d265663a26fc75c763818943bcf41d657cd16b28549b9372c6c646ead9ece51dd9eb9da416ccac756951b18c743cbc2dc0e3d07e990af90be49a330a704034d591b9241c1addfb12c003458071b0c3f2f96491baf426455216a4cbd23719d92995506de3c70fcf3d0cb063064236a4e7c16223bb26657ac892f61d9bdc43350e4f29e1fc82c4c875d9aa4f17c298051daa174a7cc2fb1c6b6231c7288280fd3a31fb5b3cfd6dfdc08477388b04efea685ceda9e71772bad9651683b0ea7eb34bb28354328780f34b2f069ef310625300ba181ba8ceb20e92c4d6e96de57e6ac79d9236e41d660fe8c7c80d90f0099c030d0802c27b2e20284fef1b7026dbfd08212b708d64404cb3fba220a19c158648a0185737c2a3ac539627c03a664793fbffeb9bc245897a476bff14abc7ce4ad9cf021fa9e4055a48eb9a9baf5c2f3cc3ca11d109b456ecdd1226dc4f59e9a991188df0c083ab758e35e5590135130cfade3ba1949e2508310645dedc45dffbf54e66739a917154cb7fe1d83296f46375e87477864a6a806b77d33bc430c1f8deebec408d11c4641060cbee567b450695e98dc484264bbadaf3fcd6ed810cd17b38cf1e003fd2878046b8fd3e0027279dcad7b2a8dfda0bf169dad7f5b9aa23a0b7db96340d613ca51706d97ef49c503966a2186d5e064b37b0d9463ca0744a60bfbe4e9d52905621ee4f03b78aaed44db1f23508809796d6168c74ddd893479f0527ae44bcdf49c3c0caebbce896d406cc0de4e79c77b74c5f8fdda2f713e49e4c7d0e9584e1b3a088764d7241d5ed4b788c81fb21e325d27004368bfc0ae003ff10344d774cdd464233ac743beabb32aa6d32f10b02ff01f5e4950376f5365e81113db03fa5dde78b2fb6ba50ba22f9691213ee824a353e26ebd53aabed974d21865d909ba6293c4cb048fba6159b9bba17bb53a62717b5ef1e719699fe96bffb7cc339c98f13f98def77893be72c30f6ea7ed48561103cadfe55233d3015e249cc1beff93eabbddeaf8a8038ec0d8de88a84e0750ebd5da64d4a05cd73728bb0f4b699ba9700c4a69ce0a7489678af1a3388f4419a5ee931af485912e4874bc6394432c95541153eeb6bfdbac361f9c4651a4f8651026ecbd9eef913741438fc30f3fee8bf68dc79195b5c607d66f019386443f7c6190952df91cb1cd66813ff4c3898e56e7694c0c5135f95e79191ae420ed041a7315c2210deabe0ca9f63535b50c430fab9ed2102ed4ffecc1d09a2b40606abf93aa9dc8c380e8b0503d04bf5fc4310a271d5b9f3e240110444addd4c1570c7d9791f814e8f4f3e6ecffce2bd2a6a4d87bb7d11eba902cb134e0a4539f007417499802ea8145d18fdd016968f119fc62f44c778a6ea3932de00d7ca14cb2edaa056d1139d9a14200c1d9f6105202d94c849c0abbda885498b70bfc0a153bf5e72bebdb9c957c9df967c3698ae9c65ecd1549fbf0b85b90a6fbd816131dce355d0d5ab2d4690030216edcff3a8a9d087e61c70b9f8b26858c38b3137341694a5768bb867cfc850def6bc77cfad389473ca5d1f9e900fbe9c4541414c12a21d8fea60a34d3eb42696a8686a360286daf8f96e619ed1dbc68d2623a17959a625fe2ec980207f8c82e17951a5785800a41e46ea497182101039711ab6692a4bd287f738abaf4c526d95b09e4dba686708dffd288e4fe7c775d52ac4bbc95ed1b24ac66861de9a3fec5b515e537c2ac0a798cbf7031050ae5d19c6e129dcea8540fe33920f549454252fdfb5f96ab737625f8203ea11fd6e659e6305f15da88dd9d5aaf89cedbad6553c704d9a1d04d4dcb396fcc9e8e6636eef1e8134f3562a6189acaf495e8e9924115adac0c084bc65118b1e4581e67cfc1f55658d4f6c1c304c1e08b7dd7d94831ca8ed779c3a17c44c64ac2881da621c12b4411628ac464c292d4b73e336962b06a43ee1cf707bc2d889e6f672ded4ce99c44a394e53a0a9948a1538954fb7fb99b3ccb4bf41363b3f72dc9968a86d18b484c34c3f90183fa9e58527455a512f762a90575a28234efb3a6ebd83fba587c22d9fe8a2209301f17eb03dd5d1a726be171fed3e3e8b091de484db1ecb74586ae07ce5dc29dfde28cbaf53be80813737c3662fcd34b273a1c655a336086ac797cfef65335338edcfc2f5bcfcad0b84e158d0545f4eef522eefd765047a8b97f659f211c8b6db14ba0e587e1a97369d942bc877f7b2c15412e865ab6b4125e737e2c332dc31ca889e1176ef119e7104f247d4644b4dadedd3eb5f1fe90ed761143cd2ba0c885b92733a3127940c3ba7a503c6e832d669a620cea61c56aa9a25e01330ff3594b2d8b426759170a4afb339ffc179f4c14e318a376a0b9042cdc63ea87e033e61a70db1b9596eb6a2a8aeb11b49438f3a0f4de574a621f5e2b792ec23622faedc58f572ebc08391032d89db3e75fd5df61c3910eae53963bd3a3b4f4624da4e70e9d6070e6b96b119b7ababaacf958a72a792c32900859109eb383772b63b73baef8b60cd1974fdd3a96c67dd8aa55bc7d0f243ea0001f3e66ee3fefba1ab735c3747a84ee3354957b5fdcf30645484c06792ff41b5db2b74ac48128f684ba8141b28fdc113fc2bdbed0dfc238d86fd1f36497fc5063ba2a30f1e1c75038944bdcda5d2606497dc70e49dff7cfc62296571bd9db0d19eddd5dc046cb5ad18d34f0f8d12ba82d531a19e40cde059013edbb41086c87a8f7b4ed28d56fa1307de44d84c85691ef8f210f73049f3861a7ffeb7138444400a9a93c0edaa352d354d66198d645a0c84b394126c87ccdb1900916158915a094f5cf9e275c5dfb939134f4906252a7bb615fdec99c787da6ed69f244ba840429cd3f0e806326ee2721489728bfd562fbe2d961c99862b11ecfc2465b3e69526e880dcc70bff898f79c520c82b9a91024b2862397cb5326af88f6acd2c9fbd6e510079a27f80f6573d2980fda7a57bd95ce27102752b5209ad8cbb9ff221fa093188cc6d64ae2cf9c72b7980ea8fd4792eb210310fd30f96539f4dcf543cd72571bf18718d9e298d4aaef182a956474d8b795976eb2a0497ac9f5074c73c8d1ede4bc4a270da1eac3b41b789a7739f96bde7124e2d0abead942cd8f46079fdbfdf87ec4bb71cdb9429581e7d01537701f68d07ddca96b0741a176535024819d4ddba1cb4f6f45bc25598cfd43016429778e6a8a942cc00dfecacbc2c781bf1e3ee3206abcd7be509531768cbb423085410c424d8b7c431f954cdf71a026cf20946a4e46abf3c566b3a2dafbbeec25454be68f7c0b925bed7cd10a7d6fc1136db842f952091bfb50449cb929c8a23f238777990e0edb5644a9c29807d000df597b8bef2701238280494eb4cb1bbdabb4d7a1afdfc1cf2ed4a202fcdc6064ecaf0861d925a0bb4ee6c50b0536c6b0cb013c3b79aea1defe06194b894fac81749a5054cc2d83950731e92473df40b56eed9c58ee285aa4fc5bed6839831410b64dbdf5dca456ebf5aa7c34bf93a3e21cb97beface9915e627baf0e4107edfdd35f83d70b878474cc8fa451460ff63ab613f409c4a6b36f3f4018199acee22a5bcb566139702d53a292bee8ae280984f32e7eeb55b737b3bad6a73fc49d01e586faffc11e34438b198ac106b454f8c360c396f696271b34251e310b63353dbe8d14ca7f5edb0ce61759afdd0429ede47f7632efc6d9b496dc6deb623187fbf690becc2594f76535dca3d2201a9ccc9edee0470ef6fab2d8f8eb884546a833874c5ef3612b0651db2535e34d408bee55fcb76eecf05b0162fe566dc7e195dd1f6ffea1694e66fffa997919d1b35fa38e38d84801ee3add97c14add72ebad5e2c4208c5dd9c2bdb03d2e12fe8ed89af60cca9a32a224157d57ef03f2a2cb92a7ac1a4114db3ccc2610620620dc312edc9c9e0431e6063956e95a58deddbc14066d7e9eaa422764398b661e7560f55cd76f61f3d5cca501dc30d33409a7475137953f57737098a8a2eaacaecbf57748892af8cc8291ddf777e0669b7b96ba9cc358705fbaf31ff88dec60cbc7d42475fa4680799d2f1a14e3256382572620d3f9fa43fe3ea08522c06c66365bfe0cce0e65798741eaa0aef7817bfac3a420a17e5337d30e03a60259d8b7d3931663582b10878d499bea954734ac8fbd1447f2e9af052d60c268fc33513d4ae0a73e127bb1d1b0622ea12aff30ce0a18619295a8cb16acebf6c75b75c9c91e818723eee028b75aa884a14ade1104a8007ff71d7ea20c3460ccecb16c05413aeea640fae9615adf5a78da22f90779d073a0b51753a289e63ab8458ad75d9739d898701498e27fc8373bc1171f94ecf7f71fa10f4850ea0f4ba6583b80e337ef4ea4f494cc90e9bac653029d869bfcfde99ae18e963f69ffcc0beeab63749de90e304c255cd30655431ef2aa3218ad48cfe2329682e1839b15850ecb4bad4387ec5c4f8692b1d85ee8cebf3a63ee91340210d8c90943479cf4d2d60dacb7b2f9ddb445b19c67d78aa4b100f174d6ce15248a243d766671f63f93a03dce343d1b7f5cc4e8523b8c2060f87ae757cee807935b514649a1bfa435d13094a179c80d36d00a58b703c438e892cd13cdbad25996bb4ea9ff31136231fc11ca1ce4bc5997e7d302ce69d114b0fe6d4b31d5f0e58e5f56a12d0acc51635bbfefcb26af0a6aede6b3380b07b8799ee632db113a59821dc6ec74c0e84e9504a24ce091df9b4b90a9d27318903a62663e31f78f82a1de1309f7c8261ec84d4c50fe45502c481c9e8aa76f03ce2824129dc05114ac762cc60c27e1b3403ea4de61231ad74ad8abda653234e25a2a928703134ad6159083eb340f75f4712aff1d3763eeb5af3bd3eaf10a8f022ebf52746fb6ec0c77bdef9a384e5484b4d6f1fe284563d1461e68d3572fdffc9c097824f21abcedf892a82fd3fa343bd1967ada60bab48668519cfe353a56c48ddf8c9eaa4006d519179a1f6d9f717b3a19f0c61a4ca9fbe12689f72cd39d5e143c02aed855432e3616d55f633b881fb943edd9ed2d58c668774a7e9ff2757147561eac17c692a534bd7d71b09a5ea9eb47df36153c8b3833f80842f425a96231b4242b49f3ffd277653aba5967387f90b130c20bbfcbe0e268201b851711655ad67173f99566040ac797582d27c4f1b03a702347625997efc54faf8be11e3e90130dbf1aca69f0bf668b5522b254ac66c7820cf6b090e2f7284e53e8fe3b890cbdb08cec763075c62c3b11c45997bec83d273055d2597c80344eba58cbb8c417f7eaaf95f6d9adb8469ea513db9245f35337753229cc5ee7763eacd5a23fc04934db351ca038ff7c15c81cfec33e2e5d9d60da657f4b3aa4afe0d087c96f72d120aa87dbbb6897ba3fa1190b6e2be756d9f6eedba6b898fe8e74f17776422e56e883f06692477d45af65549cffbc7a8421d5b77866a216e8872223252904f740f6472fcae4a7b76679e427ae5c77ca34d1b146341834c7162969d5c881bd56f11bf21d55c39414a5607d2aed7f01c58e063686901b86b0fff6f2829c1b19a6059ed28b50b2678b71fbbcbb787f63507ad6cffc615d3dfba6e0a23fcc5251ec2bd3acc9403303579c6bf47cceda0d322848ad39091bc8a754d7323f1070df0e4c034aa6cfe813abe5b8ea2a34481d391186f0cb8c1b0f405e684c7cd89ff59a48a644e838a02bb613ca2ab2c2f213d97d0a5d6f1073707abf4011c2741da255d039935044ca4c10cbb7bb053baa5278ce96cf026f060cd115c295eb65accf9f125cec99d335cbe0ceaa59645a84dbce70b1427353cec72264cc348c1c4d6b1f653bd6156e0043dde6d224a67cdf3b7c8053156b08d16e4ff045ba5bbd82a9802a4780540106ee9b6ac8606cec2c7215a4fe293a72beecf28e2feb5d1a31c851a108c1ab3b9233e95857affcd1c2232a7618dbcd8ac322bbe3bd4f05f9bcc524d2f160c73f4ba3a51349bfcd0d1bff69446616f015084102c94ef0cd3fded31012cc2b431222435e0e121d37bd2213f27017a88737542cb779a531a61e90896b71c2f78d41b8f67c60243b938894e11dc8e032d767b6a3a7198f9b69f944354f21526e2ff63e09f292511235e403cde65e653c921fc78ba099d0234fca6acf63cf79d39d9215a06b437612beac84ca64399966be5a7b44e4ec8d3929ecf904dce2eb5c402d4f53a31dbe23101a0de11cfc36b51a90dbf73fe3ba6dee53b156cd5bd2b48a7796410ac62819087a19bef8f65825a22f16cc9f3313b900cf5770080600ca47fc51861c2212746fa99f28b222f6abe90f63760eb0edf949e0fd2449f763addfbbe76ad1f10588d55e330e699a08a5db62c3aac541b3beeae847748ee7c5a5d1bc29d3916d105f5e6d38087b5a79f07b236a6f714b4a1e7b4c61d855c39150c4e46433ca822c140970f6cbb45cefb1f9da37f4c4f06b02dff24ae021ec854322df2df520fbe5385eb08023afb2126d3d0fef578f56bdedb8697de136ccdd944ae4edc6a93787c2ed3524427ee4d5c18acdbde4014cacc68a56f9d0a8f8bb0eecff68f7d5eea216ca8e5b134c22dcf0828e52e4dbe9e543b4d68c6092df730f02a4806d42253a9aff7b8c37c92141d9126ad517d22736ec21633b460e8f5992c6f11bc65a902a7d8ba1fb39082be6d558155493a6f968175a294dfc8f7733a72821496769e2064fff2b3f5cc6c88b10cf65b3a217f6d51dfb711ba29e03aaf1649664305fa2020f751f816bfa17b1604bea6c39bbb8b2f2c4360d55b59aff8519e98e69df14f84e3ce8242c35d3d21350b57f4075e5d401163e93721d2dcba01d18c652af3d40563de07802ca8ce71c3cac062d0f5ff41deb7e8db1f12e22c0e5c817d79ddd90ad4da73978593796fde4124a301942f7bd5e204f05194be534d64a4727c0af21ff31d64249ec50b2b0336755a9c88df0f063bac119825da2dd5918eb6eb6ff2c4ebc0b86362d8d07f10e7af0c5e731ffbf89c18306a110112c42aee2894bba06c4385bd0079bd1847783f9852ba6a415e31e420726cf93cee39ded89f1a50fbfc783811f66e7bcbe0f205e37311e52e90d566273eb239f05ca9e5a373ad903d4c9650cde0a0d50462a8d5a404e8045fb25c57fa5a1a425a5d73492516f970f85368f067304d72abae3b14ad1638024197960819e887e78216d20b85ab0297bcd1e436c397ddf8fc5f812bf2ed093c47979de6b3369b1dc400ce4c00d36349b39ec2e1d723f7c6a8d5b4f9a1cbb6765105cc6874558b4af12d223d2466ba9cca58fdfdb361ac8dadd08cc4cd7d0adefe9495bf69e6f697dd3bc71b68ccc9eae1fa97cff39e5311884f7f9ef2c0a66e91e3681978beaae6b15ea7665377b9a8f2255f05e263673fca28d6cbcb7542c52b574a1ed5f9b72f5cce10ec8cd35f130c6ee4685b853fe0c9b2ca2d8bd37fe9e28b70eb9b6c603b72f1f25e382da5b9ee5ccd979c8d4e77774ae5789ed6125a66136732968acb6b09d42ad638dedebc26b3e692d09f6def7762b719e307579f56fb4e054013cc5a8a5ba1fe79233f43b4102d5fff5328bab36e05eb7f65871bef29d28b08b4bd387ac89d1a2c4c87356485692c06895873f3bcdf4924bfc91da6464a8cbd70aeb74df16b1a0d06f3be43cf2e79a0d430c93adcdcff7ea486fc9535f272a36fc03b4d187e83f46b1235f7369f0971b5ce19a61fc54d327b0731cbc1a5a74d1587515102144209ddd1bb28638fbbc28952ad41b37e38404325027bd9ee99f2d9f463b6dc37008ada0b4651090d5d8c575c8785038386622275a7bf943f6e18bd19bc69a95f4267eb3bc43597b197a28ad9e29547452a163ac9a0af80002231c245ad7192a5661294ed98dd57d5a803ef5792a579f9f3fb918795fa009a9db45b7d1008c890ac522774eb0c123fcdeaf6911e5ae13385cc9c464bc6750daec7745d30b9b23bb8c854fcd88d86ce072b369f2a9cf112f074d449e7cb20e7f20873a7692256484f82058dc052924383e720a5e0a1dc9e90ed62a4ab42e1635e4b3c76dfb162aaddda3197c1775d8ad34813920fa917d17e2ffb78f74aa95308a4ad8257c1a8e4a2126870a9ae4617ff89c2cf2913c0536da39ac173072c09a147cd2984fb1610a98c5bf42277a64c1a019711db7f1bff4abf7315570cd3040e1a1a02557ac430b89a1237fbf03882617cdabd2207164b73b56207c5cfaffede4ea191d2dd581bba22415038951e74868c693ff64157dbedc928e176663991be4370db49b4586ef93be4234141c42967f1a28637ab151d9dc5f55682db66923b0c29f2c4d123b33840a0be67e4564b64058a3c9ef5e12cfb34751bf777311422892800cf7c85e426b30e1d093c027740eb4c6d8d49d3522fbcfbeaf4a72bc5baa3ac17e946ab8019c438dfe698dc65ae1f4fcf9584d5f7609dba07d5c4bf1dc1434e37ce6407029ecda217cee28db472619d0c25d710e97f3166f2c0e53569af06142efd0ab2e5acebce25c9d140a896d33e57851f11a235240108142c6d98fddef5f6a2f507361cd2141d858cb63c261b352f264020d1c4995f290e38d1f02b7483340ca4f0df2eaeee1a4c2c89515b32c81b896eba0c94e8928b41cdf022e12f538c08e69770f86c4acdc8d4bb88fa47e8a68b5b8b268f925e062ef3eb0d9fa2e264df7d6d29c7edc083891e8b3688d2c3bf27ac98380da21b9675e01f935a1ff744291b50bea6fb6fee7c73d7e93ca68223b7d00f790e6f1cdaeb0d7762bc8cb67ee6c5a24afa079f0a6288ce42ca8a0f15c39906b8bc3d8a1efd4431a0290c9bf044435dadfffa4d1040fa56a510aab3fbe2636e95bf1ec8e415f9704d76973646924a997330313e748fb9a0fb0dc4653e26ed0a853a784446b27a3da15405ceda9ca7ec458781f574122e49eed745baec32039ca48266611ffc4d31ea6602f1c1c0821d3766c9fd70e710289328bab75f375689dbc4a01dfe8cc0c91feeee3703effbdab63c0832b53b376030c05bbbfd1103fea016c9106272019d0970b5d5d5f3139ca5c7772214186c904b4af2580811f8610886d122be885b6ebc627c72c1015eafa5a7586391ba94456fba4a084b28baab515e261e5cf1bb4da8813618ee98ee0de1c908093cf83d58cb42e88b572440bbc976b115c27e4697f89cbf4e5dd947eb9da967280213115bb6f248ffc46821153077a322c6769db34672b399be6bd57ddb41dbd9c35c2feba99e6770612f509ad1e17a1b028fe00d1ddd2aebe7a67aa95a9b2d27bfbff4eba72eaaa623f5919a981b681aea3162396ae6490f2081d45d3d13a5c69586408c05813a48836c8f8e91a740267ca47d36c36fad61209a742394492fedc1fdadaa821fb48d8ee3b569a241ed8c375d7b6785872f6f1a21b01c4775848c725a91c5c3154a4a99a723180e47f07afa050e1df240a7767d449c4fa34364030e6ebc9a5593e87d6143afbfb215374e878fcdbcf76464af87a7c2b43f00630521208f04f7093739a1bf234de2585c85a54567a2812158b688a7b165f910aaf2b9437d16d213a014afca799700390b7517767cc66af7895c61988bb326d2a45f1bef940bd34ffd913c70419eeb3819f3ba507c968ecf54e112402bf323a82ecae9df04bb4b792f7e92deedaebb449087a2923f9ad02eee10b364fd061bf570e9ec6dd0e73f99242cf197519a37e868aa09c8c7c37f3a9ef0c29bf87c028c445e558d6cbbef461766fe3f2343ccb0224ce08b4074882ec4ada377f2a3132bbc96b76a1da2068d498b8a0d9c88f2bb5cb29943efa4968705f26625cb1ab45192234f6014fab2188fad4d0a7aa7819dd89a91cec8d6553b8c5ed326c7ffb0f153c1b41df5ac43bc1b2cf55e2ad13ef1e1277807ee72b7d8a82354e06707d625b4f103924e5bae99c47fab6cad884cf0b149daed683b1ab35c35ed9b917dc5004e80bd031d86ef4a08c0818e828a558d85c7770c64a4fe63f9d9cdc65570b67bab26298b8c3051fd3a23e540c821e80cb1d8545a52af410e4f4f233903aecc42432af3e4efb5fe14ff1e85aa65ee6ec032b9969078d3c636c6bf3d88bca7d923d9792d93c39292da5ed92701b39b8acf62a53b82af154d7c52568bb46cbb3e7b7c8dce001f79c5835ce9894fda390aa090ed399e5b0aab7467d84ea2b1f05ee7663d5ad285a3c4ac8ab7f3adec602278ca28e60d0155c5642b7010e5833942ae2331a2591c9d5320cb632653f1149f33eeb67020165aec4eac8e5bae906f54a02edd139f9160c1ed4082e3d371b5906b6c5d8a67c0fe897360a1478a3a74149ffa8a0f88ee9677cfb631473c8da8681c3aa0f4c26a771d6b8f06421c72e966235e1be0c8b443a771334845ce5a4803b6a7d4caf907c724f904c434da844e106e4e9a6bdf7b3149791723102763896dc82fd917cc8bfd96b6b5a24dee6f4a17bb1590830314a6c6f5a94d66e0706f02c72a95e32435d04e541aa88ce9c5672c2159ff1996608eed438c5b624db15e94c6b7f59e715ee1958f511deeac947ca12e4935285577cdf9373a5fda3822bbff5972b50f764ab900ab3726dd96d8f62f7a5ee00d988a2293f933adbfbacb101faa23421140c5828dfb88af40168f8dacaac93a61f36b584d066cd8a4823a696bb0c103599a4bb55573e6f34f08d9907764ff9fc70a9538d761b6f9ffb683e9a96e27056491ace10d2ade091ed3543f2b732ca9f11c0067601c92609f17352995c93732f827653103c4b3bc5a0bee785a4a4433a1a8a85e87226607db32c667124a4242eb61ce6276ddc1412ef9b6a343d5af917a49df3e65cda9c24dce6bc94a7c031eb22b97f5e85e2e909514cb5fe82fca6d20013f3ff4dbe0223d3b7bbaeca01b8a626f8b752e5f90a374fa37fb246d56696435b5177e26ecd6090e207b46bc9ba36694c48c797652d5ee0bb86d33f065554df615ad505e433dc5fbef5f81d233e96a44e572c4a1fd1caee73bcdbcdea4b2d2035d24d294dbdf31a84e1efef9b1996119c2669d56f1f785ffe0f264693acc684f5d8348f71bd0d4e8a3fb71052994e6ef488c52dbededac86e3c34dfe979f419759e7a13506cdfa15ff313156f3f82a62c2dd9c4a9e22b2e10b575cb43a2ea6e48a1e15b2bc83e714a04b4f875ca366f5ba849d33f02424b405883b436581633b89967259b70993eadb4df7ff4090fbc5cd7043094597bf3e9f50aeff6771fe6c7c0651c934d7a46d3f1f5d63c25499434281a73315b8512eb029649c2f5e9801dfb39a0a5ba8df7ea8716d417f1f1d066f1b62140f755a4d8fb78c4dc92f69ab4a9fc5b253bd3038befb5d0e7b9697f397f15fd75a5df141ed3c127236aa08063532b1507d8d806bfdf75fabec1d4afba6d3775c349db6c1c91583542586b669268b6fa9527dd06717da82541acc24bd6d36d87a20cf66d899fc247d3425a9af730cab288ef4e7915ada5e84ce2ea6b93fae76b1c73f17f94f37928bc585a91ed7163ec3e418ff6f60ea5f3cdcdb2791e8fe28176260100aec83760c578e0b2134ae6fd0a0e7b9c58d8f2e77d09f7b517cc3dee2206ab9631661ea11291dcfda257b99ab884e103017774785e9c940132de4caf59a66a037aef529079121b19e8b113d89ae2c77897b1447656d0a7fe50fac42f9383102d5c9213b180589e4010ff47d9dcd36186869b7b769bd6dc775d1edb79cc9decc8096ffb180b138fc8698fb9134334a9b623cdc19843881eb6f87873c5416bf522cb7a9cf68f3e873a182c261fbf1502f0b1c6dcda39ef7b3c918d4ca236ec5952029274b8bef51f50ecd33ccb567eceb402dede164ab46daf38dbe03b366382e3df92d256516d64a4084a6b2a954ecb13ca1e2666d28e56238719d2e8edccfb7f41c85a5a3b5e6d032b71a4754274fe6c7ea24a894fb77ac57f93cb18b3d1e4cf681ef9073f65981c8fe4b93d1376a3af7d1f361195a5e8a437931a184722864c6bd0348d2662b10fd98b8a3cf96c886be82b98b98489667092aea1f28fef421132da75ff90437865a27daa8aa44cd14e3d625e88e3c538343d445e6ad7d9ef3344805678969eabbe32a695d74950b036e317c1550852f217fc2bf9d42958a820951d47912c3f16c5ba1dffff090b6626aa4176c3c9befe65478476ddce23431113bad483a6280cdb42416a5283e7ce28bc0f2752048384a723565127be3527f11b789ab514320bc63a55dba25debbfab9a0fdcdda42e41f6bf0343b29aeb33916a03830b272b4c4804b37b5534d3f9fb2c9c5091963fdd9e260288fabf19dee71b90447414a2c370313758f86bf0253784bbca0da877f6a48110287d1fc0cefe9ff6068c3a02761bf37b343690a76dfd75394417456d4a42e6e3e99305a33f3bc0e8691d7cd32a22f4a2ff47db52f88439d44374bf8d714eb413fbe3db469ee2e0a9f5dbbb3441b73ff7b957a77ab5eacb8a69a2d1fa6289ad22257bae8e3266028223d89edc3174a29f87493b4bb710d669bbbeab44b78bf27ffd09468b17ba9b7023ae6899c0817edebc9e6097ede0095f6acf3be3bc81df455f1faaf446f119d894f690b1f3f792bde80251114925cc4ff1cef02eff803b8c38ce9445265daaff352ef3a8ffd5035ba74e0acbbf2f49b7f7efc9d2ea4af6a1d73a4ab7ac16b3f7f8f99f80b65f43a511c8b425e4bcfc155841d0c49bff98ae880d0e1da2bb467de7347096447075d314568f459b3e3a1df8d68d037b0ddf553eadf0c4a40b0988e7bf287d76a12888c8474c8100abc203509054cce7a7bec3d6ec3602254a81f81d965b32fc87a0277886076359386a160a60510e1e253d1f93dd1c99eb6b680a9524f2eeccf8fac277e6b9fdcf17a9913749c3a785d4f63f50d6bfc6a72d394a67223b1a0b9b143ed352bd70d4bde1ae88848474f4ce87b47a284bf47df3092ecdc0a4c28342e93af53add2201b12514f53bb0fd218330e0e00837900424b4e2ea935f542a2cbce1d74c35b685132c8e70cfb9c1d88857160a36224297a829b4fbf6b72a237b0ef054a4ff5fa4623389b80d5b4f75e599a439c810df59d9b2109a0ec119ae38dfb42a9214490c579ee962b4f5b4229de61d117ad532087c257d86b860aafdc3a3a62a4dfce848f7e21490905481d1ec2cc4598951a3bd2a8f85f9f0519021464684679fec8d1e068114df69f56f412377a38ffcbecd161daa865b0d5c34856f36ce666877f839b5f5485a686e341ec3b3f27edf8021a88f0da3135b7e2da51ef853bfd68383f8a91c0a55fe3dab23889942b5e1f97b11cc9bf9f52960e01675ed313dc1321bc4ab9b14e5b620b635f412891673f059c3bcf9499e41367576e06e0b04e0dfb5a782ece2577f9b5ed31120ac05ab502a35d190b9cbb553b33779b0e72b21aeab872e05aad8c98d4bda1f3b31b5ea165bdfd6b9dc62f0fee6ea68fa61c3d3a7863ba0f3d1608b31fab995e6fc2855dd3823ff39ed72fb634d56800a0d60aa287b5fcba19bc669a76fbc4869d2e2ce5b3cd062a360fd0b5ae4ef214fccb9b63a39dbe577eec237da49752cf3c1ec2c7c2d435a7fec28e6581b8c6883f9e725c304f0a3e1b27ae862c7e66e801f0c49453226e642025e81d838c1e31a1e7aaae55ee566931701c704ee39c306724d6b33660593b4da4dc7d3fe2e0f565c294ac0c54f518d0120d7a0801bc549e6f10628386a9285be5549fb1dfaf73b26443dffea3183fff97aea94e0f9958c90e5dbd37b1105198af51d95d90a12757c7adeefaa5eff50759583a59af8cd5751e696ef80d4ecd37f35afb6869da1e92f0c110c17b6543eb373dc3e61d51fe4466834712258f0a1511c582db3c4019e0d26f976019a8a2bf7c96bd8b4f980e894e73439ceb45406c2170e761f85692b529ba73df3432d649559cd00609700be80aea8e636b43abdee74615e9bf9aec483a85957b9fa1a8a5119b5fd8bfcb3e0c9a3d0a35fa3046ac33b6a0bf6a5590cb893571ab7422b4d597c17e6e3fb149f4d9f6a4b0e38fb680afbc24ce5a7d999323310e02d20039e4e88fbf32fc7c138ad3a8d027c762309c5fb79af471337ae1a810c182231aad84eb1c4e360ffaaef120234cc18192974a25aba4a058175101acef3fc84aab443e6ee7bef0ae48424bc1f649e07ecc03d3bf36aecbdc9355846e020244df9b682253ee39c6bf070010c30ef29b6bd8b9b56d5727e6b1af9f7e26406780c1cf5e9edd4c6d3d83c20082ea5b9e56be26f7821d6c04138ed76a32e2d4c8b7e051e412e1d33bcef2c26be5dc80c8bd14d53c6ef5e62ef53bf4348d2058da38f7cfa6d9922601fd83f6a95ebd7addb3c56104d08f1fbe08f1a5d80848160f21b64cfd4f339fdf3195515236483c3d3aae5433a8cf0deefb8d4db2399e8d2e2032727c4bc6a9d1a970ba43320113271ae412ec3b7f74316b8f177f311a71fb56ad36f5950b1742bf6951d7bde3332b68b26984541c65afb13f9bfbc9dc40a2ceb99071c6bef51d9a4395c77634f9154d375170ebb7a94e5dd269639ac7fe1e1fe590365a8ae9a2d3ee20067331e91e5c2eed384c94cd5f2a246866ba601f50c215c63e980f2ec43d85a3c74e7a8413daa673136b3783d4b4e23e249a15559883825635c9cd33d5c524dbf1471f3efde29f03753dd49f7312d9e7a2e350177d919addb38d6f2ccd315a7404ea57ddca43d4461bc4dad9a72de20f900bfda1d5a92fb54b7556f5e794164038c7e63a00ce22dc4f12f7a5ac6586b5891cdaf21cbb0366fa38d6b24e75cb40b82324a48c6e5b0bfe60842d3b7b3d4177e5210095967aed2d16e25f3858694e43bf42030d30e537315358a1637397055c00bbb7152c5256fd8ec02164cc44916780c35b88d4fd7d0e5f984b06ea736cfddc7cfeb1b747d3567fb65ea1d305b25ae96e5f94d0e94d31e97ff9cdb60c0f120a412c4b5644166af1b073b54e304498c2214013d42618f9ffd67c0a9c4de9daf7c7ac233a2e624016a96680984a7afba777523b0e625e4cd51f04725b49bdb340e6d5144ba220bb09ed5e39c7736e16c06d1023ae4c32c8fb9a3c57fed82b3fe21ac2814049ba2537758a79937672368a0657c0a60cd5005bff04fc6ee83e379cc02972b629125e85f9e7f7a798c5bfcca395b7d0fd0b7d230f38c5bf5b7cc191ea517d425cf7d6bd39390d628cbeb70f88c9462803c5149da91bf56e56802ffb57bae2a59888f908957dbf911aef633960079fbf6b9cf4979137f10a1a0d1ab7a7f267fa769113c402e8cf2321a26874b6115835ce3cbcc7a0ae77fe8dfbe7fcdfea0104b789a7ae0795f6f6b58e0989dcaa5329e32049b53b7483bdc9c3fadda9522a7bb41ab63d38b6be21ffe2392e229ce6c6535e6a2541ca17be6131b834581be6ea2fb2dac75332c983205cc1f37508e1182de6af5349ad2f2c5f2c424796dca13a57b0a118c366b4d93e8a34669128834f99a1142109bd62a351a574ad9402e2694ea57df029fe0fb3cff9de45e8662f65b5bc650faaff48b1d9c7644e6cc71bb4d1118e86090836b1bab5e059b88c0d41e80827750cbc0a6a441e36c1488ad7f3a94d5413d5d089a58426b2ba428e8d2016c2b308d3668badc5938a331eec8cfa2eda3a5fbe4af1da941f0edce09ad8fc1044dd5ae8fabeca01fbbf7c07797ba19069566db6df996072daee84d433706430de23ce6cdbb8c71a8404c2c8751c175c2a64e7ca7ebecfeb2b6705066c7029139a24cdb0b58d316fb97ee5b11397c8b1295e7175d55f335e8037fddef7a9f1f0c2fd90f5ad9933309c5bce34948e39d163a5f6b564aaf7d7146b0aac741e35ede28718dc5a9e5ebf00ce3a8f2fb87f7a0d34bf0aabe44802ecdaf49f3fc3d6f409212883df995df88a539cc47e7057473e5b3c2e19806a5f97c5d74e7cb45fd2aee794624800ecdf383afa43b8b2c284cd4295599a2580a21b64a18de7b02b093e82d460369e706e360346f71410f0135f04e1199967edc94f3ca9fa3005f323cc7857fff0968a582fc9c945523f9162f27ddaf61d9e5799650f17703dda57827bbb3ead5ba7ce70c4d9e68d77b5c0ffd17e4b96943b4c0fa1690883c3a965d301d6dd1d3691ea4ba2494bc59a657a7ba4b79444df5b3d3d8e78538bfb4fe68d35bc8035e5f92a4caca3c54f1853c0c80f579ff24ab2cf33648d7b3e5ebab72f693fd9dfe3278e4243a05f6e94f97eb02648d4a4ff195defa60e9a6c29c60afb29a60af6090674d191a54687ed3ba73fe4be75c88f7072fe67661a59e669c77acec85e4c299c2a815b28a08cf782b48a4f43e400931d62c94d82605e870c0f2a8f252fc784322dd29942e978cd15b6ab522a9d7de7b7b274a0fcc4776bfe0e0fb3e4fd398322d9d9a44930480bda7654ec222c954a1aff943ddde2c401d725b165f5f405a2213d677853db1b1a4c087964912f5520ec60157a8b10a5d549f72f3502739107e0d69d774fa96cd1972eebbe48f77c526e89f3489aa061f245e59c21ee4e6e519b4ed2e30f63fde6c0df550232210d541fd91e206ef294ea23a81b8f5de5da8e42f71303e028872ed2a9d51508f3773f9a19285bf0b0c460bb615b147c9fa84330d28b06529a477408b8f9f6227e8a79fa50981652cb216f0671ee753e3c55cc1b803888affe247ae7e510689b80cd46401065c425ae6638cab19f976bb816cd6f87c1d324ef4053b2ae88e097ec0e152f823a59a9845a80f7cc67363cff1de04a9ee1714665e06c9396eb65f39ef488eadb2dd03d12c582ac42190fd121fb3322cb7d39cda165a74e2140382c758465bf4329da21a243ae47a6fe6a1115b7c4c93dbd53b6d92ce01560e4382e2c4f3b4cd3e3c9bad86194be7469736c9518b3f5a8358eb5bc68dc576a5156fc1c319a5e1425fab67ba63ecdb65c99acd4e2ae7cd3e092ac258d871081922a278aa929db1a68e06d1ff2154f5dc23624c0b823259dc1e1c65154937f06fad20d30c6148ff5ca750733c353192c811f99f9bfddeb030e00d0e2f8c31397dce0dcf5772be5131315643c537a6aa8bf38b29567112998f778327edb2fde27bc87ceee6ddf5ab63292c88312323b7a9a2de6b2809dadeb5be847138acbfee502c8c794c06e321c332900784fa34489c6a396e18fc9526412890835cad2de5bccaba7f4b557e2d82ef0649bb8b959df2a6e4115b6718f7c2ab0e5a8ab94bac5e997cd8bcfc02dbe104007c2f8898fcf920bcea47671b93ddec079c54c4d7d2966f760ccd5bc6e70801ba619158e0e734f77d3859762f6c09210102e9f11607d42091e10fa1a66809839cf27ad268f2243d267cbc1705e9d4a631db3200d2378bd28f70dead7ace3ff03317ad1ebce7ef0c39cd3ec7704896aec7a1db346ab8bfbfaae480e5bdba682f05b6952624bb56e699b214700f8629b0bb67d82a72e11e602ec0af50b52673764310c975174525fd52b456bb276b96374e4c20fbb72da2efd4ee1903542f960625ebd8fcd2678ea6c5f93760d4cdced3b8e85c3b6a0427860cc3070a96ed4609acca747256580ce20d54a530f84c9a475ac9f9246b5734223085ad579dbf8326eff80ab135415c1771319811d27faed3f9699df02b64d3ab8361c8c1e42c1a5bc30f819b404c4df8356763dd14642505d05576e11ec2f20a2a15dc72ab348527e4825f4b0f153b6e7556c121e202a986930d060d6612b4bcdb66609b26cc1ca85bce30887114d93a6909f850d14750288842742479d82d310b51a2f618a65c3c0f818dd568e2467f1fab99c897b1949ceefd66b3537f2a923b99544115d5bf29957d836012e8b54cf396653b30ef62b7b8e22aebf6d2b22f7e071e6a74497b5e5698f3371a13f29a46c8729ae506ed3ac80ed7a4d1de719457d17e9a92f668665f54171b9eebf20e976b7f1715f1709a256851e319a6749d73adcb3aed8b2d0cb7957b94325130c0ee6f3ee70e7a53bd468cc3fa1906f5b161af45398fe225b9989d5cd6e53dadd946b5318cc4ec703d97beb824e5be46359d84f32a074aa1789119110434bb18ad5da772819dd1ebd5fe9dee81642da1abe1c7316b707dd8cce75099f2a2686c6e52cd92992451d505da7899428f32f0700f726ff20060d16201c1a761198f36b20dcff9237414bc2f2d0bc647e5972ad4618920ccdc36ab4f3edb3ca360c788ee8b859088bcdbd9c0dd4ac5ee7aa577e0086d37595fdfb508f36c57aaf28afaacf9c7e7808e491e964303f945c1643a4ecdf2f7ac41087fb297df09f3a8cda96768f4ed51df0d410f4c70090e952b8cfe40265c4d1923fb89de683afe854ca9bfec762e00b48fca1951ffbb908d251d744578e80b6b5c894cc18cd4a8a2cf1b5a626e025957d3d8d0e1fb11ef85932d16056d0c39eb2900097ee0b3218dc27518fb6c55afb062d52b3462d2264625b55ad744b2845ca61365eadf0169a8e3b01d0e8a5d16efb9940f97183ee8790918aa9e96717361c99942a7de0870a049b275c0b482ca61c3aec90b66fd8bd553e8cceb9c54355a4ba344eb29ec79fd9b45475e3da2d4eb5297472603dd0fb8c631c81910ffbb2f12a884b7ed0391a5eba01b2d039be1144f6c674f6a04892dc26569fecb6799caa188fbe525e438e7d77402f169e9f9214e87f6059ce8716bb7bf9b7feac767843e8d1eb5b5a0a0860f2e45ce6874efabca0183a805b30cf249d67e47ea8743bebb25ad33d0acf052922376c9dce45a0fbc21f8af11ceb955b6a7529b25715a7c272a7cae5e653fc5a4fa3fdb2ac8d1372a7d1ccb070ed9b757e01524ef6a7b3c27ad3c0e5078b089a50ac7b7b8cfc417c10d1ee03430eaf9dc3e19b77165d37491f885e3c9385229746a37da4631541dd7c8363be1e700366c91ca2f0e9db52397efbaa02c5fbd1a4244dcb0e8adc06390168c9acaf9d76a989bf7de092d1fa56298e7b9d81138225d92ce21db339d33d9fbcb0017342c335e3ffebaf340488a9db4aebb2a9eb089b18e7c50ab390ecbd89801dab3c3f3884899c500c98cef8067bc1b3c13f5cbb2ac81de96aff25f947ddcd26aebe95539fc583425174f4d3c3b5c3e87f4c77661824ede8a4ff431bb54291c598fc324409fbea9a3357c1ab1ceb6cfdc2af8adecfbf409a1dc2804e21816841b47682144f2a6dc69f815754d5532814d2b11ccc5fb19cfafc94b8b1f608baa7140984e2c6bce9133bcd95d69ad65e7f5762025703db8baf0b3b7cdd748a0752efdbadbc498b15c9dd1090399ae20cfdba4de96539aaf6e2dcfff664462887cb37bbcb9f325bded9efe0169433782149b6a225870711a9ac87339f00f8f75db6c4c98769d55923bffd4fad0bbbf4b862c151bd11b536f38a35599032270f7819f23ca80fac5dd9c6d0a0f40561c612f9916a89ec7335d37dea82c91ff8423b5f57a1aa65965513abd172c02f1e217d5a12bf40bf73da54182a534be4db5e7deaeb251b7f162d7d04b3deaf958f3a533d763e2615a994a0fea6fc6403a24064dec9c1c7926986ef0f822cfb58c0b5294e95f3b1350dd5e13015f00d61d274880313340997b3bbc7c9a4e2a2f5eb7739f7180ec2fe1b588a86ca9735e6320b1dba722c1d68feed6220de4cd4ec2c84d76c9176c835ffbd62fbb73bf661aec3374d8d4342cebeef188c21891e8e64cd53411011bc2fa02b408e804f786d72bfcaf7436d783d04561e05dbe96467e415b14d5f993ab78ebf80085d9ca1a5e188adaea63f57877e57118cc611f93f6bb482b8d44c9fdcf1fa13e08f19a4de2103e0421088d40def1e4049d3aecb081d2e286934712d151e74739a42f3dac0330528042c0c728e62e1e8536a11f57cab82e1ff34dc1ebb8c9a39c8681b4d5f97c85417019eac8e17fd0550c6e7f0a1c0a7f9a99ce733c477ed8587baa09be1331788b790ba08a0cd4e3cc6b474d3072b781ed5e6082dbd3125d45809c2a27b22fa0acc8f6eb4d2c746767f4344d31926e066cda58f7944ece3ce4edb3f7ef706bc42b2c542f2e68bce9471d9d247fc80ebaa454782f103d378937573c7be5e1cc4d6b27436ea06ffe9cce022b48cee2e942104edee8cc254c7d6e7b4101545871912dbd4281bea323389b891b725a9f891e672055f518eef79ea83c0a1c0156ef0afb2db76fb9d8aa5380dc4395f3f03227e22bdbe81fc381074aca0cc46744e27eb556ea75d4ac7060bb724e5c444bfbd45fd5058ad03d5f3d274191809409e9e5c27ec1ac1185a658b71407896a0fbf2c63ea02523676cc4044eb5cb4b93e77e51b61764ceea482e32e025859eb45611ebd49b25fe97cacead7e0aa0b97e94479ebff31f38067686fed37d41f8a09410598ce22d03c34a1e31a920a67467eb7b29a9c8c186d03de9c7485b9beec9142b129444b3cabd01b80ea67d4093bc7228346209f3a06f4bcdeb5e4077d47b4cff8509e5d92e5e62a1f97f5d6408f7da500622f731034d38d9d1cf946335bc720fdbacb2f5cb1d1d38f8200668a6b90f3cf4e3b2027e4400abc63bac5c3fe3d42e22b17f43022af942b96d9950b8fc5d97f3f14a48b16fbeb40f82f47331454a6f1afe9866b0c6e37ce2ca9b2f3c68c0d6b208f56a16ea7b8aba89563fe1e41ad1355710375c099b6435c6a6f5e26866b8ac7fcef065ac5abb7fd813c2933ae7fdd72cae0ca3ff7200a5900379887057e22b882c796864097d76a78bf04fa65bd53b65cdd10f827da36b2d808aa92d97b31d0500f5cc8d7a037f5a94b896288622eea18dff5d65965066a320087ea672c809ed5f0645b56e3d0812bc8f5f16b54d0679185333d9a8de405c45bbf28d603cf11498b24b7177b1f1f4605cfa26802176862debcb75f885bbcf29430077b6109f8161f0a9b7e09c3407a5b0f30b26200833360287751558b6a30c82178a2f5702b6cf9029e5dca92faf5c45cc0ce35e2cab609ca519c26727c5342df9c1fffd7a6b3c8aa8263de9cd5cc9456d8d8835133936fb5a600fa49d19c8329ece81baf75cfb7e572eb86986225e4ed40654abccc3517fa1a3f0999c799a21c12c98ec7e9c288c77e3e735ce1f6acf50528d26499200f830c7954bb1d564f192c3a8e9cb3ffe3f085545db087125c4be02ee6148bdca79f1a16858635fd42612951510d4fca05d68bd265793fc9f8c6b27a773257fcf055e1f43daf7eac791612b8b739f3f33fa7026720cda8dba80be28ef20b3dde74904649b80ed9d24f2e9541ce79bc6a71648dfae056da2462b9600e6cd8af48dd1665c37c4940e40bd75dbcaf7b3116f1f3e7993610b41b7ef3a89ad2b2d025583dfbceca404dac50b1677c6d1dad45a3d602609dd179b1360af4f681ad297730bef4b38df556a009435313b314134dceb14fceaf313bb1ef2f2f1cc795a51c3002b8c906626de39c7ee1f47b490fe280e709f6c8f2de7f255560c3d7ff346bc8deffbf17d956e5a3bc77e32f3855eb99097bf064c672171075bd205b267cbb6588e7b23b7b1e9e6f644d265a007aac04519a20e79298c97c09780fc0bf9b27c29706b2f02b4a999123c51612ac1cc267f4164e9817f2da7caa0177e734a19484baf5e5e639e5ccf4fbcee1e627297f82ae73a30cbac7b8367808fc76da9b2620b757875b937324789c434bb3d22390256136826246f2755e882359797d6cb1a305736d82d8ad2a9593ef56b15e5ab8ffbc7f5b4ec6dedda10160fbc1963ff88d5d93f4203beed49388c8cd0b09acd7b6288610d63cb5dd4955acd4825ded0d517880acc291e594fb0ebefcf7717301eded4c83f8afa8ef4504c6eacae7321addb20c36c95539f50654f33d529171bc3ae43029ccaffa0ca8a58876dddb8a178dd7c5ea6fbf6657966a3940e8f62747c6156eed8e5978d874c12f9c77969e6e875f2511dfc83e52abbadc3abbdb86d0e3e7dbaf4df2c1e38a23bc06b322925b878fd9c75b58740335a79d3fb378d578d582447cf9805e924a381cad3b6a399fa828b8912fa483018ce5b1ba4655883cb08271c6b4dfac0a369dd501617f33d67fbaacb7de7859cb46034b460f7ef6ea5dabe8a6c4bab3283da41b1bd9a303736133344b743088711fe3452aacfdcdd0b723d7c71443b110ec3722d759e729f9556880b60807c65bb7066ec874bbaf29c4eb1772dcda4f5791deab84e9d27d5b633bd030064ff12ced96ffd24121e33f0db037b41f555aebb0b26a9acb8f48afaf616c401c5ca816278c6e6133d3339323458210909fadb658220dee6a7f9e2d6fd39dc3ab3ea5028038ae5a607cb92a9ed59fb26d4cd304ef0386f170b5ea4767bac026ec053df4fadf7e375071d37c77c0c70062e2c06e672c4c5e95d1e605eaf6158ba021ecbf461b48ba0055aa6ee230a1a71627bdfdf7a635307f3cb8f6b65c989b6b1cd5eff41ca8558bb9af0d57d13f8867f7fd5c748b0ad1189e511ccaccd26c47f400f42d7b57ca69b0e209905668865ab6b373669f2ee3d807ed3d80412bdda2502c6aeb6422060ab9eccde2bcd71f6566dc6e80cc5f09cbc9f34e1f050270fbbb5710a5b8e150d4444a612b7efa69afe39b51f566027d92bd3fb454babb7d4ee29a93c236f42ca7ef67511056c29f23612feb19a4a44331018a080c36287d5d0541b968d70074f087e63d5e102708a37ac1f60b3b6908ba981a4754526913ffaf09f480298c29246ffd6a1215dc66185eff303dda3b86124af551cbe98f52ff7b6696787a020300aad56b8714f1c0da4d6f4b0e2f5fe45beb74760062ead01b1ab14bd0dc039e84d1b019002cd0f54a9f5053f110cdc368f4893c009821838e9027052f26ea7333ea876cc77ab34811b3fcd4b7fa047a419b39e75e4dc850ea73d1989d8e7650b13a773754f6c349be99880535796471bcaf61f656cdce895dfd51af521413043c0a44b9d3d101695cb94c5a0ae5dea9ac319fe0e6e91895b942f77b877e6eb901ae3a2b6dab8c415fddf5b46cdeca73c1253dfeccb81357f334b326bca36b3375d30ab53fd0b91525fe61a3eb96e1e0e0243470e0397a583faad2332c678d86b65d753fac632bfe26942ece1b26093ca8d95f49d8d6e18bc8022b54e1dd6b642ae90753c37cf88423622f0a85d816f4e22967b0eda79cb2a6eba28cdd1aaf42820a31b7e72f818b00b803c315040e96a0a2efd043c68d08f20b3fb18a9a6d6692fdf452cf3830e397604a84c3629889e9b65965efd2822aad18d4e3ce71aac3d5aa4a82cb543e271e890e2ad92c43c6978c4c2fd54316667b9de0a1842d5f0a41d988603481b39b2030fe917bc8df726bbbc325f8e8fdef7f3d2bb086f71e0046dbe007fd9a5841991f256ae5152f32c7e5e9a4767cd165f746c7f08aa4eadfbc97a8e3d842cac168c3a06c6d1cef2950f37a8ecfebb996a13fe7d1c36266654264d20d084d39745ed03d6a37cbeda5869e40290a8f059dbef5eb3ef04b6e2d9714223e2ca3eee75c09076d25accbd40a74b2273421a054f12f92fba083dc0034bb8fb64bd2ddff4846269d1e997114d9a20778e07e70eef64e026baad1313bfde638da6cc16b04755d6dd16034eb6fab9670d6b3d52f6ba50ec065ca45881ce660e2945eca848e1dfbf26aec8a234d10a603164f7fd09ed69836483e29a0d960d6ec959512d17faf80a1abf889130ee7bf5b720e0e7f84ce53a5911ac684ba2b54df8329e061169271a86955da40a42dca784c4221c200f6302e4eb07968d43d85aac8ea06d48c312e753de69c5762ad60747cd5e8d1923836d4e9fc9da1c42cdf5ab2eff6c4e2ae855f2c6259b3ee03be6522fd11f71b36ef8c40e8cc6c155f3f80e512123bfb4adbf11f731252f7223b8c717b7177921f78320c44b66814b269fed31a40005b015b7f468fa0fa0682e14b5c65438c67b1dbc6589ef55caa3ba457a118fb1c432a99e78c14d84e0315742d739b5cc8a7791acf67ce94b31020fe4725072c74f1483faecf3ef5ce2e35f28bebd2041a2d27a3f67c6e5e4474a0fb3a39867e4d643c4ba4e83ff000ff2e56298a43d2a6f0fcaa7a060d66c3977e5d39f2ceba881bc36e3acc268b96574f33a669ba72ba4859bab6cf8dddee0c5b28f87baa41c30a47362d9df4d2c42bc8fe5cc56929b4e74273bb04599f240a0f38f9b8ce72f56f2041bf525d4eba69ae60a0a2ae217ab3ac5dbd62ff38ba16e5a764ce1acac3fa161bcb6960496653338c715d81555ac224a94ce0bfcc8efbbb5ef5c81509029270c39126e512d189deb75af1f7ece6a7f822c366c98f544683a9537c656b51f63ffb5245b8466f6826e521f991f3a4757f91544aeaa6bc970e91a5974e11ad417453f2c7414e604671e74c47664e11bcbcc55194ce0686587dd3f5ef8d1a161218bd249f26e0549c3605a219d7006922080a04a79d566e807cf6fae39d5176ba5b673916cec8cb9639ac4c67464cb5bccdee5aed1a955187cccb94494de6faf696297bfec3a51b0e0ea97e52d03fb20bba398c6251cf92b514c79463f2def7cfd4a3da5cefe79b06b9c7513130ff538e85a65453ec0db7b507bc9fcfeb4d2c66c109893f4197435f35e8c6f8477bc5b99fbd46291961830bf2fe64a169babaea1ae9a82c6973a985900d38bcaf5300a84d662f3a327e20dae5d7f0882047097188c36eda34f4d535a6195ed1757f1ad6c8eb673b0dc646ae0b9e43cb3b4732cf082fa5db68db012fe2cc6c3ba9e99e04f1b3a05744f4eb6d5a6b7ec7b67df18c08b35e4c24e4ea3908cf6b4757fa2a48998ef0bd0a2eea1680871be445b0452e700d82f1fa11e478de643da0f6c9c7ccea4d6df4183e14ac5bfd78313d58f7c3d01074e97bdd342a95c33fb6c8642f4ccce0cb3456af90537f843688052092badccc4ca941fda5ddf67db48f00d9babf80a9ff43f04c2f8aaf44e8fad7e2bd4af683f97d6e588720935bf9161720a1459525057faeccce58de8e354eeddae6de553b9aef6fb359e499ec5d53d4a408c2bc8e83586035f117278683c6539c02de211056e6127c63af36e0a118973ed5213331ee36b506d6a17f8185bce2b98197db24b7329d1fe9fc389f619d17182d08dbe68b5c0091e9792084d0bc7a63a7c10c35991e0a4269f316ce03d59b8848f7b5cc816196c0ad8b6d7b049894ee2b6fff2b4a04fe1eb61317d234d9d3fa9d2867ac75b6ee7fce3b4a09efbf48e142c94d61400d22b671d65dd4714f1d84f10c8c35049d16243a0bdeef45bf37ffcadf0bc75c71ac492ab54cf3e5da789838d4a81e63c016e789697a25438ae68a388c2547b330231aeaee6ec27c3cc1d23ab43ad1ba88f626f21547c05fe0ba1bd71115039db1bc3bd9a14db0961c92bc70266193a80016b29d37c4c2bef7b21e729a7b73046d1a5846041d6e1811c1e542c23f6d5cb266bd46842ca4154c8891e6abc1ddf53c2e0ad8e8eed7743748cd296f1af4e7f3026aaeea38ae8d9d3a371e68e097822261732c024c1d59a82b9755ca39c53c118b98bd44c9dd17ddc5455d0a78844dfedc0600715cf2fcd45c9f21613b6d05cbe937ab6d289435fcf3b41bffc4a3516c7b46624617f2a50dba5430e3786970a93193c90d37cf12b1f768052a251e0d10ee03296f6e7bee18f6d4047319020771a8c4bc124def68138fd009bf085eee8cb213befd880ee900f2dbe7f397446384c1dd56bec147756fa09ba5a0066799809973f3aac06773221d5f62ea8d4aac873c128c83f55b930b1ae56c84db2583a9c44cfaf91a6fe4c9abb36554431c236c642b882f002c80905fca0592a9375b20e2eb1e4fc6d041911f5488f6cda04f001639bd3abf7df136b3fb74bb6287c46460ab68d412f7339bee22c350cec88206cf81c5de225cae8f9bbd86d11681c7d26f086253f1f03f798c9003d3212c1b60bf39b8edf3bde0c73002914173f55d83b75ba910d8a406ca274dcaad0bfe0ef269fa73a99ba62ed3a140daed112a2f771aa3ad4a3e7a20ebdc9ef5614fdf812fc0ff489eced43ea448ce0a483e8136709741729ecaf9c3f41d570f6b7d3f1ccdd9ae3d41606f9c09f2b0a63b0491986c35dd34b1f8d9ccdb0ee46e881dc7003aa2261cc16da50e882b00209329568f7f2b25f86cfa3ed389ffd909c6e3631194f2482187d212eb9b4ddf1ebf591d5b3df5f0378151f8165b945ad4d839029e1e69c05ec6323d60bdb931a70fef7c773a37d4a2e3b55b65419dfbc82959355879f0a785fde269a925f4db83e180c6846112283c32474403991643fd5c54079f854592b03a4b6d29fd763215f4d9c0dd720856ba93070d64b2fa94f9d86084380ba6a670adfc3b4c59e2ce6d44859365e1ff79784d3386c301ef86c7d75e7f12ca0e4757dd0c06f9d737b7910f96936ace7a83729fe382b7bebc035b09ee354c6d6cc8e5a65d9b2089c6e150c99e352b5066ae4d3522b84024623988e961dd54210d4d6196d4000bded2651bc7d81cc566a3b7573a4622b6a6d23a039ed156197250a972f2bba735bb9e7428ed7673ef5a1b261365cde40aaee67452dc2333c80817dd6699a95f9f50686dfe22851d65f17d8123f2e0fe8c645360164751b72f6c889333c953aa108f3620f5bcf657420ec2e76c1cf30177258887fa778e0fe3e02f00ef54aa8ad0772c867a3676d088fd6c1cddb1f8c994e39efc3ba4031b219ebfe9a1e57d48fc01ae2ac512e1dc0fcc2a4037817f25f4a36a8a12737fe2c6e8052fd4f03f2ecd4902fbe09fd9196189bc916f42d2f33102305b79b2e1b1a5ec9176a998b48910b9cf34d10b1056f872f60b646fa0bdd161729c50e85e2cd61a0a0acf0361dd47266a7041f15c076b751486209c3974ac3302daec8cce1768dc1d86a6de50202515bc5e9061c1281b7e5ff862886ef61c654e2a0ee2fbb7af2994f342d3c23a17397658aaafbc24bfc529573b6332e93b1bf95ff9df76c613a0a42</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/zhoukaiqi/lib/hbe.js"></script><link href="/zhoukaiqi/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>x86_64模拟arm环境</title>
    <url>/zhoukaiqi/eb93f416377a/</url>
    <content><![CDATA[<h6 id="1-安装arm交叉编译工具链">1.安装arm交叉编译工具链</h6>
<p>安装交叉编译工具链 <code>gcc-aarch64-linux-gnu</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>
<p>建立软链接，否则后面执行的时候会报动态库找不到的错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/aarch64-linux-gnu/lib/libc.so.6 /lib/libc.so.6</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/aarch64-linux-gnu/lib/ld-linux-aarch64.so.1 /lib/ld-linux-aarch64.so.1</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h6 id="2-安装arm模拟器qemu">2.安装arm模拟器qemu</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br></pre></td></tr></table></figure>
<p>编译<code>a.out</code>并执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zkq@zkq-vm:~$ aarch64-linux-gnu-gcc main.c</span><br><span class="line">zkq@zkq-vm:~$ file a.out</span><br><span class="line">a.out: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, <span class="keyword">for</span> GNU/Linux 3.7.0, BuildID[sha1]=6ef0ca0c6462e038e589b6e1d52220a680007588, not stripped</span><br><span class="line">zkq@zkq-vm:~$ qemu-aarch64 a.out</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h6 id="3-通过gdb调试arm程序">3.通过gdb调试arm程序</h6>
<p>gdb调试arm程序的原理：qemu端作为gdb server启动可执行程序，另一端作为gdb client连接gdb server，进行本地远程调试。</p>
<p>首先安装多平台的gdb工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdb-multiarch</span><br></pre></td></tr></table></figure>
<p>重新编译示例代码<code>main.c</code>，注意，这次加上了参数<code>--static</code>。加上这个参数后，生成的可执行文件为静态链接的。<strong>如果不加这个参数，gdb调试的时候单步执行功能不正常，符号表也找不到。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc --static -g main.c</span><br></pre></td></tr></table></figure>
<p>通过下面的命令启动可执行程序<code>a.out</code>, 选项<code>-g</code>指明了gdb的监听端口，这里选择的是1234。该指令运行后，当前窗口会被阻塞住。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-aarch64 -g 1234 a.out</span><br></pre></td></tr></table></figure>
<p>新开一个命令行窗口，启动gdb client，进入gdb交互界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-multiarch a.out</span><br></pre></td></tr></table></figure>
<p>在gdb交互界面输入以下内容就可以连接到server端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>
<p>接下来，就可以正常使用gdb的相关功能调试程序了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x102e8: file main.c, line 5.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:5</span><br><span class="line">5	    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>main.c中必须有main函数，否则执行<code>qemu-aarch64 -g 1234 a.out</code>会报<code>Invalid ELF image for this architecture</code></p>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
  </entry>
  <entry>
    <title>x86_84常见汇编指令</title>
    <url>/zhoukaiqi/1d4d4cadb785/</url>
    <content><![CDATA[<p>本文介绍了x86_84常见汇编指令</p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th></th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>lea</td>
<td>leaq a(b, c, d), %rax</td>
<td>先计算地址a + b + c * d，然后把最终地址赋值给寄存器rax</td>
</tr>
<tr>
<td>shr</td>
<td>$0x4, %rdi</td>
<td>右移：rdi &gt;&gt; 4</td>
</tr>
<tr>
<td>mov</td>
<td>mov    %rax,-0x10(%rbp)</td>
<td>将rax载入rbp-16的地址，变型：movb, movq, movl, movq</td>
</tr>
<tr>
<td>movz</td>
<td>movzwl %dx %eax</td>
<td>将源操作数做零扩展后，再复制到目的操作数中</td>
</tr>
<tr>
<td>movs</td>
<td>movswl %dx %eax</td>
<td>将源操作数做符号扩展后，再复制到目的操作数中</td>
</tr>
<tr>
<td>movaps</td>
<td>movaps %xmm0, -0x80(%rbp)</td>
<td>SSE指令，一次移动16字节，<code>要求寄存器地址16字节对齐</code></td>
</tr>
<tr>
<td>xor</td>
<td>xor    %eax, %eax</td>
<td>eax清零</td>
</tr>
<tr>
<td>test</td>
<td>test    %eax, %eax</td>
<td>eax与0比较是否相等</td>
</tr>
<tr>
<td>nopl</td>
<td>nopl  0x0(%rax)</td>
<td>冗余指令，为了字节对齐</td>
</tr>
<tr>
<td>ctlq</td>
<td></td>
<td>将eax符号扩展为8字节的rax</td>
</tr>
</tbody>
</table>
<p>保存入参的寄存器：<code>rdi, rsi, rdx, rcx, r8, r9</code> 依次对应第一、二、三、四、五、六个参数</p>
<p>保存返回值的寄存器： <code>rax</code></p>
<span id="more"></span>
<p>编译选项需添加<code>-fno-omit-frame-pointer</code>，否则rbp不作为栈帧寄存器使用，无法推栈。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -Q --<span class="built_in">help</span>=optimizers -O2 | grep frame</span><br><span class="line">-fomit-frame-pointer                  [enabled]</span><br></pre></td></tr></table></figure>
<p><font color="#FF0000"> <strong>push rbp的具体实现</strong> </font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsp = rsp - 8</span><br><span class="line">*(unsigned long*)rsp = rbp</span><br></pre></td></tr></table></figure>
<p><font color="#FF0000"> <strong>callq addr的具体实现</strong> </font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsp = rsp - 8</span><br><span class="line">*(unsigned long*)rsp = rip + sizeof(inst)</span><br><span class="line">rip = addr</span><br></pre></td></tr></table></figure>
<p>以demo.c为例，分析x86_64下的汇编指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FuncC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x900C</span>;</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="string">&#x27;c&#x27;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">100</span>); <span class="comment">//这里构造了踩栈，后续展开</span></span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消栈保护编译选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector -g demo.c -o demo</span><br></pre></td></tr></table></figure>
<h6 id="1-完整指令-2">1. 完整指令</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncC</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncC:</span><br><span class="line">   0x000055555555471a &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x000055555555471b &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x000055555555471e &lt;+4&gt;:     sub    <span class="variable">$0x60</span>,%rsp</span><br><span class="line">   0x0000555555554722 &lt;+8&gt;:     movl   <span class="variable">$0x900c</span>,-0x4(%rbp)</span><br><span class="line">   0x0000555555554729 &lt;+15&gt;:    mov    <span class="variable">$0x8</span>,%edi</span><br><span class="line">   0x000055555555472e &lt;+20&gt;:    callq  0x5555555545f0 &lt;malloc@plt&gt;</span><br><span class="line">   0x0000555555554733 &lt;+25&gt;:    mov    %rax,-0x10(%rbp)</span><br><span class="line">   0x0000555555554737 &lt;+29&gt;:    movabs <span class="variable">$0x6f57206f6c6c6548</span>,%rax</span><br><span class="line">   0x0000555555554741 &lt;+39&gt;:    mov    <span class="variable">$0x21646c72</span>,%edx</span><br><span class="line">   0x0000555555554746 &lt;+44&gt;:    mov    %rax,-0x30(%rbp)</span><br><span class="line">   0x000055555555474a &lt;+48&gt;:    mov    %rdx,-0x28(%rbp)</span><br><span class="line">   0x000055555555474e &lt;+52&gt;:    movl   <span class="variable">$0x0</span>,-0x20(%rbp)</span><br><span class="line">   0x0000555555554755 &lt;+59&gt;:    movq   <span class="variable">$0x0</span>,-0x60(%rbp)</span><br><span class="line">   0x000055555555475d &lt;+67&gt;:    movq   <span class="variable">$0x0</span>,-0x58(%rbp)</span><br><span class="line">   0x0000555555554765 &lt;+75&gt;:    movq   <span class="variable">$0x0</span>,-0x50(%rbp)</span><br><span class="line">   0x000055555555476d &lt;+83&gt;:    movq   <span class="variable">$0x0</span>,-0x48(%rbp)</span><br><span class="line">   0x0000555555554775 &lt;+91&gt;:    movq   <span class="variable">$0x0</span>,-0x40(%rbp)</span><br><span class="line">   0x000055555555477d &lt;+99&gt;:    lea    -0x60(%rbp),%rax</span><br><span class="line">   0x0000555555554781 &lt;+103&gt;:   mov    <span class="variable">$0x64</span>,%edx</span><br><span class="line">   0x0000555555554786 &lt;+108&gt;:   mov    <span class="variable">$0x63</span>,%esi</span><br><span class="line">   0x000055555555478b &lt;+113&gt;:   mov    %rax,%rdi</span><br><span class="line">   0x000055555555478e &lt;+116&gt;:   callq  0x5555555545e0 &lt;memset@plt&gt;</span><br><span class="line">   0x0000555555554793 &lt;+121&gt;:   mov    -0x10(%rbp),%rax</span><br><span class="line">   0x0000555555554797 &lt;+125&gt;:   mov    %rax,%rdi</span><br><span class="line">   0x000055555555479a &lt;+128&gt;:   callq  0x5555555545c0 &lt;free@plt&gt;</span><br><span class="line">   0x000055555555479f &lt;+133&gt;:   movq   <span class="variable">$0x0</span>,-0x10(%rbp)</span><br><span class="line">   0x00005555555547a7 &lt;+141&gt;:   mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x00005555555547ac &lt;+146&gt;:   leaveq</span><br><span class="line">   0x00005555555547ad &lt;+147&gt;:   retq</span><br></pre></td></tr></table></figure>
<h6 id="2-push开栈">2. push开栈</h6>
<p>开栈大小 = 96字节，rsp是栈顶，rbp是栈底。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x000055555555471a &lt;+0&gt;:     push   %rbp</span><br><span class="line">0x000055555555471b &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">0x000055555555471e &lt;+4&gt;:     sub    <span class="variable">$0x60</span>,%rsp</span><br><span class="line">(gdb) i r <span class="variable">$rsp</span> <span class="variable">$rbp</span></span><br><span class="line">rsp            0x7fffffffe330   0x7fffffffe330</span><br><span class="line">rbp            0x7fffffffe390   0x7fffffffe390</span><br></pre></td></tr></table></figure>
<h6 id="3-将0x900c存入rbp-4的地址，对应代码第3行。">3. 将0x900c存入rbp - 4的地址，对应代码第3行。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000555555554722 &lt;+8&gt;:     movl   <span class="variable">$0x900c</span>,-0x4(%rbp)</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0xf7ffea98      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0xffffffff      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0xf7ffa268      0x00007fff      0xf7ffe710      0x00007fff</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x00000000      0x00000000      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure>
<h6 id="4-将edi赋值成8，作为malloc的第一个入参。malloc的结果rax存入rbp-16的地址。对应代码第4行。">4. 将edi赋值成8，作为malloc的第一个入参。malloc的结果rax存入rbp-16的地址。对应代码第4行。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000555555554729 &lt;+15&gt;:    mov    <span class="variable">$0x8</span>,%edi</span><br><span class="line">0x000055555555472e &lt;+20&gt;:    callq  0x5555555545f0 &lt;malloc@plt&gt;</span><br><span class="line">0x0000555555554733 &lt;+25&gt;:    mov    %rax,-0x10(%rbp)</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0xf7ffea98      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0xffffffff      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0xf7ffa268      0x00007fff      0xf7ffe710      0x00007fff</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x55756260      0x00005555      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure>
<h6 id="5-将0x6f57206f6c6c6548存入rax，将0x21646c72存入edx，rax存入rbp-48的地址，rdx存入rbp-40的地址，最后四字节补0，对应代码第5行。">5. 将0x6f57206f6c6c6548存入rax，将0x21646c72存入edx，rax存入rbp-48的地址，rdx存入rbp-40的地址，最后四字节补0，对应代码第5行。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">48  65  6c  6c  6f  20  57  6f  72  6c  64  21</span><br><span class="line"><span class="string">&#x27;H&#x27;</span> <span class="string">&#x27;e&#x27;</span> <span class="string">&#x27;l&#x27;</span> <span class="string">&#x27;l&#x27;</span> <span class="string">&#x27;o&#x27;</span> <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;W&#x27;</span> <span class="string">&#x27;o&#x27;</span> <span class="string">&#x27;r&#x27;</span> <span class="string">&#x27;l&#x27;</span> <span class="string">&#x27;d&#x27;</span> <span class="string">&#x27;!&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000555555554737 &lt;+29&gt;:    movabs <span class="variable">$0x6f57206f6c6c6548</span>,%rax</span><br><span class="line">0x0000555555554741 &lt;+39&gt;:    mov    <span class="variable">$0x21646c72</span>,%edx</span><br><span class="line">0x0000555555554746 &lt;+44&gt;:    mov    %rax,-0x30(%rbp)</span><br><span class="line">0x000055555555474a &lt;+48&gt;:    mov    %rdx,-0x28(%rbp)</span><br><span class="line">0x000055555555474e &lt;+52&gt;:    movl   <span class="variable">$0x0</span>,-0x20(%rbp)</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0xf7ffea98      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0xffffffff      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x55756260      0x00005555      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure>
<h6 id="6-从rbp-96的地址开始，依次将连续的40字节设置成0，对应代码第6行。">6. 从rbp-96的地址开始，依次将连续的40字节设置成0，对应代码第6行。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000555555554755 &lt;+59&gt;:    movq   <span class="variable">$0x0</span>,-0x60(%rbp)</span><br><span class="line">0x000055555555475d &lt;+67&gt;:    movq   <span class="variable">$0x0</span>,-0x58(%rbp)</span><br><span class="line">0x0000555555554765 &lt;+75&gt;:    movq   <span class="variable">$0x0</span>,-0x50(%rbp)</span><br><span class="line">0x000055555555476d &lt;+83&gt;:    movq   <span class="variable">$0x0</span>,-0x48(%rbp)</span><br><span class="line">0x0000555555554775 &lt;+91&gt;:    movq   <span class="variable">$0x0</span>,-0x40(%rbp)</span><br><span class="line">0x7fffffffe330: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x55756260      0x00005555      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure>
<h6 id="7-从rbp-96的地址开始，依次将连续的100字节设置成’c’，对应代码第7行。（这里构造了踩栈）">7. 从rbp-96的地址开始，依次将连续的100字节设置成’c’，对应代码第7行。（这里构造了踩栈）</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x000055555555477d &lt;+99&gt;:    lea    -0x60(%rbp),%rax</span><br><span class="line">0x0000555555554781 &lt;+103&gt;:   mov    <span class="variable">$0x64</span>,%edx</span><br><span class="line">0x0000555555554786 &lt;+108&gt;:   mov    <span class="variable">$0x63</span>,%esi</span><br><span class="line">0x000055555555478b &lt;+113&gt;:   mov    %rax,%rdi</span><br><span class="line">0x000055555555478e &lt;+116&gt;:   callq  0x5555555545e0 &lt;memset@plt&gt;</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe340: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe350: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe360: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe370: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe380: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe390: 0x63636363      0x00007fff</span><br></pre></td></tr></table></figure>
<h6 id="8-对应代码第8行，由于构造了踩栈，指针b被踩，free非法指针会异常。">8. 对应代码第8行，由于构造了踩栈，指针b被踩，free非法指针会异常。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000555555554793 &lt;+121&gt;:   mov    -0x10(%rbp),%rax</span><br><span class="line">0x0000555555554797 &lt;+125&gt;:   mov    %rax,%rdi</span><br><span class="line">0x000055555555479a &lt;+128&gt;:   callq  0x5555555545c0 &lt;free@plt&gt;</span><br><span class="line">(gdb) ni</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">__GI___libc_free (mem=0x6363636363636363) at malloc.c:3113</span><br><span class="line">3113    malloc.c: No such file or directory.</span><br><span class="line">(gdb) i r</span><br><span class="line">rax            0x0      0</span><br><span class="line">rbx            0x0      0</span><br><span class="line">rcx            0x555555756260   93824994337376</span><br><span class="line">rdx            0x64     100</span><br><span class="line">rsi            0x63     99</span><br><span class="line">rdi            0x6363636363636363       7161677110969590627</span><br><span class="line">rbp            0x7fffffffe390   0x7fffffffe390</span><br><span class="line">rsp            0x7fffffffe2c0   0x7fffffffe2c0</span><br><span class="line">r8             0x2      2</span><br><span class="line">r9             0x0      0</span><br><span class="line">r10            0x555555756010   93824994336784</span><br><span class="line">r11            0x0      0</span><br><span class="line">r12            0x6363636363636363       7161677110969590627</span><br><span class="line">r13            0x7fffffffe4d0   140737488348368</span><br><span class="line">r14            0x0      0</span><br><span class="line">r15            0x0      0</span><br><span class="line">rip            0x7ffff7a7994d   0x7ffff7a7994d &lt;__GI___libc_free+61&gt;</span><br><span class="line">eflags         0x10206  [ PF IF RF ]</span><br><span class="line">cs             0x33     51</span><br><span class="line">ss             0x2b     43</span><br><span class="line">ds             0x0      0</span><br><span class="line">es             0x0      0</span><br><span class="line">fs             0x0      0</span><br><span class="line">gs             0x0      0</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  __GI___libc_free (mem=0x6363636363636363) at malloc.c:3113</span></span><br><span class="line"><span class="comment">#1  0x000055555555479f in FuncC () at demo.c:12</span></span><br><span class="line"><span class="comment">#2  0x00005555555547c7 in FuncB () at demo.c:20</span></span><br></pre></td></tr></table></figure>
<h6 id="9-对应代码第9行">9. 对应代码第9行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x000055555555479f &lt;+133&gt;:   movq   <span class="variable">$0x0</span>,-0x10(%rbp)</span><br><span class="line">0x00005555555547a7 &lt;+141&gt;:   mov    <span class="variable">$0x0</span>,%eax</span><br></pre></td></tr></table></figure>
<h6 id="10-eax-rax作为函数的返回值，对应代码第10行">10. eax/rax作为函数的返回值，对应代码第10行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x00005555555547a7 &lt;+141&gt;:   mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">0x00005555555547ac &lt;+146&gt;:   leaveq</span><br><span class="line">0x00005555555547ad &lt;+147&gt;:   retq</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>common-tools</title>
    <url>/zhoukaiqi/c7f5a0752882/</url>
    <content><![CDATA[<p>本文介绍了常见工具的使用</p>
<span id="more"></span>
<h6 id="1-tcpdump">1. tcpdump</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 指定网口</span><br><span class="line">tcpdump -x -n -v -s 0 -i eth2 -w demo.cap</span><br><span class="line">// 指定IP + 端口</span><br><span class="line">tcpdump -x -n -v -s 0 -i any host IP and port portnum -w demo.cap</span><br><span class="line">tcpdump -x -n -v -s 0 -i any src host srcIP and dst host dstIP and port portnum -w demo.cap</span><br><span class="line">// 环回网口</span><br><span class="line">tcpdump -x -n -v -s 0 -i lo -w demo.cap</span><br><span class="line">// 指定协议类型</span><br><span class="line">tcpdump -x -n -v -s 0 -i any ether proto 56320 -w demo.cap</span><br><span class="line">// 指定物理地址</span><br><span class="line">tcpdump -x -n -v -s 0 -i eth2 not tcp and not udp and ether host macaddr -w demo.cap</span><br><span class="line"></span><br><span class="line">tcpdump -x -n -v -s 0 -i any \(host IP and port 20015 \) or \(host IP \) -w demo.cap</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析</td>
</tr>
<tr>
<td>-v</td>
<td>当分析和打印的时候，产生详细的输出</td>
</tr>
<tr>
<td>-s len</td>
<td>设置tcpdump的数据包抓取长度为len，-s 0抓取完整的数据包</td>
</tr>
<tr>
<td>-i interface</td>
<td>指定tcpdump需要监听的网口，any表示监听所有网络接口</td>
</tr>
<tr>
<td>-w</td>
<td>将抓包数据输出到文件中而不是标准输出</td>
</tr>
<tr>
<td>ether proto 56320</td>
<td>指令协议类型</td>
</tr>
<tr>
<td>ether host macaddr</td>
<td>指定物理地址</td>
</tr>
<tr>
<td>portrange port1-port2</td>
<td>指定端口范围</td>
</tr>
</tbody>
</table>
<p>wireshark抓包过滤指定的字节数据     <a href="https://blog.csdn.net/andrewgithub/article/details/103444611">https://blog.csdn.net/andrewgithub/article/details/103444611</a></p>
<p>data[61:3]==0a:39:00</p>
<p>data数据报文中，以第61字节开始，之后的3个字节的数据为 0a:39:00</p>
<p>IP分片报文中端口信息在data数据中</p>
<h6 id="2-strace">2. strace</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -ff -tt -T -o <span class="built_in">log</span> -p 17720</span><br><span class="line">strace -ft -o <span class="built_in">log</span> -p 35332</span><br><span class="line">// 跟踪单个线程</span><br><span class="line">strace -tt -T -o strace.log -p pid(线程的pid)</span><br><span class="line">// 跟踪整个进程</span><br><span class="line">strace -f -tt -T -o strace.log -p pid(进程的pid)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>跟踪子线程</td>
</tr>
<tr>
<td>-ff</td>
<td>跟踪子线程，每个线程独立文件</td>
</tr>
<tr>
<td>-t</td>
<td>表示时间精确到秒(每秒记录一次)</td>
</tr>
<tr>
<td>-tt</td>
<td>表示时间精确到微秒(每微秒记录一次)</td>
</tr>
<tr>
<td>-T</td>
<td>记录各个系统调用花费的时间，精确到微秒</td>
</tr>
<tr>
<td>-o</td>
<td>表示将追踪结果输出的一个文件</td>
</tr>
<tr>
<td>-p</td>
<td>pid</td>
</tr>
</tbody>
</table>
<h6 id="3-top">3. top</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查线程的CPU占用率</span></span><br><span class="line">top -H -p pid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓某时刻CPU升高的调用栈信息</span></span><br><span class="line"><span class="comment"># 实时查询CPU</span></span><br><span class="line"><span class="built_in">nohup</span> top -H -d 1 -b -n 600 -p pid &gt; top_cpu.log</span><br><span class="line"><span class="comment"># 实时查询调用栈</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span> gstack tid(pid);<span class="built_in">date</span>;<span class="built_in">sleep</span> 1;<span class="keyword">done</span> &gt; stack.log</span><br><span class="line"><span class="comment"># 与上面查询调用栈的方式结合分析</span></span><br><span class="line">perf record -a -F 1000 -g -e cycles (-t tid) -p pid <span class="built_in">sleep</span> 60</span><br></pre></td></tr></table></figure>
<h6 id="4-iptables">4. iptables</h6>
<p>iptables是Linux上常见的防火墙软件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-A 规则链的末尾加入新规则</span><br><span class="line">-D 删除某一个规则</span><br><span class="line">INPUT链：处理输入数据包 </span><br><span class="line">OUTPUT链：处理输出数据包</span><br><span class="line">-s 匹配源地址</span><br><span class="line">-d 匹配目的地址</span><br><span class="line">-p 匹配协议，如tcp,udp,icmp</span><br><span class="line">--sport 匹配源端口</span><br><span class="line">--dport 匹配目的端口</span><br><span class="line">-j 指定动作，ACCEPT 接收数据包;DROP 丢弃数据包</span><br><span class="line"></span><br><span class="line">iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目的IP/目的子网&gt; --dport 目的端口 -j 动作</span><br><span class="line"></span><br><span class="line">iptables -L -n --line-number</span><br><span class="line">iptables -A INPUT -p tcp --dport 1024:65535 -j drop</span><br><span class="line">iptables -A OUTPUT -p tcp -s srcIP -d dstIP --dport 20000:20050 -j drop</span><br><span class="line">iptables -D OUTPUT num</span><br></pre></td></tr></table></figure>
<h6 id="5-netstat">5. netstat</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep -aE <span class="string">&quot;Recv-Q&quot;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a, --all</td>
<td>display all sockets (default: connected)</td>
</tr>
<tr>
<td>-n, --numeric</td>
<td>don’t resolve names(-n会显示端口，不加显示的是协议名)</td>
</tr>
<tr>
<td>-p, --programs</td>
<td>display PID/Program name for sockets</td>
</tr>
<tr>
<td></td>
<td><Socket>={-t|–tcp} {-u|–udp}</td>
</tr>
<tr>
<td>-W, --wide</td>
<td>don’t truncate IP addresses(显示IP地址全名)</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb使用</title>
    <url>/zhoukaiqi/ffde21da3a9c/</url>
    <content><![CDATA[<p>本文介绍了gdb的常见用法。</p>
<span id="more"></span>
<h6 id="1、入参与返回值">1、入参与返回值</h6>
<table>
<thead>
<tr>
<th style="text-align:left">CPU</th>
<th style="text-align:left">入参</th>
<th style="text-align:left">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x86</td>
<td style="text-align:left">ebp+8, ebp+12, ebp+16, ebp+20</td>
<td style="text-align:left">eax</td>
</tr>
<tr>
<td style="text-align:left">x86_64</td>
<td style="text-align:left">rdi, rsi, rdx, rcx, r8, r9</td>
<td style="text-align:left">rax</td>
</tr>
<tr>
<td style="text-align:left">arm64</td>
<td style="text-align:left">x0, x1, x2, x3, x4, x5, x6, x7</td>
<td style="text-align:left">x0</td>
</tr>
</tbody>
</table>
<p>返回值需要在执行finish后查看</p>
<h6 id="2、常见命令">2、常见命令</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb -q bin                                   // 启动时不显示提示信息</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint    // 屏蔽某些信号</span><br><span class="line"><span class="built_in">set</span> height 0                                 // 不限制输出行数</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> pretty on                          // 美化结构体打印</span><br><span class="line">i thread                                     // 查看所有线程信息</span><br><span class="line">thread threadno                              // 切换到指定线程</span><br><span class="line">thread apply all bt                          // 查看所有线程栈信息</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;Handle[%u], PtNo[%u]\n&quot;</span>, <span class="variable">$rdi</span>, <span class="variable">$rsi</span>  // 打印信息</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> thread-events off                  // 不显示线程启动和退出信息</span><br><span class="line">call getpid()                                // 获取拉起进程的pid</span><br><span class="line">shell <span class="built_in">date</span> +%H:%M:%S.%N                      // 加shell可以执行linux命令</span><br><span class="line">i r                                          // 查看寄存器信息</span><br><span class="line">generate-core-file                           // 生成core文件</span><br><span class="line">bt n(-n)                                     // 显示栈顶(栈底)的n层栈</span><br><span class="line">x addr                                       // 解析addr对应的函数</span><br><span class="line">x/s str                                      // 显示str对应的字符串</span><br><span class="line">x/nbx                                        // 显示n个单字节</span><br><span class="line">x/nhx                                        // 显示n个双字节</span><br><span class="line">x/nwx                                        // 显示n个4字节</span><br><span class="line">x/ngx                                        // 显示n个8字节</span><br><span class="line">frame n                                      // 切换到第n层栈帧（切换栈帧后i r查看的寄存器可能并不可信）</span><br><span class="line">disassemble func                             // 反汇编函数</span><br><span class="line">disassemble func, +n                         // 反汇编函数的指定n字节</span><br><span class="line">disassemble /m func                          // 显示源码和汇编(编译选项要加-g)</span><br><span class="line">disassemble /r func                          // 显示汇编和机器码</span><br><span class="line">disassemble /mr func                         // 显示源码、汇编和机器码</span><br><span class="line">watch  *addr                                 // 监控地址被写</span><br><span class="line">rwatch *addr                                 // 监控地址被读</span><br><span class="line">awatch *addr                                 // 监控地址被读写</span><br><span class="line">ptype /o struct xxx_type                     // 查看结构体成员的偏移量</span><br></pre></td></tr></table></figure>
<h6 id="3、条件断点">3、条件断点</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x86 32位:  b func <span class="keyword">if</span> *(unsigned int*)(<span class="variable">$ebp</span>+8) == 226 &amp;&amp; *(unsigned int*)(<span class="variable">$ebp</span>+16) == 206</span><br><span class="line">x86 64位:  b func <span class="keyword">if</span> <span class="variable">$rdi</span> == 226 &amp;&amp; <span class="variable">$rdx</span> == 206</span><br><span class="line">arm 64位:  b func <span class="keyword">if</span> <span class="variable">$x0</span> == 226 &amp;&amp; <span class="variable">$x2</span> == 206</span><br><span class="line">线程断点:  b func thread threadno <span class="keyword">if</span> condition</span><br><span class="line">字符断点:  b func <span class="keyword">if</span> *(unsigned char*)(<span class="variable">$ebp</span>+8)==<span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>
<h6 id="4、查看所有线程栈信息">4、查看所有线程栈信息</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gdb attach <span class="number">10889</span></span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height <span class="number">0</span></span><br><span class="line">i thread</span><br><span class="line">thread apply all bt</span><br><span class="line">det</span><br><span class="line">q</span><br></pre></td></tr></table></figure>
<h6 id="5、查看调用栈">5、查看调用栈</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb attach 10889</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height 0</span><br><span class="line">b func</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">bt</span><br><span class="line">det</span><br><span class="line">q</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h6 id="6、查看入参和返回值">6、查看入参和返回值</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb attach pid   ----------//进程的pid由ps -ef | grep xxx查询到</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height 0</span><br><span class="line">define oops</span><br><span class="line">bt        ----------// 显示调用栈</span><br><span class="line">i r       ----------// 显示寄存器信息，主要看入参，x86 32位进程看入参要替换成x/8wx <span class="variable">$ebp</span>+8</span><br><span class="line">fin       ----------// 表示执行完当前打断点的函数func</span><br><span class="line">i r       ----------// 在fin之后表示显示返回值，x86，x86_64，arm的返回值依次对应eax,rax,x0</span><br><span class="line">det</span><br><span class="line">q</span><br><span class="line">end</span><br><span class="line">b func    ----------// func即打断点的函数</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">oops</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h6 id="7、查看出参">7、查看出参</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb attach `pidof demo`</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> heigh 0</span><br><span class="line">define ops</span><br><span class="line">bt</span><br><span class="line">i r</span><br><span class="line">x/s <span class="variable">$rdi</span></span><br><span class="line">p <span class="variable">$rsi</span></span><br><span class="line"><span class="built_in">set</span> <span class="variable">$a</span>=<span class="variable">$rdx</span></span><br><span class="line">fin</span><br><span class="line">x/5wx <span class="variable">$a</span></span><br><span class="line">x/s <span class="variable">$a</span></span><br><span class="line">p *(unsigned int*)(<span class="variable">$a</span>+16)</span><br><span class="line">det</span><br><span class="line">q</span><br><span class="line">end</span><br><span class="line">b func</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">ops</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h6 id="8、在函数func2执行之后再执行函数func1">8、在函数<code>func2</code>执行之后再执行函数<code>func1</code></h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb attach `pidof demo`</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height 0</span><br><span class="line">b func1</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">bt</span><br><span class="line">det</span><br><span class="line">q</span><br><span class="line">end</span><br><span class="line"><span class="built_in">disable</span> 1</span><br><span class="line">b func2</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="built_in">enable</span> 1</span><br><span class="line">bt</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h6 id="9、重定向到linux屏幕">9、重定向到linux屏幕</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重定向后，调用printf的打印会输出到指定的屏幕</span></span><br><span class="line">gdb attach 10889</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height 0</span><br><span class="line">call (int)close(1)</span><br><span class="line">call (int)close(2)</span><br><span class="line"><span class="comment"># 此处的路径用tty查询</span></span><br><span class="line">call (int)(<span class="string">&quot;/dev/tty1&quot;</span>, 2)</span><br><span class="line">detach</span><br><span class="line">q</span><br></pre></td></tr></table></figure>
<h6 id="10、扫描core文件1">10、扫描core文件1</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">define mem_scan</span><br><span class="line">    <span class="built_in">set</span> logging file xxx.txt</span><br><span class="line">    <span class="built_in">set</span> logging on</span><br><span class="line">    <span class="built_in">set</span> logging overwrite on</span><br><span class="line">    <span class="built_in">set</span> height 0</span><br><span class="line">    <span class="built_in">set</span> <span class="built_in">print</span> pretty on</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$g_index</span> = 0</span><br><span class="line">    <span class="keyword">while</span> (xxx)</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;**************************\n&quot;</span></span><br><span class="line">        // 具体扫描实现</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;**************************\n&quot;</span></span><br><span class="line">        <span class="built_in">set</span> = <span class="variable">$g_index</span> + 1</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">set</span> logging off</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">mem_scan</span><br></pre></td></tr></table></figure>
<h6 id="11、扫描core文件2">11、扫描core文件2</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb attach pid</span><br><span class="line"><span class="built_in">set</span> height 0</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="built_in">set</span> <span class="variable">$array</span> = &#123;1, 3, 5, 7, 9&#125;</span><br><span class="line"><span class="built_in">set</span> <span class="variable">$num</span> = sizeof(<span class="variable">$array</span>) / 4</span><br><span class="line"><span class="built_in">set</span> <span class="variable">$index</span> = 0</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$index</span> &lt; <span class="variable">$num</span>)</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$linkNo</span> = <span class="variable">$array</span>[<span class="variable">$index</span>]</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$tmp</span> = *(unsigned long*)&amp;g_state + <span class="variable">$linkNo</span> * 8</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$plane</span> = *(unsigned long*)<span class="variable">$tmp</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">&quot;Plane[%u]\n&quot;</span>, <span class="variable">$plane</span></span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$index</span> = <span class="variable">$index</span> + 1</span><br><span class="line">end</span><br><span class="line">det</span><br><span class="line">q</span><br></pre></td></tr></table></figure>
<h6 id="12、内存搜索">12、内存搜索</h6>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">搜索某块内存中的value</span><br><span class="line">find [/sn] start_addr, +len, val1 [, val2, ...]</span><br><span class="line">find [/sn] start_addr, end_addr, val1 [, val2, ...]</span><br><span class="line">s：表示搜索value所占的字节数，b/h/w/g</span><br><span class="line">n：表示最多输出n个查找结果</span><br><span class="line"></span><br><span class="line">具体示例</span><br><span class="line"><span class="number">0x7f55fa12ce70</span>: <span class="number">0x12345678</span> <span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x12340000</span></span><br><span class="line"><span class="number">0x7f55fa12ce80</span>: <span class="number">0xdeaddead</span> <span class="number">0x00000000</span> <span class="number">0xdeaddead</span> <span class="number">0x00000000</span></span><br><span class="line">(gdb) find /w2 <span class="number">0x7f55fa12ce70</span>, +<span class="number">0x20</span>, <span class="number">0xdeaddead</span></span><br><span class="line"><span class="number">0x7f55fa12ce80</span></span><br><span class="line"><span class="number">0x7f55fa12ce88</span></span><br><span class="line"><span class="number">2</span> patterns found.</span><br><span class="line">(gdb) find /w2 <span class="number">0x7f55fa12ce70</span>, <span class="number">0x7f55fa12ce90</span>, <span class="number">0xdeaddead</span></span><br><span class="line"><span class="number">0x7f55fa12ce80</span></span><br><span class="line"><span class="number">0x7f55fa12ce88</span></span><br><span class="line"><span class="number">2</span> patterns found.</span><br></pre></td></tr></table></figure>
<h6 id="13、gdb-shell脚本">13、gdb shell脚本</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">RunGDB</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> cmdFile=gdb.txt</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$cmdFile</span>&quot;</span></span><br><span class="line">    gdb -q -batch -x <span class="string">&quot;<span class="variable">$cmdFile</span>&quot;</span>  2&gt;/dev/null</span><br><span class="line">    <span class="built_in">rm</span> <span class="string">&quot;<span class="variable">$cmdFile</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">AttachByPid</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">local</span> pid=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> gdbCmdPre=<span class="string">&quot;</span></span><br><span class="line"><span class="string">attach <span class="variable">$pid</span></span></span><br><span class="line"><span class="string">set height 0</span></span><br><span class="line"><span class="string">set print thread-events off</span></span><br><span class="line"><span class="string">set print inferior-events off</span></span><br><span class="line"><span class="string">handle SIG35 SIG36 SIGUSR2 nostop noprint&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> gdbCmd=<span class="string">&quot;<span class="variable">$gdbCmdPre</span></span></span><br><span class="line"><span class="string">b FuncD&quot;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">command</span></span><br><span class="line"><span class="string">    bt</span></span><br><span class="line"><span class="string">    i r $rsp $rbp</span></span><br><span class="line"><span class="string">    set $tmprbp = $rbp</span></span><br><span class="line"><span class="string">    set $index = 0</span></span><br><span class="line"><span class="string">    while $index &lt; 4</span></span><br><span class="line"><span class="string">        set $nextrbp = *(unsigned long*)$tmprbp</span></span><br><span class="line"><span class="string">        set $func = *(unsigned long*)($tmprbp + 8)</span></span><br><span class="line"><span class="string">        printf &quot;rbp[0x%lx], func[0x%lx]\n&quot;, $tmprbp, $func</span></span><br><span class="line"><span class="string">        set $tmprbp = $nextrbp</span></span><br><span class="line"><span class="string">        set $index = $index + 1</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    det</span></span><br><span class="line"><span class="string">    q</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">c&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        RunGDB <span class="string">&quot;<span class="variable">$gdbCmd</span>&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 2</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AttachByPid <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>实际使用需要修改commmad和end之间的内容。</p>
<h6 id="14、tips">14、tips</h6>
<p>frame切换栈帧后，挥发性寄存器的值就容易不准确。</p>
<blockquote>
<p>总而言之，一些挥发性寄存器的值可能随着栈帧的展开而不断的累加错误。也就是这里所说的：如果栈帧越靠外层，这些挥发性寄存器的值就越容易不准确。<br>
Usually ABIs reserve some registers as not needed to be saved by the callee (a.k.a.: “caller-saved”, “call-clobbered” or “volatile” registers). It may therefore not be possible for GDB to know the value a register had before the call (in other words, in the outer frame), if the register value has since been changed by the callee. GDB tries to deduce where the inner frame saved (“callee-saved”) registers, from the debug info, unwind info, or the machine code generated by your compiler. If some register is not saved, and GDB knows the register is “caller-saved” (via its own knowledge of the ABI, or because the debug/unwind info explicitly says the register’s value is undefined), GDB displays ‘<not saved>’ as the register’s value. With targets that GDB has no knowledge of the register saving convention, if a register was not saved by the callee, then its value and location in the outer frame are assumed to be the same of the inner frame. This is usually harmless, because if the register is call-clobbered, the caller either does not care what is in the register after the call, or has code to restore the value that it does care about. Note, however, that if you change such a register in the outer frame, you may also be affecting the inner frame. <strong>Also, the more “outer” the frame is you’re looking at, the more likely a call-clobbered register’s value is to be wrong, in the sense that it doesn’t actually represent the value the register had just before the call</strong>.</p>
</blockquote>
<p><a href="https://www.cnblogs.com/tsecer/p/11371549.html">https://www.cnblogs.com/tsecer/p/11371549.html</a></p>
<p>参考：<a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/info-function.html">https://wizardforcel.gitbooks.io/100-gdb-tips/content/info-function.html</a></p>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>调用者与被调用者的寄存器优化</title>
    <url>/zhoukaiqi/e89ef2b48b02/</url>
    <content><![CDATA[<p><strong>问题背景</strong></p>
<p>最近遇到了一个少见的热补丁问题，叶子函数(FuncChild)打上热补丁后，进程在调用父函数(FuncFather)时会复位。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncFather</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncFather:</span><br><span class="line">   <span class="number">0x0000000000687f10</span> &lt;+<span class="number">0</span>&gt;:     adrp   x3, <span class="number">0x1f8e000</span></span><br><span class="line">   <span class="number">0x0000000000687f14</span> &lt;+<span class="number">4</span>&gt;:     stp    x29, x30, [sp, #<span class="number">-32</span>]!</span><br><span class="line">   <span class="number">0x0000000000687f18</span> &lt;+<span class="number">8</span>&gt;:     mov    x4, x2</span><br><span class="line">   <span class="number">0x0000000000687f1c</span> &lt;+<span class="number">12</span>&gt;:    mov    x29, sp</span><br><span class="line">   <span class="number">0x0000000000687f20</span> &lt;+<span class="number">16</span>&gt;:    ldr    x2, [x3, #<span class="number">744</span>]</span><br><span class="line">   <span class="number">0x0000000000687f24</span> &lt;+<span class="number">20</span>&gt;:    mov    x5, x1</span><br><span class="line">   <span class="number">0x0000000000687f28</span> &lt;+<span class="number">24</span>&gt;:    add    x1, x29, #<span class="number">0x17</span></span><br><span class="line">   <span class="number">0x0000000000687f2c</span> &lt;+<span class="number">28</span>&gt;:    ldr    x6, [x2]</span><br><span class="line">   <span class="number">0x0000000000687f30</span> &lt;+<span class="number">32</span>&gt;:    str    x6, [x29, #<span class="number">24</span>]</span><br><span class="line">   <span class="number">0x0000000000687f34</span> &lt;+<span class="number">36</span>&gt;:    mov    x6, #<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000687f38</span> &lt;+<span class="number">40</span>&gt;:    bl     <span class="number">0x687de0</span> &lt;FuncChild&gt;</span><br><span class="line">   <span class="number">0x0000000000687f3c</span> &lt;+<span class="number">44</span>&gt;:    cbz    w0, <span class="number">0x687f70</span> &lt;FuncFather+<span class="number">96</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000687f40</span> &lt;+<span class="number">48</span>&gt;:    ldrb   w0, [x29, #<span class="number">23</span>]</span><br><span class="line">   <span class="number">0x0000000000687f44</span> &lt;+<span class="number">52</span>&gt;:    strb   w0, [x4]</span><br><span class="line">   <span class="number">0x0000000000687f48</span> &lt;+<span class="number">56</span>&gt;:    ldrb   w0, [x5, #<span class="number">25</span>]</span><br><span class="line">   <span class="number">0x0000000000687f4c</span> &lt;+<span class="number">60</span>&gt;:    cmp    w0, #<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000687f50</span> &lt;+<span class="number">64</span>&gt;:    cset   w0, eq <span class="comment">// eq = none</span></span><br><span class="line">=&gt; <span class="number">0x0000000000687f54</span> &lt;+<span class="number">68</span>&gt;:    ldr    x3, [x3, <span class="number">744</span>]</span><br><span class="line">(gdb) i r x3</span><br><span class="line">x3            <span class="number">0x0000000000018000</span>        <span class="number">0x0000000000018000</span></span><br></pre></td></tr></table></figure>
<p>异常的指令是<code>0x0000000000687f54 &lt;+68&gt;:    ldr    x3, [x3, 744]</code>，x3寄存器是0x18000。</p>
<p>FuncFather在之前读写过x3寄存器的只有<code>0x0000000000687f20 &lt;+16&gt;:    ldr    x2, [x3, #744]</code></p>
<p>所以，即使x3寄存器不可访问，也应该在FuncFather+16指令时出现异常，这里存在了矛盾点。合理的怀疑是FuncChild修改了x3寄存器，从FuncChild的汇编分也证明了这一点。</p>
<p>为什么会出现被调用者复用了调用者的寄存器且不恢复，查询了相关资料予以说明。</p>
<p><strong>相关介绍</strong></p>
<p>对于函数调用，假设存在这样两个函数 funA 和 funB，其中 funA 调用 funB 函数，这里称 funA 为 caller（调用者），funB 为 callee（被调用者），funA 和 funB 都使用了相同的寄存器 R。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e7b7788746c1d6c99e49d84a79c2f8c1_720w.jpg" alt=""></p>
<p>寄存器R被funB修改了，funA再使用相同寄存器R时已经是错误的数据。</p>
<p>如果 funA 在调用 funB 前保存寄存器 R 中的数据，funB 返回后再将数据恢复到 R 中，或者 funB 先保存 R 中原有的数据，然后在返回前恢复，就可以解决这类问题。</p>
<p><strong>唯一的调用约定</strong></p>
<p>那寄存器该由 caller 还是 callee 来保存？这就需要遵循函数的调用约定（call convention），不同的 ABI 和不同的平台，函数的调用约定是不一样的，对于 Linux 来说，它遵循的是 System V ABI 的 call convention，x86_64 平台下函数调用约定有且只有一种，调用者 caller 和被调用者 callee 需要对相应的寄存器进行保存和恢复操作：</p>
<ul>
<li>Caller-save registers : RDI, RSI, RDX, RCX, R8, R9, RAX, R10, R11</li>
<li>Callee-save registers : RBX, RBP, R12, R13, R14, R15</li>
</ul>
<p><strong>调用约定，gcc 它遵守了吗？</strong></p>
<p>设问：当函数实现很简单，只用到了少量寄存器，那没使用到的还需要保存吗？</p>
<p>答案：it depends。根据编译选项决定。</p>
<p>众所周知，GCC 编译器有 -O0、-O1、-O2 和 -Ox 等编译优化选项，优化范围和深度随 x 增大而增大（-O0是不优化，其中隐含的意思是，它会严格遵循 ABI 中的调用约定，对所有使用的寄存器进行保存和恢复）。</p>
<p>Linux 内核选用的都是 -O2 优化。GCC 会选择性的不遵守调用约定，也就是设问里提到的，不需要保存没使用到的寄存器。</p>
<p><strong>当【运行时替换】撞见【调用约定】</strong></p>
<p>GCC 之所以可以做这个优化，是因为 GCC 高屋建瓴，了解程序的执行流。当它知道 callee，caller 的寄存器分配情况，就会大胆且安全地做各种优化。</p>
<p>但是，运行时替换破坏了这个假设，GCC 所掌握的 callee 信息，极有可能是错误的。那么这些优化可能会引发严重问题。这里以一个具体的实例进行详细说明，<strong>（ x86_64 平台）</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译命令：gcc leaf.c -o leaf -O2 -g  (kernel 采用的是 O2 优化选项)</span></span><br><span class="line"><span class="comment">// 执行过程：./leaf</span></span><br><span class="line"><span class="comment">// 编译选项 -fipa-ra</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noinline __attribute__((noinline))</span></span><br><span class="line"></span><br><span class="line">noinline <span class="type">int</span> <span class="title function_">FuncC</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">int</span> <span class="title function_">FuncB</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">int</span> <span class="title function_">NewFuncB</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> FuncC(x * <span class="number">2</span>) * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">int</span> <span class="title function_">FuncA</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> temp = FuncB(x);</span><br><span class="line">    <span class="keyword">return</span> x + temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mprotect传入的地址必须页对齐</span></span><br><span class="line">    <span class="type">void</span> *startAddr = (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)&amp;FuncB &amp; (~<span class="number">0xFFF</span>));</span><br><span class="line">    <span class="keyword">if</span> (mprotect(startAddr, <span class="number">15</span>, PROT_WRITE | PROT_EXEC | PROT_READ)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mprotect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 利用 jump 指令将函数 FuncB 替换为 NewFuncB 函数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pucInst = (<span class="type">unsigned</span> <span class="type">char</span> *)FuncB;</span><br><span class="line">    *pucInst = <span class="number">0xe9</span>; <span class="comment">// 短跳转jmp指令机器码</span></span><br><span class="line">    pucInst++;</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span>*)pucInst = ((<span class="type">unsigned</span> <span class="type">long</span>)&amp;NewFuncB - (<span class="type">unsigned</span> <span class="type">long</span>)&amp;FuncB - <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, FuncA(x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序解释：该程序是对输入的数字进行计算，运行时利用 jump 指令将程序中的函数 b 替换为 newb 函数，即，将 y = x + x 计算过程替换为 y = x + (2x) ^ 3 * x；</li>
<li>程序编译：gcc leaf.c -o leaf -O2 -g，这里我们采用的是与编译内核相同的优化选项 -O2；</li>
<li>程序执行：./leaf，输入参数：4，输出结果：132；</li>
<li>程序错误：132是错误的结果，应该是 130，而且直接调用 newb 函数编译执行的结果是 130。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncA</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncA:</span><br><span class="line">   <span class="number">0x0000000000001260</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x0000000000001264</span> &lt;+<span class="number">4</span>&gt;:     sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">0x0000000000001268</span> &lt;+<span class="number">8</span>&gt;:     callq  <span class="number">0x1220</span> &lt;FuncB&gt;</span><br><span class="line">   <span class="number">0x000000000000126d</span> &lt;+<span class="number">13</span>&gt;:    mov    %eax,<span class="number">0xc</span>(%rsp)</span><br><span class="line">   <span class="number">0x0000000000001271</span> &lt;+<span class="number">17</span>&gt;:    mov    <span class="number">0xc</span>(%rsp),%eax</span><br><span class="line">   <span class="number">0x0000000000001275</span> &lt;+<span class="number">21</span>&gt;:    add    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">0x0000000000001279</span> &lt;+<span class="number">25</span>&gt;:    add    %edi,%eax</span><br><span class="line">   <span class="number">0x000000000000127b</span> &lt;+<span class="number">27</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disassemble FuncB</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncB:</span><br><span class="line">   <span class="number">0x0000000000001220</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x0000000000001224</span> &lt;+<span class="number">4</span>&gt;:     mov    %edi,%eax</span><br><span class="line">   <span class="number">0x0000000000001226</span> &lt;+<span class="number">6</span>&gt;:     retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>当FuncA通过FuncB跳转到NewFuncB后：edi = 2 * edi，返回到FuncA时edi寄存器已经被修改了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncA</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncA:</span><br><span class="line">   <span class="number">0x0000000008001260</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x0000000008001264</span> &lt;+<span class="number">4</span>&gt;:     sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">=&gt; <span class="number">0x0000000008001268</span> &lt;+<span class="number">8</span>&gt;:     callq  <span class="number">0x8001220</span> &lt;FuncB&gt;</span><br><span class="line">   <span class="number">0x000000000800126d</span> &lt;+<span class="number">13</span>&gt;:    mov    %eax,<span class="number">0xc</span>(%rsp)</span><br><span class="line">   <span class="number">0x0000000008001271</span> &lt;+<span class="number">17</span>&gt;:    mov    <span class="number">0xc</span>(%rsp),%eax</span><br><span class="line">   <span class="number">0x0000000008001275</span> &lt;+<span class="number">21</span>&gt;:    add    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">0x0000000008001279</span> &lt;+<span class="number">25</span>&gt;:    add    %edi,%eax</span><br><span class="line">   <span class="number">0x000000000800127b</span> &lt;+<span class="number">27</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) si</span><br><span class="line">(gdb) disassemble FuncB</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncB:</span><br><span class="line">=&gt; <span class="number">0x0000000008001220</span> &lt;+<span class="number">0</span>&gt;:     jmpq   <span class="number">0x8001240</span> &lt;NewFuncB&gt;</span><br><span class="line">   <span class="number">0x0000000008001225</span> &lt;+<span class="number">5</span>&gt;:     clc</span><br><span class="line">   <span class="number">0x0000000008001226</span> &lt;+<span class="number">6</span>&gt;:     retq</span><br><span class="line">(gdb) si</span><br><span class="line">(gdb) disassemble NewFuncB</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function NewFuncB:</span><br><span class="line">=&gt; <span class="number">0x0000000008001240</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x0000000008001244</span> &lt;+<span class="number">4</span>&gt;:     mov    %edi,%edx</span><br><span class="line">   <span class="number">0x0000000008001246</span> &lt;+<span class="number">6</span>&gt;:     lea    (%rdi,%rdi,<span class="number">1</span>),%edi</span><br><span class="line">   <span class="number">0x0000000008001249</span> &lt;+<span class="number">9</span>&gt;:     callq  <span class="number">0x8001230</span> &lt;FuncC&gt;</span><br><span class="line">   <span class="number">0x000000000800124e</span> &lt;+<span class="number">14</span>&gt;:    imul   %edx,%eax</span><br><span class="line">   <span class="number">0x0000000008001251</span> &lt;+<span class="number">17</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">ret = <span class="number">132</span></span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">292</span>) exited normally]</span><br></pre></td></tr></table></figure>
<p>查找相关资料，发现了这个<code> -fipa-ra</code> 选项，可以说它是优化的幕后主使。</p>
<p>如果开启这个选项，callee 中如果没有使用到 caller 使用的寄存器，就没有必要保存这些寄存器，前提是，callee 与 caller 在同一个.c中而且 callee 函数比 caller 先被编译，这样才可能出现前面的优化。如果开启了 -O2 及以上的编译优化选项，则会使能 -fipa-ra 选项，然而，如果开启了 -p 或者 -pg 这些选项，或者，无法明确 callee 所使用的寄存器，-fipa-ra 选项会被禁用。</p>
<p>加上<code>-fno-ipa-ra</code>屏蔽该优化，运行结果正常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xxx@ubuntu:src$ gcc -Q --help=optimizers -O2 | grep fipa-ra</span><br><span class="line">  -fipa-ra                              [enabled]</span><br><span class="line">xxx@ubuntu:src$ gcc leaf.c -o leaf -O2 -g -fno-ipa-ra</span><br><span class="line">xxx@ubuntu:src$ ./leaf</span><br><span class="line">ret = <span class="number">130</span></span><br><span class="line">xxx@ubuntu:src$</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/397027508">https://zhuanlan.zhihu.com/p/397027508</a></p>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>符号解析</title>
    <url>/zhoukaiqi/6af7315879b9/</url>
    <content><![CDATA[<p>本文介绍了链接中的符号解析过程。</p>
<span id="more"></span>
<h4 id="1-静态库">1 静态库</h4>
<p>将.o目标文件打包成.a文件即静态库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打包静态库</span></span><br><span class="line">ar rcs libtest.a test1.o test2.o</span><br><span class="line"><span class="comment">// 加了-static会把系统的.a比如libc.a中需要的.o也链接到main中</span></span><br><span class="line">gcc main.o -<span class="type">static</span> -L. -ltest -o main1</span><br><span class="line">gcc main.o -L. -ltest -o main2</span><br><span class="line">-rwx------. <span class="number">1</span> root root <span class="number">750</span>K Jul  <span class="number">3</span> <span class="number">22</span>:<span class="number">49</span> main1</span><br><span class="line">-rwx------. <span class="number">1</span> root root  <span class="number">17</span>K Jul  <span class="number">3</span> <span class="number">22</span>:<span class="number">51</span> main2</span><br><span class="line"><span class="comment">// main1是完全链接的可执行目标文件，所以比较大；main2依赖的函数可以从so中获取，所以相对比较小</span></span><br><span class="line">[root@<span class="number">192</span> demo]<span class="meta"># ldd main1</span></span><br><span class="line">        not a dynamic executable</span><br><span class="line">[root@<span class="number">192</span> demo]<span class="meta"># ldd main2</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007ffccebc1000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007f7238d61000</span>)</span><br><span class="line">        /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f7238f2e000</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-符号解析">2 符号解析</h4>
<p>在符号解析阶段，链接器从左到右按照它们在命令行上出现的顺序来扫描可重定位目标文件和.a静态库文件。</p>
<h4 id="2-1-建立三个空的集合">2.1 建立三个空的集合</h4>
<ul>
<li>
<p>集合E：放入该集合中的文件，后续将用于合成最终的可执行文件</p>
</li>
<li>
<p>集合U：当前所有未解析的引用符号</p>
</li>
<li>
<p>集合D：当前所有定义的符号</p>
</li>
</ul>
<blockquote>
<p>注：E\U\D，此处分别表示 Empty, Undefined, Defined</p>
</blockquote>
<h4 id="2-2-从左到右依次扫描每一个文件">2.2 从左到右依次扫描每一个文件</h4>
<p>1） 按命令行指定顺序依次处理每个目标文件和库文件；</p>
<p>2） 如果为.o文件，将其加入集合E，将其所有符号加入D，将引用但未定义的符号加入U；</p>
<p>3） 如果为静态库文件，实际链接过程中是拆成单个的.o文件来扫描的。假设静态库中的第一个目标文件是 m 。</p>
<h5 id="第一步：匹配">第一步：匹配</h5>
<p>检查集合 U 中未定义的符号是否在目标文件 m 的符号表中</p>
<p>若没有，抛弃 m，继续扫描静态库中的下一个目标文件；若有，则</p>
<ul>
<li>将 m 加入集合 E 中</li>
<li>将 m 中定义的符号添加集合 D 中</li>
<li>将 m 中引用但未定义的符号，添加到集合 U 中</li>
</ul>
<h5 id="第二步：重复">第二步：重复</h5>
<p>继续扫描静态库中的下一个目标文件，重复上一步的匹配过程，直到 U 和 D 都不再发生变化</p>
<p>4） 如果为动态库文件，移除U中得到解析的符号，在D中加入动态库中符号；</p>
<p>5） 若集合U最终为空，链接成功，对E中文件进行合并和重定位处理，生成可执行文件，否则报告链接出错。</p>
<h4 id="3-举例说明">3 举例说明</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># main.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test1();</span><br><span class="line">    test2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># test1.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># test2.cc</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test2\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译命令：<code>gcc main.c test1.c test2.c -c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc main.c test1.c test2.c -c</span><br><span class="line">Coder:test$ ll *.o</span><br><span class="line">-rw-r--r-- <span class="number">1</span> coder coder <span class="number">1608</span> Jul <span class="number">17</span> <span class="number">22</span>:<span class="number">57</span> main.o</span><br><span class="line">-rw-r--r-- <span class="number">1</span> coder coder <span class="number">1680</span> Jul <span class="number">17</span> <span class="number">22</span>:<span class="number">57</span> test1.o</span><br><span class="line">-rw-r--r-- <span class="number">1</span> coder coder <span class="number">1680</span> Jul <span class="number">17</span> <span class="number">22</span>:<span class="number">57</span> test2.o</span><br></pre></td></tr></table></figure>
<p>都是.o文件时，无顺序要求，都能编译成功。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Coder:test$ gcc main.o test1.o test2.o -o main</span><br><span class="line">Coder:test$</span><br><span class="line">Coder:test$ gcc test1.o main.o test2.o -o main</span><br><span class="line">Coder:test$</span><br></pre></td></tr></table></figure>
<p>使用静态库或者动态库时，有顺序的要求。（使用动态库时，执行程序前需要执行动态库的路径<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Coder:test$ ar rcs libtest.a test1.o test2.o</span><br><span class="line">Coder:test$ gcc libtest.a main.o -o main</span><br><span class="line">/usr/bin/ld: main.o: in function `main<span class="number">&#x27;</span>:</span><br><span class="line">main.c:(.text+<span class="number">0xe</span>): undefined reference to `test1<span class="number">&#x27;</span></span><br><span class="line">/usr/bin/ld: main.c:(.text+<span class="number">0x18</span>): undefined reference to `test2<span class="number">&#x27;</span></span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">Coder:test$ gcc main.o libtest.a -o main</span><br><span class="line">Coder:test$</span><br><span class="line">Coder:test$</span><br><span class="line">Coder:test$ gcc -shared -fPIC test1.o test2.o -o libtest.so</span><br><span class="line">Coder:test$ gcc libtest.so main.o -o main</span><br><span class="line">/usr/bin/ld: main.o: in function `main<span class="number">&#x27;</span>:</span><br><span class="line">main.c:(.text+<span class="number">0xe</span>): undefined reference to `test1<span class="number">&#x27;</span></span><br><span class="line">/usr/bin/ld: main.c:(.text+<span class="number">0x18</span>): undefined reference to `test2<span class="number">&#x27;</span></span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">Coder:test$ gcc main.o libtest.so -o main</span><br><span class="line">Coder:test$ ./main</span><br><span class="line">./main: error <span class="keyword">while</span> loading shared libraries: libtest.so: cannot open shared object file: No such file or directory</span><br><span class="line">Coder:test$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./</span><br><span class="line">Coder:test$ ./main</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">Coder:test$</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>link</category>
      </categories>
      <tags>
        <tag>link</tag>
      </tags>
  </entry>
  <entry>
    <title>静态链接</title>
    <url>/zhoukaiqi/7508e955a9b1/</url>
    <content><![CDATA[<p>本文介绍静态链接中的重定位。</p>
<span id="more"></span>
<h4 id="1-重定位结构体">1 重定位结构体</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> offset;    <span class="comment">/* Offset of the reference to relocate */</span></span><br><span class="line">    <span class="type">long</span> type:<span class="number">32</span>,   <span class="comment">/* Relocation type */</span></span><br><span class="line">    <span class="type">long</span> symbol:<span class="number">32</span>; <span class="comment">/* Symbol table index */</span></span><br><span class="line">    <span class="type">long</span> addend;    <span class="comment">/* Constant part of relocation expression */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line">offset：需要重定位的地址离当前函数首地址的偏移</span><br><span class="line">type：  重定位的类型（常见有R_X86_64_PC32和R_X86_64_32）</span><br><span class="line">symbol：重定位到的符号</span><br><span class="line">addend：需要重定位的地址与下一条指令的相对位置关系</span><br></pre></td></tr></table></figure>
<h4 id="2-重定位算法（伪代码）">2 重定位算法（伪代码）</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">foreach section s &#123;</span><br><span class="line">    foreach relocation entry r &#123;</span><br><span class="line">        refptr = s + r.offset;  <span class="comment">/* ptr to reference to be relocated */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* Relocate a PC-relative reference */</span></span><br><span class="line">        <span class="keyword">if</span> (r.type == R_X86_64_PC32)&#123;</span><br><span class="line">            refaddr = ADDR(s) + r.offset; <span class="comment">/* ref&#x27;s run-time address */</span></span><br><span class="line">            *refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend - refaddr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Relocate an absolute reference */</span></span><br><span class="line">        <span class="keyword">if</span> (r.type == R_X86_64_32)</span><br><span class="line">            *refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>R_X86_64_PC32：重定位一个使用32位PC相对地址的引用，计算方式为：S + A - P<br>
R_X86_64_32：  重定位一个使用32位绝对地址的引用，计算方式为：S + A</p>
<blockquote>
<p>S：符号的实际地址，相当于ADDR(r.symbol)</p>
<p>A：保存在被修正位置的值，相当于r.addend</p>
<p>P：要被修正的位置，相当于ADDR(s) + r.offset</p>
</blockquote>
<h4 id="3-重定位示例">3 重定位示例</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g_test;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="type">int</span> a = g_test;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="type">int</span> g_test = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析出的相关信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[root@<span class="number">192</span> link]<span class="meta"># readelf -r main.o</span></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.text&#x27;</span> at offset <span class="number">0x3c0</span> contains <span class="number">2</span> entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line"><span class="number">00000000000</span>e  <span class="number">000e00000004</span> R_X86_64_PLT32    <span class="number">0000000000000000</span> test - <span class="number">4</span></span><br><span class="line"><span class="number">000000000014</span>  <span class="number">000f</span>00000002 R_X86_64_PC32     <span class="number">0000000000000000</span> g_test - <span class="number">4</span></span><br><span class="line">[root@<span class="number">192</span> link]<span class="meta"># readelf -sW main | grep <span class="string">&quot;GLOBAL&quot;</span> | grep -E <span class="string">&quot;main|test&quot;</span></span></span><br><span class="line">    <span class="number">60</span>: <span class="number">0000000000404028</span>     <span class="number">4</span> OBJECT  GLOBAL DEFAULT   <span class="number">21</span> g_test</span><br><span class="line">    <span class="number">63</span>: <span class="number">000000000040111</span>a    <span class="number">34</span> FUNC    GLOBAL DEFAULT   <span class="number">11</span> main</span><br><span class="line">    <span class="number">67</span>: <span class="number">000000000040113</span>c     <span class="number">7</span> FUNC    GLOBAL DEFAULT   <span class="number">11</span> test</span><br></pre></td></tr></table></figure>
<p>重定位后的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重定位前</span></span><br><span class="line"><span class="number">0000000000000000</span> &lt;main&gt;:</span><br><span class="line">   <span class="number">0</span>:   <span class="number">55</span>                      push   %rbp</span><br><span class="line">   <span class="number">1</span>:   <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">   <span class="number">4</span>:   <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">8</span>:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   d:   e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq  <span class="number">12</span> &lt;main+<span class="number">0x12</span>&gt;</span><br><span class="line">                        e: R_X86_64_PLT32       test<span class="number">-0x4</span></span><br><span class="line">  <span class="number">12</span>:   <span class="number">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x0</span>(%rip),%eax        # <span class="number">18</span> &lt;main+<span class="number">0x18</span>&gt;</span><br><span class="line">                        <span class="number">14</span>: R_X86_64_PC32       g_test<span class="number">-0x4</span></span><br><span class="line">  <span class="number">18</span>:   <span class="number">89</span> <span class="number">45</span> fc                mov    %eax,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">  <span class="number">1b</span>:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">20</span>:   c9                      leaveq</span><br><span class="line">  <span class="number">21</span>:   c3                      retq</span><br><span class="line"><span class="comment">// 重定位后</span></span><br><span class="line"><span class="number">000000000040111</span>a &lt;main&gt;:</span><br><span class="line">  <span class="number">40111</span>a:       <span class="number">55</span>                      push   %rbp</span><br><span class="line">  <span class="number">40111b</span>:       <span class="number">48</span> <span class="number">89</span> e5                mov    %rsp,%rbp</span><br><span class="line">  <span class="number">40111</span>e:       <span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>             sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">  <span class="number">401122</span>:       b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">401127</span>:       e8 <span class="number">10</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          callq  <span class="number">40113</span>c &lt;test&gt;</span><br><span class="line">  <span class="number">40112</span>c:       <span class="number">8b</span> <span class="number">05</span> f6 <span class="number">2</span>e <span class="number">00</span> <span class="number">00</span>       mov    <span class="number">0x2ef6</span>(%rip),%eax        # <span class="number">404028</span> &lt;g_test&gt;</span><br><span class="line">  <span class="number">401132</span>:       <span class="number">89</span> <span class="number">45</span> fc                mov    %eax,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">  <span class="number">401135</span>:       b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">40113</span>a:       c9                      leaveq</span><br><span class="line">  <span class="number">40113b</span>:       c3                      retq</span><br></pre></td></tr></table></figure>
<h4 id="3-1-重定位PC相对引用">3.1 重定位PC相对引用</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">r.offset = <span class="number">0xe</span></span><br><span class="line">r.symbol = test</span><br><span class="line">r.type   = R_X86_64_PLT32</span><br><span class="line">r.addend = <span class="number">-4</span></span><br><span class="line">ADDR(s) = ADDR(main) = <span class="number">0x40111a</span></span><br><span class="line">ADDR(r.symbol) = ADDR(test) = <span class="number">0x40113c</span></span><br><span class="line">refaddr = ADDR(s) + r.offset = <span class="number">0x40111a</span> + <span class="number">0xe</span> = <span class="number">0x401128</span></span><br><span class="line">*refptr = (<span class="type">unsigned</span>) (ADDR(r.symbol) + r.addend - refaddr)</span><br><span class="line">        = (<span class="type">unsigned</span>) (<span class="number">0x40113c</span>       + (<span class="number">-4</span>)     - <span class="number">0x401128</span>)</span><br><span class="line">        = (<span class="type">unsigned</span>) (<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure>
<p>因此重定位被修改成</p>
<p><code>401127:       e8 10 00 00 00          callq  40113c &lt;test&gt;</code></p>
<h4 id="3-2-重定位绝对引用">3.2 重定位绝对引用</h4>
]]></content>
      <categories>
        <category>link</category>
      </categories>
      <tags>
        <tag>link</tag>
      </tags>
  </entry>
  <entry>
    <title>malloc引起三个线程卡死问题</title>
    <url>/zhoukaiqi/1393215fa52d/</url>
    <content><![CDATA[<h5 id="1-背景描述">1.背景描述</h5>
<p>最近参与定位了一个malloc死锁导致的三个线程卡死问题。本文对该问题进行了复盘。</p>
<span id="more"></span>
<h5 id="2-原理介绍">2.原理介绍</h5>
<p>为了构造malloc死锁，需要设置malloc公用同一把锁，导入环境变量<code>export MALLOC_ARENA_MAX=1</code></p>
<ol>
<li>线程 C 第二次调用malloc后异常，产生6信号。在信号处理函数中再次调用malloc构造出malloc锁死锁；</li>
<li>线程 B 先拿了g_Mutex锁，再调用malloc。由于线程 C 已经占了malloc锁，导致线程 B 在等malloc锁过程中卡死；</li>
<li>线程 A 想占用g_Mutex锁。由于线程 B 已经拿了g_Mutex锁，导致线程 A 在等g_Mutex锁过程中卡死。</li>
</ol>
<h5 id="3-具体实现">3.具体实现</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc deadlock.c -lpthread -fno-omit-frame-pointer -m64 -g -o deadlock</span></span><br><span class="line"><span class="comment">// MALLOC_ARENA_MAX=1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> g_Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*SigHandler)</span><span class="params">(<span class="type">int</span> sigNum, <span class="type">siginfo_t</span> *sigInfo, <span class="type">void</span> *context)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SingalHandlerReg</span><span class="params">(<span class="type">int</span> sigNum, SigHandler sigHandler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> sigMask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span>;</span></span><br><span class="line">    (<span class="type">void</span>)sigfillset(&amp;sigMask);</span><br><span class="line">    sig.sa_mask = sigMask;</span><br><span class="line">    sig.sa_flags = SA_SIGINFO;</span><br><span class="line">    sig.sa_sigaction = (<span class="type">void</span> *)sigHandler;</span><br><span class="line">    sigaction(sigNum, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sigHandler</span><span class="params">(<span class="type">int</span> sigNum, <span class="type">siginfo_t</span> *sigInfo, <span class="type">void</span> *context)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// memset(p, 0, 40000);</span></span><br><span class="line">    <span class="comment">// raise(6);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ThreadA</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)arg;</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;ThreadA&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;g_Mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ThreadA is running %d\n&quot;</span>, i);</span><br><span class="line">        pthread_mutex_unlock(&amp;g_Mutex);</span><br><span class="line">        i++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ThreadB</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)arg;</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;ThreadB&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ThreadB is running %d\n&quot;</span>, i);</span><br><span class="line">        pthread_mutex_lock(&amp;g_Mutex);</span><br><span class="line">        <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">20</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;g_Mutex);</span><br><span class="line">        i++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ThreadC</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)arg;</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;ThreadC&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ThreadC is running %d\n&quot;</span>, i);</span><br><span class="line">        <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">20</span>);</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="string">&#x27;c&#x27;</span>, <span class="number">20000</span>);</span><br><span class="line">        <span class="type">int</span> *q = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">20</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1;</span><br><span class="line">    <span class="type">pthread_t</span> tid2;</span><br><span class="line">    <span class="type">pthread_t</span> tid3;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    SingalHandlerReg(<span class="number">6</span>, sigHandler);</span><br><span class="line">    ret = pthread_mutex_init(&amp;g_Mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_mutex_init g_MutexA failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, (<span class="type">void</span> *)ThreadA, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_create failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, (<span class="type">void</span> *)ThreadB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_create failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid3, <span class="literal">NULL</span>, (<span class="type">void</span> *)ThreadC, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_create failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-定位信息">4.定位信息</h5>
<p>现象：线程 A 执行两次后卡死，线程 B 执行两次后卡死，线程 C 执行一次后卡死。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[root@<span class="number">192</span> deadlock]# ./deadlock</span><br><span class="line">ThreadA is running <span class="number">1</span></span><br><span class="line">ThreadB is running <span class="number">1</span></span><br><span class="line">ThreadA is running <span class="number">2</span></span><br><span class="line">ThreadC is running <span class="number">1</span></span><br><span class="line">ThreadB is running <span class="number">2</span></span><br><span class="line"><span class="built_in">malloc</span>(): corrupted top size</span><br></pre></td></tr></table></figure>
<p>查看g_Mutex锁的信息，当前占用g_Mutex锁的是线程LWP 6217，即线程 B</p>
<p><font color="#FF0000"><strong>当三个线程都卡死后，线程 C 间接影响了线程 A 的运行，是一个比较经典的死锁问题。</strong></font></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) i thread 2 3 4</span><br><span class="line">  Id   Target Id                                  Frame</span><br><span class="line">  2    Thread 0x7f39b4738700 (LWP 6216) &quot;ThreadA&quot; __lll_lock_wait ()</span><br><span class="line">  3    Thread 0x7f39b3f37700 (LWP 6217) &quot;ThreadB&quot; __lll_lock_wait_private ()</span><br><span class="line">  4    Thread 0x7f39b3736700 (LWP 6218) &quot;ThreadC&quot; __lll_lock_wait_private ()</span><br><span class="line">(gdb) p *(unsigned int *)((char *)&amp;g_Mutex + 8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 6217</span></span><br><span class="line">(gdb) thread apply all bt</span><br><span class="line"></span><br><span class="line">Thread 4 (Thread 0x7f39b3736700 (LWP 6218)):</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  __lll_lock_wait_private ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007f39b47c1afb <span class="keyword">in</span> __GI___libc_malloc (bytes=80)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x0000000000401312 <span class="keyword">in</span> sigHandler (sigNum=6, sigInfo=0x7f39b37354f0, context=0x7f39b37353c0)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  &lt;signal handler called&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  __GI_raise (sig=sig@entry=6)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x00007f39b4776931 <span class="keyword">in</span> __GI_abort ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  0x00007f39b47b6eb9 <span class="keyword">in</span> __libc_message (action=action@entry=do_abort, <span class="built_in">fmt</span>=<span class="built_in">fmt</span>@entry=0x7f39b48be81d <span class="string">&quot;%s\n&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7  0x00007f39b47bd62a <span class="keyword">in</span> malloc_printerr (str=str@entry=0x7f39b48bcf04 <span class="string">&quot;malloc(): corrupted top size&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8  0x00007f39b47c087a <span class="keyword">in</span> _int_malloc (av=av@entry=0x7f39b48edaa0 &lt;main_arena&gt;, bytes=bytes@entry=80)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9  0x00007f39b47c1b0d <span class="keyword">in</span> __GI___libc_malloc (bytes=80)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">10 0x0000000000401458 <span class="keyword">in</span> ThreadC (arg=0x0)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">11 0x00007f39b48fcf1b <span class="keyword">in</span> start_thread (arg=0x7f39b3736700)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">12 0x00007f39b4834340 <span class="keyword">in</span> <span class="built_in">clone</span> ()</span></span><br><span class="line"></span><br><span class="line">Thread 3 (Thread 0x7f39b3f37700 (LWP 6217)):</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  __lll_lock_wait_private ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007f39b47c1afb <span class="keyword">in</span> __GI___libc_malloc (bytes=80)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00000000004013c7 <span class="keyword">in</span> ThreadB (arg=0x0)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00007f39b48fcf1b <span class="keyword">in</span> start_thread (arg=0x7f39b3f37700)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x00007f39b4834340 <span class="keyword">in</span> <span class="built_in">clone</span> ()</span></span><br><span class="line"></span><br><span class="line">Thread 2 (Thread 0x7f39b4738700 (LWP 6216)):</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  __lll_lock_wait ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007f39b48ff4a1 <span class="keyword">in</span> __GI___pthread_mutex_lock (mutex=0x4040c0 &lt;g_Mutex&gt;)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x000000000040134a <span class="keyword">in</span> ThreadA (arg=0x0)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  0x00007f39b48fcf1b <span class="keyword">in</span> start_thread (arg=0x7f39b4738700)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x00007f39b4834340 <span class="keyword">in</span> <span class="built_in">clone</span> ()</span></span><br></pre></td></tr></table></figure>
<h5 id="5-补充知识">5.补充知识</h5>
<p>如何构造malloc异常</p>
<p>malloc申请一块内存，内存被写越界。如果第二次malloc申请的内存有部分已经被前者写越界，则会抛出6信号SIGABRT异常。</p>
]]></content>
      <categories>
        <category>pthread</category>
      </categories>
      <tags>
        <tag>pthread</tag>
      </tags>
  </entry>
  <entry>
    <title>动态链接</title>
    <url>/zhoukaiqi/20785740b336/</url>
    <content><![CDATA[<p>本文介绍动态链接中的重定位。</p>
<span id="more"></span>
<h4 id="1-为什么要使用动态链接">1 为什么要使用动态链接</h4>
<p>静态链接会导致bin文件很大，浪费内存空间。同时静态链接不利于程序的发布和维护。而动态链接通过共享库so解决了以上两点问题。</p>
<h4 id="2-动态链接遇到的拦路虎">2 动态链接遇到的拦路虎</h4>
<p>比如函数A调用了libb.so中的函数B，编译函数A所在的.c文件时是不知道函数B的地址的，所以call B的地址无法确认。如果后续进行符号重定位，就需要对call B的地址进行修改，但是代码段又没有可写的权限，这是一个矛盾点。需要通过增加一个适配层解决。</p>
<p>由于数据段是可写的，代码段call B的地址可以指向数据段，在数据段中填入函数B的实际地址。</p>
<h4 id="3-PLT表和GOT表">3 PLT表和GOT表</h4>
<p>PLT表：过程链接表(Procedure Linkage Table) 存放额外代码段表</p>
<p>GOT表：全局偏移表(Global Offset Table)	存放函数地址的数据表</p>
<p>call B的地址即用到了PLT表，数据段中存的是GOT表。</p>
<h4 id="4-延迟重定位">4 延迟重定位</h4>
<p>只有动态库函数在被调用时，才会进行地址解析和重定位工作，这时候动态库函数的地址才会被写入到GOT表项中</p>
<h5 id="函数第一次被调用过程">函数第一次被调用过程</h5>
<ul>
<li><img src="https://img1.imgtp.com/2022/08/21/Nx0m5CYg.png" alt=""></li>
</ul>
<p>第一步由函数调用跳入到PLT表中，然后第二步PLT表跳到GOT表中，可以看到第三步由GOT表回跳到PLT表中，这时候进行压栈，把代表函数的ID压栈，接着第四步跳转到公共的PLT表项中，第5步进入到GOT表中，然后_dl_runtime_resolve对动态函数进行地址解析和重定位，第七步把动态函数真实的地址写入到GOT表项中，然后执行函数并返回。</p>
<p>解释下dynamic段，link_map和_dl_runtime_resolve</p>
<p>dynamic段：提供动态链接的信息，例如动态链接中各个表的位置</p>
<p>link_map：已加载库的链表，由动态库函数的地址构成的链表</p>
<p>_dl_runtime_resolve：在第一次运行时进行地址解析和重定位工作</p>
<h5 id="函数非首次被调用过程">函数非首次被调用过程</h5>
<ul>
<li><img src="https://img1.imgtp.com/2022/08/21/rcIbVj3x.png" alt=""></li>
</ul>
<p>可以看到，第一步还是由函数调用跳入到PLT表，但是第二步跳入到GOT表中时，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回。</p>
<h4 id="5-动态链接示例">5 动态链接示例</h4>
<p>b.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc -shared -fPIC b.c -g -o libb.so</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FuncB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;FuncB\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc main.c libb.so -g -o main</span></span><br><span class="line"><span class="comment">// export LD_LIBRARY_PATH=./</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noinline __attribute__((noinline))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">FuncB</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> <span class="title function_">FuncA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FuncB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FuncA();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当main进程还未运行时，查询到的相关跳转信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncA</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncA:</span><br><span class="line">   <span class="number">0x000000000040113a</span> &lt;+<span class="number">0</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x000000000040113b</span> &lt;+<span class="number">1</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x000000000040113e</span> &lt;+<span class="number">4</span>&gt;:     mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x0000000000401143</span> &lt;+<span class="number">9</span>&gt;:     callq  <span class="number">0x401030</span> &lt;FuncB@plt&gt;</span><br><span class="line">   <span class="number">0x0000000000401148</span> &lt;+<span class="number">14</span>&gt;:    nop</span><br><span class="line">   <span class="number">0x0000000000401149</span> &lt;+<span class="number">15</span>&gt;:    pop    %rbp</span><br><span class="line">   <span class="number">0x000000000040114a</span> &lt;+<span class="number">16</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disassemble <span class="number">0x401030</span></span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncB@plt:</span><br><span class="line">   <span class="number">0x0000000000401030</span> &lt;+<span class="number">0</span>&gt;:     jmpq   *<span class="number">0x2fe2</span>(%rip)        # <span class="number">0x404018</span> &lt;FuncB@got.plt&gt;</span><br><span class="line">   <span class="number">0x0000000000401036</span> &lt;+<span class="number">6</span>&gt;:     pushq  $<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x000000000040103b</span> &lt;+<span class="number">11</span>&gt;:    jmpq   <span class="number">0x401020</span></span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) x/wx <span class="number">0x404018</span></span><br><span class="line"><span class="number">0x404018</span> &lt;FuncB@got.plt&gt;:       <span class="number">0x00401036</span></span><br><span class="line">(gdb) x/<span class="number">6</span>i <span class="number">0x401020</span></span><br><span class="line">   <span class="number">0x401020</span>:    pushq  <span class="number">0x2fe2</span>(%rip)        # <span class="number">0x404008</span></span><br><span class="line">   <span class="number">0x401026</span>:    jmpq   *<span class="number">0x2fe4</span>(%rip)        # <span class="number">0x404010</span></span><br><span class="line">   <span class="number">0x40102c</span>:    nopl   <span class="number">0x0</span>(%rax)</span><br><span class="line">   <span class="number">0x401030</span> &lt;FuncB@plt&gt;:        jmpq   *<span class="number">0x2fe2</span>(%rip)        # <span class="number">0x404018</span> &lt;FuncB@got.plt&gt;</span><br><span class="line">   <span class="number">0x401036</span> &lt;FuncB@plt+<span class="number">6</span>&gt;:      pushq  $<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x40103b</span> &lt;FuncB@plt+<span class="number">11</span>&gt;:     jmpq   <span class="number">0x401020</span></span><br><span class="line">(gdb) x/wx <span class="number">0x404010</span></span><br><span class="line"><span class="number">0x404010</span>:       <span class="number">0x00000000</span></span><br></pre></td></tr></table></figure>
<p>当main进程首次运行到FuncA时，0x404010赋了_dl_runtime_resolve_xsavec的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00007ffff7fe1ebd</span> in <span class="title function_">elf_machine_runtime_setup</span> <span class="params">(profile=<span class="number">0</span>, lazy=<span class="number">1</span>, l=<span class="number">0x7ffff7ffe150</span>)</span></span><br><span class="line">#1  _<span class="title function_">dl_relocate_object</span> <span class="params">(scope=<span class="number">0x7ffff7ffe4b0</span>, reloc_mode=&lt;optimized out&gt;, consider_profiling=consider_profiling@entry=<span class="number">0</span>)</span></span><br><span class="line">#2  0x00007ffff7fda25a in <span class="title function_">dl_main</span> <span class="params">()</span></span><br><span class="line">#3  0x00007ffff7fedde0 in _<span class="title function_">dl_sysdep_start</span> <span class="params">()</span></span><br><span class="line">#4  0x00007ffff7fd8191 in _<span class="title function_">dl_start_final</span> <span class="params">(arg=<span class="number">0x7fffffffeae0</span>)</span> at rtld.c:413</span><br><span class="line">#5  _<span class="title function_">dl_start</span> <span class="params">(arg=<span class="number">0x7fffffffeae0</span>)</span> at rtld.c:520</span><br><span class="line">#6  0x00007ffff7fd71c8 in _<span class="title function_">start</span> <span class="params">()</span> from /lib64/ld-linux-x86-64.so.2</span><br><span class="line">#7  0x0000000000000001 in ?? <span class="params">()</span></span><br><span class="line">#8  0x00007fffffffed49 in ?? <span class="params">()</span></span><br><span class="line">#9  0x0000000000000000 in ?? <span class="params">()</span></span><br><span class="line"><span class="params">(gdb)</span> x/2wx 0x404010</span><br><span class="line">0x404010:       0xf7feaba0      0<span class="title function_">x00007fff</span></span><br><span class="line"><span class="params">(gdb)</span> x 0x00007ffff7feaba0</span><br><span class="line">0x7ffff7feaba0 &lt;_dl_runtime_resolve_xsavec&gt;:    0xe3894853</span><br></pre></td></tr></table></figure>
<p>通过_dl_runtime_resolve_xsavec的解析，0x404018被赋入FuncB的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  _dl_fixup (l=&lt;optimized out&gt;, reloc_arg=&lt;optimized out&gt;) at ../elf/dl-runtime.c:<span class="number">149</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00007ffff7feac1a</span> in _dl_runtime_resolve_xsavec () at ../sysdeps/x86_64/dl-trampoline.h:<span class="number">126</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000000000401148</span> in <span class="title function_">FuncA</span> <span class="params">()</span> at main.c:8</span><br><span class="line">#3  0x0000000000401159 in <span class="title function_">main</span> <span class="params">()</span> at main.c:13</span><br><span class="line"><span class="params">(gdb)</span> x/2wx 0x404018</span><br><span class="line">0x404018 &lt;FuncB@got.plt&gt;:       0xf7fcb12a      0<span class="title function_">x00007fff</span></span><br><span class="line"><span class="params">(gdb)</span> x 0x00007ffff7fcb12a</span><br><span class="line">0x7ffff7fcb12a &lt;FuncB&gt;: 0xe5894855</span><br></pre></td></tr></table></figure>
<p>参考案例：<a href="https://www.jianshu.com/p/0ac63c3744dd">https://www.jianshu.com/p/0ac63c3744dd</a></p>
]]></content>
      <categories>
        <category>link</category>
      </categories>
      <tags>
        <tag>link</tag>
      </tags>
  </entry>
  <entry>
    <title>互斥锁</title>
    <url>/zhoukaiqi/5acdf544dc0c/</url>
    <content><![CDATA[<p>本文介绍了互斥锁的使用。</p>
<span id="more"></span>
<h5 id="1-pthread-mutex-t结构体-x86-64位-40字节">1. pthread_mutex_t结构体(x86_64位:40字节)</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">pthread_mutex_s</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> __lock;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __count;</span><br><span class="line">        <span class="type">int</span> __owner;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __nusers;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* KIND must stay at this position in the structure to maintain</span></span><br><span class="line"><span class="comment">           binary compatibility with static initializers.  */</span></span><br><span class="line">        <span class="type">int</span> __kind;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">        <span class="type">short</span> __spins;</span><br><span class="line">        <span class="type">short</span> __elision;</span><br><span class="line">        <span class="type">__pthread_list_t</span> __list;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __PTHREAD_MUTEX_HAVE_PREV      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; __data;</span><br><span class="line">    <span class="type">char</span> __size[__SIZEOF_PTHREAD_MUTEX_T];</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> __align;</span><br><span class="line">&#125; <span class="type">pthread_mutex_t</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>字段</th>
<th>详细说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>__lock</td>
<td>表示mutex的状态，0：未占用   1：占用</td>
</tr>
<tr>
<td>__count</td>
<td>表示锁的次数，用于可重入锁。每次获取锁，值加1；释放锁，值减1</td>
</tr>
<tr>
<td><font color="#FF0000"><strong>__owner</strong></font></td>
<td><font color="#FF0000"><strong>线程的持有者，即线程的LWP，可通过info threads查看</strong></font></td>
</tr>
<tr>
<td>__nusers</td>
<td>使用锁的任务个数，一般情况下为1(被占用)或者0（空闲）</td>
</tr>
<tr>
<td>__kind</td>
<td>mutex的属性</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对于死锁问题，通过<code>__owner</code>找到锁的持有者非常关键。</p>
</blockquote>
<h5 id="2-创建互斥锁">2. 创建互斥锁</h5>
<ul>
<li>
<p>静态创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>动态创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *mutexattr)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-注销互斥锁">3. 注销互斥锁</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span><br></pre></td></tr></table></figure>
<h5 id="4-锁的属性">4. 锁的属性</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PTHREAD_MUTEX_TIMED_NP：</span><br><span class="line">默认值，普通锁。当一个线程加锁以后，其余请求锁的线程形成一个等待队列，并在解锁后按优先级获得锁。</span><br><span class="line"></span><br><span class="line">PTHREAD_MUTEX_RECURSIVE_NP：</span><br><span class="line">可重入锁，允许同一个线程多次P锁和V锁。</span><br><span class="line"></span><br><span class="line">PTHREAD_MUTEX_ERRORCHECK_NP：</span><br><span class="line">检错锁，同一个线程重复请求同一把锁则返回EDEADLK。</span><br><span class="line"></span><br><span class="line">PTHREAD_MUTEX_ADAPTIVE_NP：</span><br><span class="line">自适应锁，自旋锁和普通锁的混合。</span><br></pre></td></tr></table></figure>
<h5 id="5-锁的操作">5. 锁的操作</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span><br></pre></td></tr></table></figure>
<h5 id="6-其他">6. 其他</h5>
<ul>
<li>无论哪种类型的锁，都不可以被两个不同的线程同时持有</li>
<li>普通锁和自适应锁，解锁者可以是同进程内的任何线程</li>
<li>可重入锁，必须由加锁线程解锁</li>
<li>检错锁，必须由加锁线程解锁，否则返回EPERMc</li>
</ul>
<h5 id="7-死锁构造">7. 死锁构造</h5>
<p>测试代码</p>
<p>ThreadA线程拿了A锁等B锁，ThreadB线程拿了B锁等A锁，造成两个线程死锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc deadlock.c -lpthread -fno-omit-frame-pointer -m64 -g -o deadlock</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> g_MutexA;</span><br><span class="line"><span class="type">pthread_mutex_t</span> g_MutexB;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ThreadA</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)arg;</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;ThreadA&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ThreadA is running %d\n&quot;</span>, i);</span><br><span class="line">        pthread_mutex_lock(&amp;g_MutexA);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;g_MutexB);</span><br><span class="line">        pthread_mutex_unlock(&amp;g_MutexB);</span><br><span class="line">        pthread_mutex_unlock(&amp;g_MutexA);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ThreadB</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)arg;</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;ThreadB&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ThreadB is running %d\n&quot;</span>, i);</span><br><span class="line">        pthread_mutex_lock(&amp;g_MutexB);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;g_MutexA);</span><br><span class="line">        pthread_mutex_unlock(&amp;g_MutexA);</span><br><span class="line">        pthread_mutex_unlock(&amp;g_MutexB);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tidA;</span><br><span class="line">    <span class="type">pthread_t</span> tidB;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_mutex_init(&amp;g_MutexA, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_mutex_init g_MutexA failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_mutex_init(&amp;g_MutexB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_mutex_init g_MutexB failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tidA, <span class="literal">NULL</span>, (<span class="type">void</span>*)ThreadA, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_create failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tidB, <span class="literal">NULL</span>, (<span class="type">void</span>*)ThreadB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_create failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost deadlock]# ./deadlock</span><br><span class="line">ThreadA is running 1</span><br><span class="line">ThreadB is running 1</span><br></pre></td></tr></table></figure>
<p>0x1ffa即8186，表示A锁被ThreadA线程持有；0x1ffb即8187，表示B锁被ThreadB线程持有。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[root@localhost deadlock]<span class="comment"># ps -ef | grep deadlock</span></span><br><span class="line">root        <span class="number">8184</span>    <span class="number">7979</span>  <span class="number">0</span> <span class="number">17</span>:<span class="number">32</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ./deadlock</span><br><span class="line">========================================================================</span><br><span class="line"><span class="comment"># 查看锁信息</span></span><br><span class="line">gdb attach `pidof deadlock`</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height <span class="number">0</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> pretty on</span><br><span class="line">i thread <span class="number">2</span> <span class="number">3</span></span><br><span class="line">thread apply <span class="number">2</span> <span class="number">3</span> bt</span><br><span class="line">x/3wx &amp;g_MutexA</span><br><span class="line">x/3wx &amp;g_MutexB</span><br><span class="line">det</span><br><span class="line">q</span><br><span class="line">========================================================================</span><br><span class="line">(gdb) i thread <span class="number">2</span> <span class="number">3</span></span><br><span class="line">  Id   Target Id                                  Frame</span><br><span class="line">  <span class="number">2</span>    Thread <span class="number">0x7f2d57e9f700</span> (LWP <span class="number">8186</span>) <span class="string">&quot;ThreadA&quot;</span> __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:<span class="number">103</span></span><br><span class="line">  <span class="number">3</span>    Thread <span class="number">0x7f2d5769e700</span> (LWP <span class="number">8187</span>) <span class="string">&quot;ThreadB&quot;</span> __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:<span class="number">103</span></span><br><span class="line">(gdb) thread apply <span class="number">2</span> <span class="number">3</span> bt</span><br><span class="line">Thread <span class="number">2</span> (Thread <span class="number">0x7f2d57e9f700</span> (LWP <span class="number">8186</span>)):</span><br><span class="line"><span class="comment">#0  __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:103</span></span><br><span class="line"><span class="comment">#1  0x00007f2d580664a1 in __GI___pthread_mutex_lock (mutex=0x4040a0 &lt;g_MutexB&gt;) at ../nptl/pthread_mutex_lock.c:80</span></span><br><span class="line"><span class="comment">#2  0x0000000000401203 in ThreadA (arg=0x0) at deadlock.c:19</span></span><br><span class="line"><span class="comment">#3  0x00007f2d58063f1b in start_thread (arg=0x7f2d57e9f700) at pthread_create.c:486</span></span><br><span class="line"><span class="comment">#4  0x00007f2d57f9b340 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:98</span></span><br><span class="line">Thread <span class="number">3</span> (Thread <span class="number">0x7f2d5769e700</span> (LWP <span class="number">8187</span>)):</span><br><span class="line"><span class="comment">#0  __lll_lock_wait () at ../sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:103</span></span><br><span class="line"><span class="comment">#1  0x00007f2d580664a1 in __GI___pthread_mutex_lock (mutex=0x4040e0 &lt;g_MutexA&gt;) at ../nptl/pthread_mutex_lock.c:80</span></span><br><span class="line"><span class="comment">#2  0x0000000000401276 in ThreadB (arg=0x0) at deadlock.c:35</span></span><br><span class="line"><span class="comment">#3  0x00007f2d58063f1b in start_thread (arg=0x7f2d5769e700) at pthread_create.c:486</span></span><br><span class="line"><span class="comment">#4  0x00007f2d57f9b340 in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:98</span></span><br><span class="line">(gdb) x/3wx &amp;g_MutexA</span><br><span class="line"><span class="number">0x4040e0</span> &lt;g_MutexA&gt;:    <span class="number">0x00000002</span>      <span class="number">0x00000000</span>      <span class="number">0x00001ffa</span></span><br><span class="line">(gdb) x/3wx &amp;g_MutexB</span><br><span class="line"><span class="number">0x4040a0</span> &lt;g_MutexB&gt;:    <span class="number">0x00000002</span>      <span class="number">0x00000000</span>      <span class="number">0x00001ffb</span></span><br><span class="line">(gdb) p *(pthread_mutex_t *)&amp;g_MutexA</span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  __data = &#123;</span><br><span class="line">    __lock = <span class="number">2</span>,</span><br><span class="line">    __count = <span class="number">0</span>,</span><br><span class="line">    __owner = <span class="number">8186</span>,</span><br><span class="line">    __nusers = <span class="number">1</span>,</span><br><span class="line">    __kind = <span class="number">0</span>,</span><br><span class="line">    __spins = <span class="number">0</span>,</span><br><span class="line">    __elision = <span class="number">0</span>,</span><br><span class="line">    __<span class="built_in">list</span> = &#123;</span><br><span class="line">      __prev = <span class="number">0x0</span>,</span><br><span class="line">      __<span class="built_in">next</span> = <span class="number">0x0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  __size = <span class="string">&quot;\002\000\000\000\000\000\000\000\372\037\000\000\001&quot;</span>, <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">26</span> times&gt;,</span><br><span class="line">  __align = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pthread</category>
      </categories>
      <tags>
        <tag>pthread</tag>
      </tags>
  </entry>
  <entry>
    <title>movaps指令引起的复位</title>
    <url>/zhoukaiqi/82d7b7baa849/</url>
    <content><![CDATA[<p>最近定位了一个bolt优化导致进程异常复位的问题。disassemble复位函数发现是运行到movaps指令时挂了。movaps是SSE指令，要求访问的地址是16字节对齐的。由于bolt优化多开了一层8字节的栈，后续的rbp非16字节对齐。当movaps访问非16字节对齐的rbp时，指令异常，进程复位。</p>
<span id="more"></span>
<p>这里忽略bolt优化，只用汇编模拟movaps指令异常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;movaps 0x04(%rdx), %xmm0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x0000000008001129</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x000000000800112d</span> &lt;+<span class="number">4</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x000000000800112e</span> &lt;+<span class="number">5</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000008001131</span> &lt;+<span class="number">8</span>&gt;:     movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">=&gt; <span class="number">0x0000000008001138</span> &lt;+<span class="number">15</span>&gt;:    movaps <span class="number">0x4</span>(%rdx),%xmm0</span><br><span class="line">   <span class="number">0x000000000800113c</span> &lt;+<span class="number">19</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x0000000008001141</span> &lt;+<span class="number">24</span>&gt;:    pop    %rbp</span><br><span class="line">   <span class="number">0x0000000008001142</span> &lt;+<span class="number">25</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) i r rdx</span><br><span class="line">rdx            <span class="number">0x7ffffffee168</span>      <span class="number">140737488281960</span></span><br></pre></td></tr></table></figure>
<p>rdx寄存器是0x7ffffffee168， 0x7ffffffee168+0x4=0x7ffffffee16c不是16字节对齐，所以会出现段错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">main () at demo.c:<span class="number">4</span></span><br><span class="line"><span class="number">4</span>           __asm__ __volatile__ (<span class="string">&quot;movaps 0x04(%rdx), %xmm0&quot;</span>);</span><br><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x0000000008001129</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x000000000800112d</span> &lt;+<span class="number">4</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x000000000800112e</span> &lt;+<span class="number">5</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000008001131</span> &lt;+<span class="number">8</span>&gt;:     movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">=&gt; <span class="number">0x0000000008001138</span> &lt;+<span class="number">15</span>&gt;:    movaps <span class="number">0x4</span>(%rdx),%xmm0</span><br><span class="line">   <span class="number">0x000000000800113c</span> &lt;+<span class="number">19</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x0000000008001141</span> &lt;+<span class="number">24</span>&gt;:    pop    %rbp</span><br><span class="line">   <span class="number">0x0000000008001142</span> &lt;+<span class="number">25</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>如果给rdx寄存器减去12字节，使得rdx+4是16字节对齐的，则能正常执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x0000000008001129</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x000000000800112d</span> &lt;+<span class="number">4</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x000000000800112e</span> &lt;+<span class="number">5</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000008001131</span> &lt;+<span class="number">8</span>&gt;:     movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">=&gt; <span class="number">0x0000000008001138</span> &lt;+<span class="number">15</span>&gt;:    movaps <span class="number">0x4</span>(%rdx),%xmm0</span><br><span class="line">   <span class="number">0x000000000800113c</span> &lt;+<span class="number">19</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x0000000008001141</span> &lt;+<span class="number">24</span>&gt;:    pop    %rbp</span><br><span class="line">   <span class="number">0x0000000008001142</span> &lt;+<span class="number">25</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) i r $rdx</span><br><span class="line">rdx            <span class="number">0x7ffffffee168</span>      <span class="number">140737488281960</span></span><br><span class="line">(gdb) <span class="built_in">set</span> $rdx = $rdx - <span class="number">12</span></span><br><span class="line">(gdb) i r $rdx</span><br><span class="line">rdx            <span class="number">0x7ffffffee15c</span>      <span class="number">140737488281948</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">396</span>) exited normally]</span><br></pre></td></tr></table></figure>
<p>补充：movups	<code>u表示不必16字节对齐，替换成a表示必须16字节对齐。</code></p>
<p>参考：<a href="https://blog.csdn.net/u010659887/article/details/113802005">https://blog.csdn.net/u010659887/article/details/113802005</a></p>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>条件变量</title>
    <url>/zhoukaiqi/f75200d4167d/</url>
    <content><![CDATA[<p>本文介绍了条件变量。</p>
<span id="more"></span>
<h5 id="1-什么是条件变量">1. 什么是条件变量</h5>
<p>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括以下两个动作：</p>
<ul>
<li>
<p>一个线程等待”条件变量的条件成立“而被阻塞；</p>
</li>
<li>
<p>另一个线程”使条件成立“来唤醒被阻塞的线程。</p>
</li>
</ul>
<p>为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 48字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SIZEOF_PTHREAD_COND_T 48</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">int</span> __lock;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __futex;</span><br><span class="line">        __externsion__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> __total_seq;</span><br><span class="line">        __externsion__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> __wakeup_seq;</span><br><span class="line">        __externsion__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> __woken_seq;</span><br><span class="line">        <span class="type">void</span> *__mutex;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __nwaiters;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __broadcast_seq;</span><br><span class="line">    &#125; __data;</span><br><span class="line">    <span class="type">char</span> __size[__SIZEOF_PTHREAD_COND_T];</span><br><span class="line">    __externsion__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> __align;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-如何创建条件变量">2. 如何创建条件变量</h5>
<ul>
<li>
<p>静态创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>动态创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_condattr_t</span> *cond_attr)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-注销条件变量">3. 注销条件变量</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destory</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span><br></pre></td></tr></table></figure>
<h5 id="4-条件等待与触发">4. 条件等待与触发</h5>
<p>以下API必须和互斥锁配合，mutex互斥锁必须是普通锁或者自适应锁，且在调用pthread_cond_wait前必须由本线程加锁。</p>
<ul>
<li>
<p>等待</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无条件等待</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span></span><br><span class="line"><span class="comment">// 计时等待,在给定的时间前条件没有满足，则返回ETIMEOUT。abstime = 0表示格林尼治时间1970年1月1日0时0分0秒</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timewait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *abstime)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>触发</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *__cond)</span></span><br><span class="line"><span class="comment">// 激活所有等待线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *__cond)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="5-pthread-cond-wait的实现细节">5. pthread_cond_wait的实现细节</h5>
<ol>
<li>条件不满足时，才会进入pthread_cond_wait</li>
<li>进入pthread_cond_wait先解锁就马上阻塞</li>
<li>pthread_cond_signal唤醒的是阻塞在pthread_cond_wait的进程</li>
</ol>
<p><img src="https://img1.imgtp.com/2022/07/24/2Eujsx0X.png" alt="20190506080943669.png"></p>
<p>以下pthread_cond_wait和pthread_cond_signal的通常用法的伪代码(条件为：value是不是大于0)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lock(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span>(value&lt;=<span class="number">0</span>)<span class="comment">//需要value&gt;0所以 value&lt;=0就条件不满足</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lock(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span>(value==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(value&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	pthread_cond_signal(&amp;cond);</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p><strong>传入前锁mutex</strong></p>
<p>传入前锁mutex是为了保证线程从条件判断到进入pthread_cond_wait前，条件不被改变。</p>
<p>如果没有传入前的锁。就会有这样的情况：线程A判断条件不满足之后，调用pthread_cond_wait之前，A因为休眠，或者因为多线程下，多个线程执行顺序和快慢的因素，令线程B更改了条件，使得条件满足。但此时线程A还没有调用pthread_cond_wait。等到线程A又启动调用pthread_cond_wait后虽然条件满足，但却收不到pthread_cond_signal的唤醒，就一直阻塞下去。</p>
<p><strong>传入后解锁mutex</strong></p>
<p>传入后解锁是为了条件能够被改变</p>
<p>传入后的解锁，是因为调用pthread_cond_signal的那部分，需要先加锁更改条件后才调用pthread_cond_signal。（更改条件与等待条件满足，都是针对条件这一个资源的竞争，所以调用pthread_cond_wait和调用pthread_cond_signal的两个线程需要同一把锁）</p>
<p>如果pthread_cond_wait内不对mutex解锁，那么在调用pthread_cond_wait后，其他线程就不能更改条件，条件就会一直不满足。</p>
<p><strong>返回前再次锁mutex</strong></p>
<ol>
<li>
<p>返回前再次锁mutex是为了保证线程从pthread_cond_wait返回后 到 再次条件判断前不被改变。</p>
</li>
<li>
<p>保证 在pthread_cond_signal之后与解锁mutex之间可能需要的其他语句能够执行</p>
<p>对于1，这里的理由与传入pthread_cond_wait前锁mutex的理由差不多。如果不锁，那么线程A调用pthread_cond_wait后，条件满足，线程A被唤醒，从pthread_cond_wait返回。线程B在此时更改了条件，使得条件不满足。线程A并不知道条件又被更改，还是以为条件满足，就可能出错。</p>
<p>对于2，只要在pthread_cond_signal之后与解锁mutex之间有其他语句需要执行，那么由于mutex在这时已经被这个线程锁，还没有解锁，所以调用pthread_cond_wait的那个线程在pthread_cond_wait返回前的锁mutex的行为就会阻塞，直到pthread_cond_signal后的语句执行完解锁，pthread_cond_wait才会返回。</p>
</li>
</ol>
<p>参考案例：<a href="https://blog.csdn.net/shichao1470/article/details/89856443?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1-89856443-blog-110194067.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1-89856443-blog-110194067.pc_relevant_vip_default&amp;utm_relevant_index=2">https://blog.csdn.net/shichao1470/article/details/89856443?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1-89856443-blog-110194067.pc_relevant_vip_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1-89856443-blog-110194067.pc_relevant_vip_default&amp;utm_relevant_index=2</a></p>
]]></content>
      <categories>
        <category>pthread</category>
      </categories>
      <tags>
        <tag>pthread</tag>
      </tags>
  </entry>
  <entry>
    <title>栈保护canary机制与__stack_chk_fail</title>
    <url>/zhoukaiqi/b0bd912f2458/</url>
    <content><![CDATA[<h5 id="栈保护canary机制">栈保护canary机制</h5>
<p>canary机制原理：在函数被调用之后，立即在栈帧中插入一个随机数，函数执行完在返回之前，检查这个随机数是否改变来判断是否存在栈溢出。</p>
<span id="more"></span>
<h5 id="构造-stack-chk-fail">构造__stack_chk_fail</h5>
<p>以demo.c为例，编译命令<code>gcc demo.c -fstack-protector -fno-omit-frame-pointer -fPIC -g -o demo</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FuncDemo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x900C</span>;</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="string">&#x27;c&#x27;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">100</span>); <span class="comment">// 踩栈</span></span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FuncDemo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整汇编</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncDemo</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncDemo:</span><br><span class="line">   0x0000aaaaaaaaa884 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">   0x0000aaaaaaaaa888 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">   0x0000aaaaaaaaa88c &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa890 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa894 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">   0x0000aaaaaaaaa898 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa89c &lt;+24&gt;:    mov     x1, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa8a0 &lt;+28&gt;:    mov     w0, <span class="comment">#0x900c                     // #36876</span></span><br><span class="line">   0x0000aaaaaaaaa8a4 &lt;+32&gt;:    str     w0, [x29, <span class="comment">#28]</span></span><br><span class="line">   0x0000aaaaaaaaa8a8 &lt;+36&gt;:    mov     x0, <span class="comment">#0x8                        // #8</span></span><br><span class="line">   0x0000aaaaaaaaa8ac &lt;+40&gt;:    bl      0xaaaaaaaaa710 &lt;malloc@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa8b0 &lt;+44&gt;:    str     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa8b4 &lt;+48&gt;:    adrp    x0, 0xaaaaaaaaa000</span><br><span class="line">   0x0000aaaaaaaaa8b8 &lt;+52&gt;:    add     x1, x0, <span class="comment">#0x9f0</span></span><br><span class="line">   0x0000aaaaaaaaa8bc &lt;+56&gt;:    add     x0, x29, <span class="comment">#0x50</span></span><br><span class="line">   0x0000aaaaaaaaa8c0 &lt;+60&gt;:    ldr     x2, [x1]</span><br><span class="line">   0x0000aaaaaaaaa8c4 &lt;+64&gt;:    str     x2, [x0]</span><br><span class="line">   0x0000aaaaaaaaa8c8 &lt;+68&gt;:    ldur    x1, [x1, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa8cc &lt;+72&gt;:    stur    x1, [x0, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa8d0 &lt;+76&gt;:    stur    wzr, [x29, <span class="comment">#93]</span></span><br><span class="line">   0x0000aaaaaaaaa8d4 &lt;+80&gt;:    sturh   wzr, [x29, <span class="comment">#97]</span></span><br><span class="line">   0x0000aaaaaaaaa8d8 &lt;+84&gt;:    strb    wzr, [x29, <span class="comment">#99]</span></span><br><span class="line">   0x0000aaaaaaaaa8dc &lt;+88&gt;:    stp     xzr, xzr, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa8e0 &lt;+92&gt;:    stp     xzr, xzr, [x29, <span class="comment">#56]</span></span><br><span class="line">   0x0000aaaaaaaaa8e4 &lt;+96&gt;:    str     xzr, [x29, <span class="comment">#72]</span></span><br><span class="line">   0x0000aaaaaaaaa8e8 &lt;+100&gt;:   mov     w0, <span class="comment">#0x1                        // #1</span></span><br><span class="line">   0x0000aaaaaaaaa8ec &lt;+104&gt;:   str     w0, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa8f0 &lt;+108&gt;:   add     x0, x29, <span class="comment">#0x28</span></span><br><span class="line">   0x0000aaaaaaaaa8f4 &lt;+112&gt;:   mov     x2, <span class="comment">#0x64                       // #100</span></span><br><span class="line">   0x0000aaaaaaaaa8f8 &lt;+116&gt;:   mov     w1, <span class="comment">#0x63                       // #99</span></span><br><span class="line">   0x0000aaaaaaaaa8fc &lt;+120&gt;:   bl      0xaaaaaaaaa730 &lt;memset@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa900 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa904 &lt;+128&gt;:   bl      0xaaaaaaaaa770 &lt;free@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa908 &lt;+132&gt;:   str     xzr, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa90c &lt;+136&gt;:   mov     w0, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa910 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa914 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa918 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa91c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">   0x0000aaaaaaaaa920 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">   0x0000aaaaaaaaa924 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">   0x0000aaaaaaaaa928 &lt;+164&gt;:   b.eq    0xaaaaaaaaa930 &lt;FuncDemo+172&gt;  // b.none</span><br><span class="line">   0x0000aaaaaaaaa92c &lt;+168&gt;:   bl      0xaaaaaaaaa740 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa930 &lt;+172&gt;:   ldp     x29, x30, [sp], <span class="comment">#112</span></span><br><span class="line">   0x0000aaaaaaaaa934 &lt;+176&gt;:   ret</span><br></pre></td></tr></table></figure>
<h6 id="1-先通过反汇编找到canary在栈上的存放地址">1. 先通过反汇编找到canary在栈上的存放地址</h6>
<p>canary的值是<code>0x4c597894f2014f00</code>，存入sp + 104的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncDemo</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncDemo:</span><br><span class="line">   0x0000aaaaaaaaa884 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">   0x0000aaaaaaaaa888 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">   0x0000aaaaaaaaa88c &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa890 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa894 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">   0x0000aaaaaaaaa898 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">(gdb) i r x0 x1</span><br><span class="line">x0             0xfffff7ffd7a8   281474842482600</span><br><span class="line">x1             0x4c597894f2014f00       5501561000920436480</span><br><span class="line">(gdb) x/2wx <span class="variable">$x0</span></span><br><span class="line">0xfffff7ffd7a8 &lt;__stack_chk_guard&gt;:     0xf2014f00      0x4c597894</span><br><span class="line">(gdb) x/2wx <span class="variable">$sp</span> + 104</span><br><span class="line">0xfffffffffa38: 0xf2014f00      0x4c597894</span><br></pre></td></tr></table></figure>
<h6 id="2-执行完代码第7行">2. 执行完代码第7行</h6>
<p>memset越界，将栈中保存的canary值踩成了’c’</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   0x0000aaaaaaaaa8fc &lt;+120&gt;:   bl      0xaaaaaaaaa730 &lt;memset@plt&gt;</span><br><span class="line">=&gt; 0x0000aaaaaaaaa900 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">(gdb) x/2wx <span class="variable">$sp</span> + 104</span><br><span class="line">0xfffffffffa38: 0x63636363      0x63636363</span><br></pre></td></tr></table></figure>
<h6 id="3-继续执行">3. 继续执行</h6>
<p>从栈中取出保存的canary值与原来的canary值比较，不相等则说明有踩栈，跳转到__stack_chk_fail并抛出异常信号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   0x0000aaaaaaaaa910 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa914 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa918 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa91c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">   0x0000aaaaaaaaa920 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">   0x0000aaaaaaaaa924 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">   0x0000aaaaaaaaa928 &lt;+164&gt;:   b.eq    0xaaaaaaaaa930 &lt;FuncDemo+172&gt;  // b.none</span><br><span class="line">   0x0000aaaaaaaaa92c &lt;+168&gt;:   bl      0xaaaaaaaaa740 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Program received signal SIGABRT, Aborted.</span><br><span class="line">__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51</span><br><span class="line">51      ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51</span></span><br><span class="line"><span class="comment">#1  0x0000fffff7eaa974 in __GI_abort () at abort.c:79</span></span><br><span class="line"><span class="comment">#2  0x0000fffff7ee372c in __libc_message (action=do_abort,</span></span><br><span class="line">    <span class="built_in">fmt</span>=<span class="built_in">fmt</span>@entry=0xfffff7fa3350 <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>)</span><br><span class="line">    at ../sysdeps/posix/libc_fatal.c:181</span><br><span class="line"><span class="comment">#3  0x0000fffff7f583c4 in __GI___fortify_fail_abort (</span></span><br><span class="line">    need_backtrace=need_backtrace@entry=<span class="literal">false</span>,</span><br><span class="line">    msg=msg@entry=0xfffff7fa3328 <span class="string">&quot;stack smashing detected&quot;</span>)</span><br><span class="line">    at fortify_fail.c:33</span><br><span class="line"><span class="comment">#4  0x0000fffff7f58378 in __stack_chk_fail () at stack_chk_fail.c:29</span></span><br><span class="line"><span class="comment">#5  0x0000aaaaaaaaa930 in FuncDemo () at demo.c:15</span></span><br><span class="line"><span class="comment">#6  0x0000aaaaaaaaa944 in main () at demo.c:19</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>线程爆栈引起的复位</title>
    <url>/zhoukaiqi/761b5f08fe29/</url>
    <content><![CDATA[<p>近期遇到了多次线程爆栈问题，即线程栈的设置太小，被调用函数开栈到了另一个段空间，另一个段不可读写引起了异常。</p>
<span id="more"></span>
<p>下面构造了一个线程爆栈。线程的栈大小是16k，线程内的函数定义了多个局部大数组，会超过16k。</p>
<blockquote>
<p>pthread_attr_setstacksize传入的线程栈大小要大于等于PTHREAD_STACK_MIN，glibc在x86和arm上定义的PTHREAD_STACK_MIN不一样，x86是16k，arm是128k。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 16384</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FuncB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2000</span>] = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FuncA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2000</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    FuncB();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ThreadWork</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FuncA();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_attr_init failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_attr_setstacksize(&amp;attr, STACK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_attr_setstacksize failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid, &amp;attr, (<span class="type">void</span> *)ThreadWork, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_create failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<code>gcc pthread.c -lpthread -g -mmanual-endbr -o pthread</code></p>
<p>异常复位的指令是<code>orq    $0x0,(%rsp)</code>，查询rbp、rsp的值分别是0x7fffff571f70和0x7fffff570f70</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Thread <span class="number">2</span> <span class="string">&quot;pthread&quot;</span> received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[Switching to Thread <span class="number">0x7fffff574700</span> (LWP <span class="number">221</span>)]</span><br><span class="line"><span class="number">0x00000000080011f4</span> in <span class="title function_">FuncB</span> <span class="params">()</span> at pthread.c:9</span><br><span class="line">9       &#123;</span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00000000080011f4</span> in <span class="title function_">FuncB</span> <span class="params">()</span> at pthread.c:9</span><br><span class="line">#1  0x0000000008001298 in <span class="title function_">FuncA</span> <span class="params">()</span> at pthread.c:17</span><br><span class="line">#2  0x00000000080012c5 in <span class="title function_">ThreadWork</span> <span class="params">(arg=<span class="number">0x0</span>)</span> at pthread.c:25</span><br><span class="line">#3  0x00007fffff795609 in <span class="title function_">start_thread</span> <span class="params">(arg=&lt;optimized out&gt;)</span> at pthread_create.c:477</span><br><span class="line">#4  0x00007fffff6af133 in <span class="title function_">clone</span> <span class="params">()</span> at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span><br><span class="line"><span class="params">(gdb)</span> x/10i FuncB</span><br><span class="line">   0x80011e9 &lt;FuncB&gt;:   push   %rbp</span><br><span class="line">   0x80011ea &lt;FuncB+1&gt;: mov    %rsp,%rbp</span><br><span class="line">   0x80011ed &lt;FuncB+4&gt;: sub    $0x1000,%rsp</span><br><span class="line">=&gt; <span class="number">0x80011f4</span> &lt;FuncB+<span class="number">11</span>&gt;:        orq    $<span class="number">0x0</span>,(%rsp)</span><br><span class="line">   <span class="number">0x80011f9</span> &lt;FuncB+<span class="number">16</span>&gt;:        sub    $<span class="number">0xf50</span>,%rsp</span><br><span class="line">   <span class="number">0x8001200</span> &lt;FuncB+<span class="number">23</span>&gt;:        mov    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">   <span class="number">0x8001209</span> &lt;FuncB+<span class="number">32</span>&gt;:        mov    %rax,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">   <span class="number">0x800120d</span> &lt;FuncB+<span class="number">36</span>&gt;:        xor    %eax,%eax</span><br><span class="line">   <span class="number">0x800120f</span> &lt;FuncB+<span class="number">38</span>&gt;:        lea    <span class="number">-0x1f50</span>(%rbp),%rdx</span><br><span class="line">   <span class="number">0x8001216</span> &lt;FuncB+<span class="number">45</span>&gt;:        mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">(gdb) i r rbp rsp</span><br><span class="line">rbp            <span class="number">0x7fffff571f70</span>      <span class="number">0x7fffff571f70</span></span><br><span class="line">rsp            <span class="number">0x7fffff570f70</span>      <span class="number">0x7fffff570f70</span></span><br></pre></td></tr></table></figure>
<p>查看maps表，rbp所在的段可读可写，但rsp(即rbp-0x1000)所在的段不可读写，所以会异常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) shell cat /proc/<span class="number">217</span>/maps | grep <span class="number">7f</span>ffff57</span><br><span class="line"><span class="number">7f</span>ffff570000<span class="number">-7f</span>ffff571000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>ffff571000<span class="number">-7f</span>ffff575000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pthread</category>
      </categories>
      <tags>
        <tag>pthread</tag>
      </tags>
  </entry>
  <entry>
    <title>线程调度策略和调度优先级</title>
    <url>/zhoukaiqi/555d8fcae18d/</url>
    <content><![CDATA[<p>本文介绍了线程的调度策略和调度优先级。</p>
<span id="more"></span>
<h5 id="1-概括介绍">1 概括介绍</h5>
<p>linux的调度机制由调度策略(policy)和调度优先级(priority)两个属性共同决定。调度策略分为实时调度策略和非实时调度策略。实时调度策略的优先级取值范围是<code>1~99</code>，并且数值越大，优先级越高。非实时调度策略的优先级固定是0。实时调度策略的优先级总是大于非实时调度策略。而优先级高的线程总是会被优先调度。</p>
<p>实时调度策略：SCHED_FIFO(抢占)，SCHED_RR(轮询)</p>
<p>非实时调度策略：SCHED_OTHER(默认调度策略)</p>
<h5 id="2-调度策略详细介绍">2 调度策略详细介绍</h5>
<h6 id="SCHED-RR：Round-robin-scheduling">SCHED_RR：Round-robin scheduling</h6>
<p>当线程的优先级不同时，高优先级的线程先调度。当优先级相同时，按照固定的时间片循环调度。被调用的线程满足以下条件会让出CPU：</p>
<ul>
<li>调度的时间片用完，线程被放在同一优先级队列的队尾；</li>
<li>自动放弃CPU，如调用阻塞接口(eg:sleep, select)或者调用sched_yield，线程被放在同一优先级队列的队尾；</li>
<li>被更高优先级的线程抢占，线程被放在同一优先级队列的队首；</li>
<li>线程退出</li>
</ul>
<h6 id="SCHED-FIFO：First-in-first-out-scheduling">SCHED_FIFO：First in-first out scheduling</h6>
<p>与SCHED_RR的调度策略相似，没有时间片概念，线程一旦运行会一直占用CPU。让出CPU的条件也与SCHED_RR类似，但没有时间片用完此情况。</p>
<h6 id="SCHED-OTHER：time-sharing-scheduling">SCHED_OTHER：time-sharing scheduling</h6>
<p>分时循环调度策略。也就是我们常说的CFS(Completely Fair Scheduler)完全公平调度器。是系统的默认调度策略。按动态时间片循环调度。动态时间片由nice属性值决定。每个SCHED_OTHER策略的线程都拥有一个nice值，其取值范围为−20～19，默认值为0。nice值是一个权重因子，值越小，权重越大。CPU为其分配的动态时间片会越多。</p>
<h5 id="3-相关函数">3 相关函数</h5>
<p>pthread_attr_setinheritsched   设置线程是否继承父线程的调度策略</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setinheritsched</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> inheritsched)</span></span><br><span class="line">inheritsched：是否继承父线程的调度策略</span><br><span class="line">PTHREAD_EXPLICIT_SCHED：不继承，只有不继承父线程的调度策略才可以设置线程的调度策略</span><br><span class="line">PTHREAD_INHERIT_SCHED：继承父线程的调度策略，默认值</span><br></pre></td></tr></table></figure>
<p>pthread_attr_setschedpolicy    设置线程的调度策略</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setschedpolicy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> policy)</span></span><br><span class="line">policy: 调度策略</span><br><span class="line">SCHED_OTHER</span><br><span class="line">SCHED_FIFO</span><br><span class="line">SCHED_RR</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_OTHER   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_FIFO    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_RR      2</span></span><br></pre></td></tr></table></figure>
<p>pthread_attr_setschedparam     设置线程的优先级</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setschedparam</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span></span><br><span class="line"><span class="keyword">struct</span> sched_param &#123;</span><br><span class="line">    <span class="type">int</span> sched_priority;</span><br><span class="line">&#125;</span><br><span class="line">备注：只能设置还没有创建的线程</span><br></pre></td></tr></table></figure>
<p>pthread_setschedparam          设置线程的优先级</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_setschedparam</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> policy, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_getschedparam</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">int</span> *policy, <span class="keyword">struct</span> sched_param *param)</span></span><br><span class="line">备注：只能设置已经存在的线程</span><br></pre></td></tr></table></figure>
<h5 id="4-编程实例">4 编程实例</h5>
<p>使用pthread_attr_setinheritsched，pthread_attr_setschedpolicy，pthread_attr_setschedparam</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc test1.c -lpthread -g -o test1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ThreadTest</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)arg;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> policy;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;ThreadTest&quot;</span>);</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    ret = pthread_getschedparam(tid, &amp;policy, &amp;param);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span> &amp;&amp; policy == SCHED_RR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ThreadTest(0x%lx) policy is SCHED_RR, priority is %d\n&quot;</span>, tid, param.sched_priority);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line">    ret = pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_attr_init failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_attr_setinheritsched(&amp;attr, PTHREAD_EXPLICIT_SCHED);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_attr_setinheritsched failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_attr_setschedpolicy(&amp;attr, SCHED_RR);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_attr_setschedpolicy failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    param.sched_priority = <span class="number">40</span>;</span><br><span class="line">    ret = pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_attr_setschedparam failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid, &amp;attr, (<span class="type">void</span> *)ThreadTest, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">./test1</span><br><span class="line"><span class="title function_">ThreadTest</span><span class="params">(<span class="number">0x7f91d744e700</span>)</span> policy is SCHED_RR, priority is 40</span><br></pre></td></tr></table></figure>
<p>使用pthread_setschedparam</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc test2.c -lpthread -g -o test2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ThreadTest</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)arg;</span><br><span class="line">    <span class="type">int</span> policy;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span>;</span></span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;ThreadTest&quot;</span>);</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    (<span class="type">void</span>)pthread_getschedparam(tid, &amp;policy, &amp;param);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before set schedparam, ThreadTest(0x%lx) policy is %d, priority is %d\n&quot;</span>, tid, policy, param.sched_priority);</span><br><span class="line">    param.sched_priority = <span class="number">40</span>;</span><br><span class="line">    (<span class="type">void</span>)pthread_setschedparam(tid, SCHED_FIFO, &amp;param);</span><br><span class="line">    (<span class="type">void</span>)pthread_getschedparam(tid, &amp;policy, &amp;param);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; After set schedparam, ThreadTest(0x%lx) policy is %d, priority is %d\n&quot;</span>, tid, policy, param.sched_priority);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, (<span class="type">void</span> *)ThreadTest, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">./test2</span><br><span class="line">Before <span class="built_in">set</span> schedparam, ThreadTest(<span class="number">0x7feb0453e700</span>) policy is <span class="number">0</span>, priority is <span class="number">0</span></span><br><span class="line"> After <span class="built_in">set</span> schedparam, ThreadTest(<span class="number">0x7feb0453e700</span>) policy is <span class="number">1</span>, priority is <span class="number">40</span></span><br></pre></td></tr></table></figure>
<h5 id="5-相关命令">5 相关命令</h5>
<ul>
<li>查询调度策略：chrt -p pid</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chrt -p 7</span><br><span class="line">pid 7&#x27;s current scheduling policy: SCHED_OTHER</span><br><span class="line">pid 7&#x27;s current scheduling priority: 0</span><br></pre></td></tr></table></figure>
<ul>
<li>查询绑核信息：taskset -cp pid</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">taskset -cp 7</span><br><span class="line">pid 7&#x27;s current affinity list: 0-7</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pthread</category>
      </categories>
      <tags>
        <tag>pthread</tag>
      </tags>
  </entry>
  <entry>
    <title>x86_64推栈原理与实现1</title>
    <url>/zhoukaiqi/e578d0eceb35/</url>
    <content><![CDATA[<p>本文介绍了x86_64推栈原理和具体代码实现。</p>
<span id="more"></span>
<h4 id="推栈原理">推栈原理</h4>
<p>x86_64的rbp推栈需要添加编译选项<code>-fno-omit-frame-pointer</code>，否则rbp不作为栈帧寄存器使用，无法正确推栈。</p>
<p><img src="https://s1.daohangmao.net/2022/06/26/62b7cdf3eb89f.png" alt=""></p>
<p>开栈（从高地址到低地址）：当函数A callq 函数B时，会先将函数A的下一条指令存入rsp(即后续返回到A函数的地址)。而调用到函数B后，会将函数A的寄存器rbp存入rsp并且将rsp赋值给rbp。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// callq addr的具体实现</span><br><span class="line">rsp = rsp - 8</span><br><span class="line">*(unsigned long*)rsp = rip + sizeof(inst)</span><br><span class="line">rip = addr</span><br><span class="line"></span><br><span class="line">// push rbp的具体实现</span><br><span class="line">rsp = rsp - 8</span><br><span class="line">*(unsigned long*)rsp = rbp</span><br><span class="line"></span><br><span class="line">// 函数的入口指令</span><br><span class="line">(gdb) disassemble FuncC</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncC:</span><br><span class="line">   0x000055555555471a &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x000055555555471b &lt;+1&gt;:     mov    %rsp,%rbp</span><br></pre></td></tr></table></figure>
<p>推栈（从低地址到高地址）：根据上述的压栈规则，可以得到推栈公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">preRbp = *(<span class="type">unsigned</span> <span class="type">long</span>*)rbp;</span><br><span class="line">funcAddr = *(<span class="type">unsigned</span> <span class="type">long</span>*)(rbp + <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<h4 id="代码实现推栈">代码实现推栈</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GetRbp() (&#123; \</span></span><br><span class="line"><span class="meta">    unsigned long rbp; \</span></span><br><span class="line"><span class="meta">    __asm__ __volatile__ (<span class="string">&quot;movq %%rbp,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(rbp)); \</span></span><br><span class="line"><span class="meta">    rbp; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetCurrentStackBase</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *stackBegin, <span class="type">unsigned</span> <span class="type">long</span> *stackBase)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_getattr_np(tid, &amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *pStackAddr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">size_t</span> stackSize = <span class="number">0</span>;</span><br><span class="line">        (<span class="type">void</span>)pthread_attr_getstack(&amp;attr, &amp;pStackAddr, (<span class="type">size_t</span> *)(&amp;stackSize));</span><br><span class="line">        (<span class="type">void</span>)pthread_attr_destroy(&amp;attr);</span><br><span class="line">        *stackBegin = (<span class="type">unsigned</span> <span class="type">long</span>)pStackAddr;</span><br><span class="line">        *stackBase = (<span class="type">unsigned</span> <span class="type">long</span>)pStackAddr + stackSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *stackBegin = <span class="number">0</span>;</span><br><span class="line">    *stackBase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsInvalidAddr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> instAddr, <span class="type">unsigned</span> <span class="type">long</span> begin, <span class="type">unsigned</span> <span class="type">long</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instAddr &lt;= begin &amp;&amp; instAddr &gt;= end &amp;&amp; (instAddr &amp; <span class="number">3</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BackTrace</span><span class="params">(<span class="type">void</span> **buffer, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *<span class="built_in">array</span> = *(<span class="type">unsigned</span> <span class="type">long</span> **)buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulRbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stackBegin;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stackBase;</span><br><span class="line">    ulRbp = GetRbp();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = <span class="number">0xfaceface</span>; <span class="comment">// 赋予无效值</span></span><br><span class="line">    &#125;</span><br><span class="line">    GetCurrentStackBase(&amp;stackBegin, &amp;stackBase);</span><br><span class="line">    <span class="keyword">if</span> (IsInvalidAddr(ulRbp, stackBegin, stackBase)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> stackDepth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> preUlRbp = ulRbp;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> instAddr = ulRbp + <span class="number">8</span>;</span><br><span class="line">        ulRbp = *(<span class="type">unsigned</span> <span class="type">long</span> *)ulRbp;</span><br><span class="line">        <span class="keyword">if</span> (IsInvalidAddr(instAddr, stackBegin, stackBase) </span><br><span class="line">            || IsInvalidAddr(ulRbp, preUlRbp, stackBase)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[stackDepth] = *(<span class="type">unsigned</span> <span class="type">long</span> *)instAddr;</span><br><span class="line">        stackDepth++;</span><br><span class="line">    &#125; <span class="keyword">while</span>(stackDepth &lt; size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试demo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc backtrace.c -lpthread -rdynamic -m64 -fno-omit-frame-pointer -g -D_GNU_SOURCE -o backtrace</span></span><br><span class="line"><span class="comment">// backtrace_symbols only works if link with -rdynamic</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noinline __attribute__((noinline))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GetRbp() (&#123; \</span></span><br><span class="line"><span class="meta">    unsigned long rbp; \</span></span><br><span class="line"><span class="meta">    __asm__ __volatile__ (<span class="string">&quot;movq %%rbp,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(rbp)); \</span></span><br><span class="line"><span class="meta">    rbp; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetCurrentStackBase</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *stackBegin, <span class="type">unsigned</span> <span class="type">long</span> *stackBase)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_getattr_np(tid, &amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *pStackAddr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">size_t</span> stackSize = <span class="number">0</span>;</span><br><span class="line">        (<span class="type">void</span>)pthread_attr_getstack(&amp;attr, &amp;pStackAddr, (<span class="type">size_t</span> *)(&amp;stackSize));</span><br><span class="line">        (<span class="type">void</span>)pthread_attr_destroy(&amp;attr);</span><br><span class="line">        *stackBegin = (<span class="type">unsigned</span> <span class="type">long</span>)pStackAddr;</span><br><span class="line">        *stackBase = (<span class="type">unsigned</span> <span class="type">long</span>)pStackAddr + stackSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *stackBegin = <span class="number">0</span>;</span><br><span class="line">    *stackBase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsInvalidAddr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> instAddr, <span class="type">unsigned</span> <span class="type">long</span> begin, <span class="type">unsigned</span> <span class="type">long</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instAddr &lt;= begin &amp;&amp; instAddr &gt;= end &amp;&amp; (instAddr &amp; <span class="number">3</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BackTrace</span><span class="params">(<span class="type">void</span> **buffer, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *<span class="built_in">array</span> = *(<span class="type">unsigned</span> <span class="type">long</span> **)buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulRbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stackBegin;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stackBase;</span><br><span class="line">    ulRbp = GetRbp();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = <span class="number">0xfaceface</span>; <span class="comment">// 赋予无效值</span></span><br><span class="line">    &#125;</span><br><span class="line">    GetCurrentStackBase(&amp;stackBegin, &amp;stackBase);</span><br><span class="line">    <span class="keyword">if</span> (IsInvalidAddr(ulRbp, stackBegin, stackBase)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> stackDepth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> preUlRbp = ulRbp;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> instAddr = ulRbp + <span class="number">8</span>;</span><br><span class="line">        ulRbp = *(<span class="type">unsigned</span> <span class="type">long</span> *)ulRbp;</span><br><span class="line">        <span class="keyword">if</span> (IsInvalidAddr(instAddr, stackBegin, stackBase) </span><br><span class="line">            || IsInvalidAddr(ulRbp, preUlRbp, stackBase)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[stackDepth] = *(<span class="type">unsigned</span> <span class="type">long</span> *)instAddr;</span><br><span class="line">        stackDepth++;</span><br><span class="line">    &#125; <span class="keyword">while</span>(stackDepth &lt; size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> <span class="title function_">FuncC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *buffer;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">4</span>;</span><br><span class="line">    buffer = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) * size);</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call malloc(%ld) failed\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) * size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>)BackTrace((<span class="type">void</span> **)&amp;buffer, size);</span><br><span class="line">    <span class="comment">// backtrace_symbols only works if link with -rdynamic</span></span><br><span class="line">    <span class="type">char</span> **symbolName = backtrace_symbols((<span class="type">void</span> *)buffer, size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;------0x%016lx(%s)\n&quot;</span>, buffer[i], symbolName[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    buffer = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> <span class="title function_">FuncB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    FuncC();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> <span class="title function_">FuncA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    FuncB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FuncA();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zkq@ubuntu:src$ gcc backtrace.c -lpthread -rdynamic -m64 -fno-omit-frame-pointer -g -D_GNU_SOURCE -o backtrace</span><br><span class="line">zkq@ubuntu:src$ ./backtrace</span><br><span class="line">&lt;-----<span class="number">-0x00007fb4ffeab52a</span>(./backtrace(FuncC+<span class="number">0x6f</span>) [<span class="number">0x7fb4ffeab52a</span>])</span><br><span class="line">&lt;-----<span class="number">-0x00007fb4ffeab5d6</span>(./backtrace(FuncB+<span class="number">0x19</span>) [<span class="number">0x7fb4ffeab5d6</span>])</span><br><span class="line">&lt;-----<span class="number">-0x00007fb4ffeab5f2</span>(./backtrace(FuncA+<span class="number">0x19</span>) [<span class="number">0x7fb4ffeab5f2</span>])</span><br><span class="line">&lt;-----<span class="number">-0x00007fb4ffeab603</span>(./backtrace(main+<span class="number">0xe</span>) [<span class="number">0x7fb4ffeab603</span>])</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>x86_64推栈原理与实现2</title>
    <url>/zhoukaiqi/5402692fe700/</url>
    <content><![CDATA[<p>本文介绍了x86_64如何用rsp推栈。</p>
<span id="more"></span>
<h4 id="推栈原理-2">推栈原理</h4>
<p>x86_64如果显式加了编译选项<code>-fomit-frame-pointer</code>或者没有加编译选项<code>-fno-omit-frame-pointer</code>，会导致rbp不压栈，这里考虑用rsp推栈。rsp推栈主要原理依赖callq指令。</p>
<p><font color="#FF0000"> <strong>callq addr的具体实现</strong> </font></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rsp = rsp - <span class="number">8</span></span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">long</span>*)rsp = rip + <span class="keyword">sizeof</span>(inst)</span><br><span class="line">rip = addr</span><br></pre></td></tr></table></figure>
<p>根据callq的实现机制，可以得到推栈公式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rip = *(<span class="type">unsigned</span> <span class="type">long</span>*)(rsp + 当前函数开栈大小)  <span class="comment">// rip是上一个函数的地址</span></span><br><span class="line">rsp = rsp + 当前函数开栈大小 + <span class="number">8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数开栈大小：<font color="#FF0000">push指令占8字节，sub xxx rsp指令占xxx字节，即操作rsp的指令</font></p>
</blockquote>
<h4 id="推栈演示">推栈演示</h4>
<p>以下代码为例，编译命令是<code>gcc test.c -fomit-frame-pointer -g -o test</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> noinline __attribute__((noinline))</span></span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> <span class="title function_">FuncD</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> <span class="title function_">FuncC</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b = x;</span><br><span class="line">    FuncD(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> <span class="title function_">FuncB</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b = x;</span><br><span class="line">    FuncC(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> <span class="title function_">FuncA</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> b = x + <span class="number">2</span>;</span><br><span class="line">    FuncB(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FuncA(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.当代码执行到<code>FuncD</code>函数时，开栈大小是0x38(<code>sub    $0x38,%rsp</code>，没有push指令)</p>
<p>所以<code>rip = *(unsigned long*)(0x7ffffffedef0 + 0x38) = 0x080011c9</code>，即&lt;FuncC+60&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Breakpoint 1, FuncD (x=4) at backtrace_rsp.c:6</span><br><span class="line">6       &#123;</span><br><span class="line">(gdb) disassemble FuncD</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncD:</span><br><span class="line">   0x0000000008001149 &lt;+0&gt;:     sub    <span class="variable">$0x38</span>,%rsp</span><br><span class="line">   0x000000000800114d &lt;+4&gt;:     mov    %edi,0xc(%rsp)</span><br><span class="line">=&gt; 0x0000000008001151 &lt;+8&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">   0x000000000800115a &lt;+17&gt;:    mov    %rax,0x28(%rsp)</span><br><span class="line">   0x000000000800115f &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">   0x0000000008001161 &lt;+24&gt;:    movq   <span class="variable">$0x0</span>,0x20(%rsp)</span><br><span class="line">   0x000000000800116a &lt;+33&gt;:    mov    0xc(%rsp),%eax</span><br><span class="line">   0x000000000800116e &lt;+37&gt;:    mov    %eax,0x1c(%rsp)</span><br><span class="line">   0x0000000008001172 &lt;+41&gt;:    nop</span><br><span class="line">   0x0000000008001173 &lt;+42&gt;:    mov    0x28(%rsp),%rax</span><br><span class="line">   0x0000000008001178 &lt;+47&gt;:    xor    %fs:0x28,%rax</span><br><span class="line">   0x0000000008001181 &lt;+56&gt;:    je     0x8001188 &lt;FuncD+63&gt;</span><br><span class="line">   0x0000000008001183 &lt;+58&gt;:    callq  0x8001050 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000000008001188 &lt;+63&gt;:    add    <span class="variable">$0x38</span>,%rsp</span><br><span class="line">   0x000000000800118c &lt;+67&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) i r rsp</span><br><span class="line">rsp            0x7ffffffedef0      0x7ffffffedef0</span><br><span class="line">(gdb) p/x 0x7ffffffedef0 + 0x38</span><br><span class="line"><span class="variable">$1</span> = 0x7ffffffedf28</span><br><span class="line">(gdb) x/16wx <span class="variable">$rsp</span></span><br><span class="line">0x7ffffffedef0: 0x00000380      0x00000380      0x00000380      0x00000004</span><br><span class="line">0x7ffffffedf00: 0x00000380      0x00000380      0x00000380      0x00000380</span><br><span class="line">0x7ffffffedf10: 0x00000380      0x00000380      0x00000380      0x00000380</span><br><span class="line">0x7ffffffedf20: 0x00000380      0x00000380      0x080011c9      0x00000000</span><br><span class="line">(gdb) x 0x080011c9</span><br><span class="line">0x80011c9 &lt;FuncC+60&gt;:   0x448b4890</span><br></pre></td></tr></table></figure>
<p>推完一层栈后，<code>rsp = 0x7ffffffedef0 + 0x38 + 8 = 0x7ffffffedf30</code></p>
<p>2.当代码执行到<code>FuncC</code>函数时，开栈大小是0x38(<code>sub    $0x38,%rsp</code>)</p>
<p>所以<code>rip = *(unsigned long*)(0x7ffffffedf30 + 0x38) = 0x08001221</code>，即&lt;FuncB+61&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncC</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncC:</span><br><span class="line">   0x000000000800118d &lt;+0&gt;:     sub    <span class="variable">$0x38</span>,%rsp</span><br><span class="line">   0x0000000008001191 &lt;+4&gt;:     mov    %edi,0xc(%rsp)</span><br><span class="line">   0x0000000008001195 &lt;+8&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">   0x000000000800119e &lt;+17&gt;:    mov    %rax,0x28(%rsp)</span><br><span class="line">   0x00000000080011a3 &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">   0x00000000080011a5 &lt;+24&gt;:    movq   <span class="variable">$0x0</span>,0x1c(%rsp)</span><br><span class="line">   0x00000000080011ae &lt;+33&gt;:    movl   <span class="variable">$0x0</span>,0x24(%rsp)</span><br><span class="line">   0x00000000080011b6 &lt;+41&gt;:    mov    0xc(%rsp),%eax</span><br><span class="line">   0x00000000080011ba &lt;+45&gt;:    mov    %eax,0x18(%rsp)</span><br><span class="line">   0x00000000080011be &lt;+49&gt;:    mov    0x18(%rsp),%eax</span><br><span class="line">   0x00000000080011c2 &lt;+53&gt;:    mov    %eax,%edi</span><br><span class="line">   0x00000000080011c4 &lt;+55&gt;:    callq  0x8001149 &lt;FuncD&gt;</span><br><span class="line">   0x00000000080011c9 &lt;+60&gt;:    nop</span><br><span class="line">   0x00000000080011ca &lt;+61&gt;:    mov    0x28(%rsp),%rax</span><br><span class="line">   0x00000000080011cf &lt;+66&gt;:    xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000080011d8 &lt;+75&gt;:    je     0x80011df &lt;FuncC+82&gt;</span><br><span class="line">   0x00000000080011da &lt;+77&gt;:    callq  0x8001050 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000080011df &lt;+82&gt;:    add    <span class="variable">$0x38</span>,%rsp</span><br><span class="line">   0x00000000080011e3 &lt;+86&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) p/x 0x7ffffffedf30 + 0x38</span><br><span class="line"><span class="variable">$5</span> = 0x7ffffffedf68</span><br><span class="line">(gdb) x/16wx 0x7ffffffedf30</span><br><span class="line">0x7ffffffedf30: 0x00000380      0x00000380      0x00000380      0x00000004</span><br><span class="line">0x7ffffffedf40: 0x00000380      0x00000380      0x00000004      0x00000000</span><br><span class="line">0x7ffffffedf50: 0x00000000      0x00000000      0x41fe1c00      0x9710ef65</span><br><span class="line">0x7ffffffedf60: 0x00000000      0x00000000      0x08001221      0x00000000</span><br><span class="line">(gdb) x 0x08001221</span><br><span class="line">0x8001221 &lt;FuncB+61&gt;:   0x448b4890</span><br></pre></td></tr></table></figure>
<p>推完一层栈后，<code>rsp = 0x7ffffffedf30 + 0x38 + 8 = 0x7ffffffedf70</code></p>
<p>3.当代码执行到<code>FuncB</code>函数时，开栈大小是0x48(<code>sub    $0x48,%rsp</code>)</p>
<p>所以<code>rip = *(unsigned long*)(0x7ffffffedf70 + 0x48) = 0x08001284</code>，即&lt;FuncA+72&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncB</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncB:</span><br><span class="line">   0x00000000080011e4 &lt;+0&gt;:     sub    <span class="variable">$0x48</span>,%rsp</span><br><span class="line">   0x00000000080011e8 &lt;+4&gt;:     mov    %edi,0xc(%rsp)</span><br><span class="line">   0x00000000080011ec &lt;+8&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">   0x00000000080011f5 &lt;+17&gt;:    mov    %rax,0x38(%rsp)</span><br><span class="line">   0x00000000080011fa &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">   0x00000000080011fc &lt;+24&gt;:    movq   <span class="variable">$0x0</span>,0x20(%rsp)</span><br><span class="line">   0x0000000008001205 &lt;+33&gt;:    movq   <span class="variable">$0x0</span>,0x28(%rsp)</span><br><span class="line">   0x000000000800120e &lt;+42&gt;:    mov    0xc(%rsp),%eax</span><br><span class="line">   0x0000000008001212 &lt;+46&gt;:    mov    %eax,0x1c(%rsp)</span><br><span class="line">   0x0000000008001216 &lt;+50&gt;:    mov    0x1c(%rsp),%eax</span><br><span class="line">   0x000000000800121a &lt;+54&gt;:    mov    %eax,%edi</span><br><span class="line">   0x000000000800121c &lt;+56&gt;:    callq  0x800118d &lt;FuncC&gt;</span><br><span class="line">   0x0000000008001221 &lt;+61&gt;:    nop</span><br><span class="line">   0x0000000008001222 &lt;+62&gt;:    mov    0x38(%rsp),%rax</span><br><span class="line">   0x0000000008001227 &lt;+67&gt;:    xor    %fs:0x28,%rax</span><br><span class="line">   0x0000000008001230 &lt;+76&gt;:    je     0x8001237 &lt;FuncB+83&gt;</span><br><span class="line">   0x0000000008001232 &lt;+78&gt;:    callq  0x8001050 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000000008001237 &lt;+83&gt;:    add    <span class="variable">$0x48</span>,%rsp</span><br><span class="line">   0x000000000800123b &lt;+87&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) p/x 0x7ffffffedf70 + 0x48</span><br><span class="line"><span class="variable">$6</span> = 0x7ffffffedfb8</span><br><span class="line">(gdb) x/20wx 0x7ffffffedf70</span><br><span class="line">0x7ffffffedf70: 0x00000000      0x00000000      0x00000000      0x00000004</span><br><span class="line">0x7ffffffedf80: 0x00000000      0x00000000      0x00000000      0x00000004</span><br><span class="line">0x7ffffffedf90: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7ffffffedfa0: 0x00000000      0x00000000      0x41fe1c00      0x9710ef65</span><br><span class="line">0x7ffffffedfb0: 0x08000040      0x00000000      0x08001284      0x00000000</span><br><span class="line">(gdb) x 0x08001284</span><br><span class="line">0x8001284 &lt;FuncA+72&gt;:   0x448b4890</span><br></pre></td></tr></table></figure>
<p>推完一层栈后，<code>rsp = 0x7ffffffedf70 + 0x48 + 8 = 0x7ffffffedfc0</code></p>
<p>4.当代码执行到<code>FuncA</code>函数时，开栈大小是0x48(<code>sub    $0x48,%rsp</code>)</p>
<p>所以<code>rip = *(unsigned long*)(0x7ffffffedfc0 + 0x48) = 0x08001284</code>，即&lt;main+14&gt;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncA</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncA:</span><br><span class="line">   0x000000000800123c &lt;+0&gt;:     sub    <span class="variable">$0x48</span>,%rsp</span><br><span class="line">   0x0000000008001240 &lt;+4&gt;:     mov    %edi,0xc(%rsp)</span><br><span class="line">   0x0000000008001244 &lt;+8&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">   0x000000000800124d &lt;+17&gt;:    mov    %rax,0x38(%rsp)</span><br><span class="line">   0x0000000008001252 &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">   0x0000000008001254 &lt;+24&gt;:    movq   <span class="variable">$0x0</span>,0x20(%rsp)</span><br><span class="line">   0x000000000800125d &lt;+33&gt;:    movq   <span class="variable">$0x0</span>,0x28(%rsp)</span><br><span class="line">   0x0000000008001266 &lt;+42&gt;:    movl   <span class="variable">$0x0</span>,0x30(%rsp)</span><br><span class="line">   0x000000000800126e &lt;+50&gt;:    mov    0xc(%rsp),%eax</span><br><span class="line">   0x0000000008001272 &lt;+54&gt;:    add    <span class="variable">$0x2</span>,%eax</span><br><span class="line">   0x0000000008001275 &lt;+57&gt;:    mov    %eax,0x1c(%rsp)</span><br><span class="line">   0x0000000008001279 &lt;+61&gt;:    mov    0x1c(%rsp),%eax</span><br><span class="line">   0x000000000800127d &lt;+65&gt;:    mov    %eax,%edi</span><br><span class="line">   0x000000000800127f &lt;+67&gt;:    callq  0x80011e4 &lt;FuncB&gt;</span><br><span class="line">   0x0000000008001284 &lt;+72&gt;:    nop</span><br><span class="line">   0x0000000008001285 &lt;+73&gt;:    mov    0x38(%rsp),%rax</span><br><span class="line">   0x000000000800128a &lt;+78&gt;:    xor    %fs:0x28,%rax</span><br><span class="line">   0x0000000008001293 &lt;+87&gt;:    je     0x800129a &lt;FuncA+94&gt;</span><br><span class="line">   0x0000000008001295 &lt;+89&gt;:    callq  0x8001050 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x000000000800129a &lt;+94&gt;:    add    <span class="variable">$0x48</span>,%rsp</span><br><span class="line">   0x000000000800129e &lt;+98&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) p/x 0x7ffffffedfc0 + 0x48</span><br><span class="line"><span class="variable">$8</span> = 0x7ffffffee008</span><br><span class="line">(gdb) x/20wx 0x7ffffffedfc0</span><br><span class="line">0x7ffffffedfc0: 0x000000c2      0x00000000      0xfffedff7      0x00000002</span><br><span class="line">0x7ffffffedfd0: 0xfffedff6      0x00007fff      0x0800130d      0x00000004</span><br><span class="line">0x7ffffffedfe0: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7ffffffedff0: 0x00000000      0x00000000      0x41fe1c00      0x9710ef65</span><br><span class="line">0x7ffffffee000: 0xfffee100      0x00007fff      0x080012ad      0x00000000</span><br><span class="line">(gdb) x 0x080012ad</span><br><span class="line">0x80012ad &lt;main+14&gt;:    0x000000b8</span><br></pre></td></tr></table></figure>
<p>即推栈结果是<code>&lt;FuncC+60&gt; &lt;-- &lt;FuncB+61&gt; &lt;-- &lt;FuncA+72&gt; &lt;-- &lt;main+14&gt;</code>，与gdb的bt推栈结果完全一致。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  FuncD ()</span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000080011c9</span> in <span class="title function_">FuncC</span> <span class="params">()</span> </span><br><span class="line">#2  0x0000000008001221 in <span class="title function_">FuncB</span> <span class="params">()</span> </span><br><span class="line">#3  0x0000000008001284 in <span class="title function_">FuncA</span> <span class="params">()</span> </span><br><span class="line">#4  0x00000000080012ad in <span class="title function_">main</span> <span class="params">()</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
