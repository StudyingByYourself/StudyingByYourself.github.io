<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>movaps指令引起的复位</title>
      <link href="/zhoukaiqi/movaps%E6%8C%87%E4%BB%A4%E5%BC%95%E8%B5%B7%E7%9A%84%E5%A4%8D%E4%BD%8D/"/>
      <url>/zhoukaiqi/movaps%E6%8C%87%E4%BB%A4%E5%BC%95%E8%B5%B7%E7%9A%84%E5%A4%8D%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>最近定位了一个bolt优化导致进程异常复位的问题。disassemble复位函数发现是运行到movaps指令时挂了。movaps是SSE指令，要求访问的地址是16字节对齐的。由于bolt优化多开了一层8字节的栈，后续的rbp非16字节对齐。当movaps访问非16字节对齐的rbp时，指令异常，进程复位。</p><span id="more"></span><p>这里忽略bolt优化，只用汇编模拟movaps指令异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;movaps 0x04(%rdx), %xmm0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x0000000008001129</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x000000000800112d</span> &lt;+<span class="number">4</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x000000000800112e</span> &lt;+<span class="number">5</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000008001131</span> &lt;+<span class="number">8</span>&gt;:     movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">=&gt; <span class="number">0x0000000008001138</span> &lt;+<span class="number">15</span>&gt;:    movaps <span class="number">0x4</span>(%rdx),%xmm0</span><br><span class="line">   <span class="number">0x000000000800113c</span> &lt;+<span class="number">19</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x0000000008001141</span> &lt;+<span class="number">24</span>&gt;:    pop    %rbp</span><br><span class="line">   <span class="number">0x0000000008001142</span> &lt;+<span class="number">25</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) i r rdx</span><br><span class="line">rdx            <span class="number">0x7ffffffee168</span>      <span class="number">140737488281960</span></span><br></pre></td></tr></table></figure><p>rdx寄存器是0x7ffffffee168， 0x7ffffffee168+0x4=0x7ffffffee16c不是16字节对齐，所以会出现段错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">main () at demo.c:<span class="number">4</span></span><br><span class="line"><span class="number">4</span>           __asm__ __volatile__ (<span class="string">&quot;movaps 0x04(%rdx), %xmm0&quot;</span>);</span><br><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x0000000008001129</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x000000000800112d</span> &lt;+<span class="number">4</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x000000000800112e</span> &lt;+<span class="number">5</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000008001131</span> &lt;+<span class="number">8</span>&gt;:     movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">=&gt; <span class="number">0x0000000008001138</span> &lt;+<span class="number">15</span>&gt;:    movaps <span class="number">0x4</span>(%rdx),%xmm0</span><br><span class="line">   <span class="number">0x000000000800113c</span> &lt;+<span class="number">19</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x0000000008001141</span> &lt;+<span class="number">24</span>&gt;:    pop    %rbp</span><br><span class="line">   <span class="number">0x0000000008001142</span> &lt;+<span class="number">25</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>如果给rdx寄存器减去12字节，使得rdx+4是16字节对齐的，则能正常执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x0000000008001129</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x000000000800112d</span> &lt;+<span class="number">4</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x000000000800112e</span> &lt;+<span class="number">5</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000008001131</span> &lt;+<span class="number">8</span>&gt;:     movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">=&gt; <span class="number">0x0000000008001138</span> &lt;+<span class="number">15</span>&gt;:    movaps <span class="number">0x4</span>(%rdx),%xmm0</span><br><span class="line">   <span class="number">0x000000000800113c</span> &lt;+<span class="number">19</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x0000000008001141</span> &lt;+<span class="number">24</span>&gt;:    pop    %rbp</span><br><span class="line">   <span class="number">0x0000000008001142</span> &lt;+<span class="number">25</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) i r $rdx</span><br><span class="line">rdx            <span class="number">0x7ffffffee168</span>      <span class="number">140737488281960</span></span><br><span class="line">(gdb) <span class="built_in">set</span> $rdx = $rdx - <span class="number">12</span></span><br><span class="line">(gdb) i r $rdx</span><br><span class="line">rdx            <span class="number">0x7ffffffee15c</span>      <span class="number">140737488281948</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">396</span>) exited normally]</span><br></pre></td></tr></table></figure><p>补充：movups<code>u表示不必16字节对齐，替换成a表示必需16字节对齐。</code></p><p>参考：<a href="https://blog.csdn.net/u010659887/article/details/113802005">https://blog.csdn.net/u010659887/article/details/113802005</a></p>]]></content>
      
      
      <categories>
          
          <category> assembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调用者与被调用者的寄存器优化</title>
      <link href="/zhoukaiqi/leaf-function/"/>
      <url>/zhoukaiqi/leaf-function/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> assembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈保护canary机制与__stack_chk_fail</title>
      <link href="/zhoukaiqi/stack-chk-fail/"/>
      <url>/zhoukaiqi/stack-chk-fail/</url>
      
        <content type="html"><![CDATA[<h5 id="栈保护canary机制">栈保护canary机制</h5><p>canary机制原理：在函数被调用之后，立即在栈帧中插入一个随机数，函数执行完在返回之前，检查这个随机数是否改变来判断是否存在栈溢出。</p><span id="more"></span><h5 id="构造-stack-chk-fail">构造__stack_chk_fail</h5><p>以demo.c为例，编译命令<code>gcc demo.c -fstack-protector -fno-omit-frame-pointer -fPIC -g -o demo</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FuncDemo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x900C</span>;</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="string">&#x27;c&#x27;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">100</span>); <span class="comment">// 踩栈</span></span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FuncDemo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整汇编</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble FuncDemo</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncDemo:</span><br><span class="line">   0x0000aaaaaaaaa884 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">   0x0000aaaaaaaaa888 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">   0x0000aaaaaaaaa88c &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa890 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa894 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">   0x0000aaaaaaaaa898 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa89c &lt;+24&gt;:    mov     x1, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa8a0 &lt;+28&gt;:    mov     w0, <span class="comment">#0x900c                     // #36876</span></span><br><span class="line">   0x0000aaaaaaaaa8a4 &lt;+32&gt;:    str     w0, [x29, <span class="comment">#28]</span></span><br><span class="line">   0x0000aaaaaaaaa8a8 &lt;+36&gt;:    mov     x0, <span class="comment">#0x8                        // #8</span></span><br><span class="line">   0x0000aaaaaaaaa8ac &lt;+40&gt;:    bl      0xaaaaaaaaa710 &lt;malloc@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa8b0 &lt;+44&gt;:    str     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa8b4 &lt;+48&gt;:    adrp    x0, 0xaaaaaaaaa000</span><br><span class="line">   0x0000aaaaaaaaa8b8 &lt;+52&gt;:    add     x1, x0, <span class="comment">#0x9f0</span></span><br><span class="line">   0x0000aaaaaaaaa8bc &lt;+56&gt;:    add     x0, x29, <span class="comment">#0x50</span></span><br><span class="line">   0x0000aaaaaaaaa8c0 &lt;+60&gt;:    ldr     x2, [x1]</span><br><span class="line">   0x0000aaaaaaaaa8c4 &lt;+64&gt;:    str     x2, [x0]</span><br><span class="line">   0x0000aaaaaaaaa8c8 &lt;+68&gt;:    ldur    x1, [x1, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa8cc &lt;+72&gt;:    stur    x1, [x0, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa8d0 &lt;+76&gt;:    stur    wzr, [x29, <span class="comment">#93]</span></span><br><span class="line">   0x0000aaaaaaaaa8d4 &lt;+80&gt;:    sturh   wzr, [x29, <span class="comment">#97]</span></span><br><span class="line">   0x0000aaaaaaaaa8d8 &lt;+84&gt;:    strb    wzr, [x29, <span class="comment">#99]</span></span><br><span class="line">   0x0000aaaaaaaaa8dc &lt;+88&gt;:    stp     xzr, xzr, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa8e0 &lt;+92&gt;:    stp     xzr, xzr, [x29, <span class="comment">#56]</span></span><br><span class="line">   0x0000aaaaaaaaa8e4 &lt;+96&gt;:    str     xzr, [x29, <span class="comment">#72]</span></span><br><span class="line">   0x0000aaaaaaaaa8e8 &lt;+100&gt;:   mov     w0, <span class="comment">#0x1                        // #1</span></span><br><span class="line">   0x0000aaaaaaaaa8ec &lt;+104&gt;:   str     w0, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa8f0 &lt;+108&gt;:   add     x0, x29, <span class="comment">#0x28</span></span><br><span class="line">   0x0000aaaaaaaaa8f4 &lt;+112&gt;:   mov     x2, <span class="comment">#0x64                       // #100</span></span><br><span class="line">   0x0000aaaaaaaaa8f8 &lt;+116&gt;:   mov     w1, <span class="comment">#0x63                       // #99</span></span><br><span class="line">   0x0000aaaaaaaaa8fc &lt;+120&gt;:   bl      0xaaaaaaaaa730 &lt;memset@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa900 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa904 &lt;+128&gt;:   bl      0xaaaaaaaaa770 &lt;free@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa908 &lt;+132&gt;:   str     xzr, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa90c &lt;+136&gt;:   mov     w0, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa910 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa914 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa918 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa91c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">   0x0000aaaaaaaaa920 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">   0x0000aaaaaaaaa924 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">   0x0000aaaaaaaaa928 &lt;+164&gt;:   b.eq    0xaaaaaaaaa930 &lt;FuncDemo+172&gt;  // b.none</span><br><span class="line">   0x0000aaaaaaaaa92c &lt;+168&gt;:   bl      0xaaaaaaaaa740 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa930 &lt;+172&gt;:   ldp     x29, x30, [sp], <span class="comment">#112</span></span><br><span class="line">   0x0000aaaaaaaaa934 &lt;+176&gt;:   ret</span><br></pre></td></tr></table></figure><h6 id="1-先通过反汇编找到canary在栈上的存放地址">1. 先通过反汇编找到canary在栈上的存放地址</h6><p>canary的值是<code>0x4c597894f2014f00</code>，存入sp + 104的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble FuncDemo</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncDemo:</span><br><span class="line">   0x0000aaaaaaaaa884 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">   0x0000aaaaaaaaa888 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">   0x0000aaaaaaaaa88c &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa890 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa894 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">   0x0000aaaaaaaaa898 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">(gdb) i r x0 x1</span><br><span class="line">x0             0xfffff7ffd7a8   281474842482600</span><br><span class="line">x1             0x4c597894f2014f00       5501561000920436480</span><br><span class="line">(gdb) x/2wx <span class="variable">$x0</span></span><br><span class="line">0xfffff7ffd7a8 &lt;__stack_chk_guard&gt;:     0xf2014f00      0x4c597894</span><br><span class="line">(gdb) x/2wx <span class="variable">$sp</span> + 104</span><br><span class="line">0xfffffffffa38: 0xf2014f00      0x4c597894</span><br></pre></td></tr></table></figure><h6 id="2-执行完代码第7行">2. 执行完代码第7行</h6><p>memset越界，将栈中保存的canary值踩成了’c’</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   0x0000aaaaaaaaa8fc &lt;+120&gt;:   bl      0xaaaaaaaaa730 &lt;memset@plt&gt;</span><br><span class="line">=&gt; 0x0000aaaaaaaaa900 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">(gdb) x/2wx <span class="variable">$sp</span> + 104</span><br><span class="line">0xfffffffffa38: 0x63636363      0x63636363</span><br></pre></td></tr></table></figure><h6 id="3-继续执行">3. 继续执行</h6><p>从栈中取出保存的canary值与原来的canary值比较，不相等则说明有踩栈，跳转到__stack_chk_fail并抛出异常信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   0x0000aaaaaaaaa910 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa914 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa918 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa91c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">   0x0000aaaaaaaaa920 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">   0x0000aaaaaaaaa924 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">   0x0000aaaaaaaaa928 &lt;+164&gt;:   b.eq    0xaaaaaaaaa930 &lt;FuncDemo+172&gt;  // b.none</span><br><span class="line">   0x0000aaaaaaaaa92c &lt;+168&gt;:   bl      0xaaaaaaaaa740 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Program received signal SIGABRT, Aborted.</span><br><span class="line">__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51</span><br><span class="line">51      ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51</span></span><br><span class="line"><span class="comment">#1  0x0000fffff7eaa974 in __GI_abort () at abort.c:79</span></span><br><span class="line"><span class="comment">#2  0x0000fffff7ee372c in __libc_message (action=do_abort,</span></span><br><span class="line">    <span class="built_in">fmt</span>=<span class="built_in">fmt</span>@entry=0xfffff7fa3350 <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>)</span><br><span class="line">    at ../sysdeps/posix/libc_fatal.c:181</span><br><span class="line"><span class="comment">#3  0x0000fffff7f583c4 in __GI___fortify_fail_abort (</span></span><br><span class="line">    need_backtrace=need_backtrace@entry=<span class="literal">false</span>,</span><br><span class="line">    msg=msg@entry=0xfffff7fa3328 <span class="string">&quot;stack smashing detected&quot;</span>)</span><br><span class="line">    at fortify_fail.c:33</span><br><span class="line"><span class="comment">#4  0x0000fffff7f58378 in __stack_chk_fail () at stack_chk_fail.c:29</span></span><br><span class="line"><span class="comment">#5  0x0000aaaaaaaaa930 in FuncDemo () at demo.c:15</span></span><br><span class="line"><span class="comment">#6  0x0000aaaaaaaaa944 in main () at demo.c:19</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> assembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>common-tools</title>
      <link href="/zhoukaiqi/common-tools/"/>
      <url>/zhoukaiqi/common-tools/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了常见工具的使用</p><span id="more"></span><h6 id="1-tcpdump">1. tcpdump</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 指定网口</span><br><span class="line">tcpdump -x -n -v -s 0 -i eth2 -w demo.cap</span><br><span class="line">// 指定IP + 端口</span><br><span class="line">tcpdump -x -n -v -s 0 -i any host IP and port 21 -w demo.cap</span><br><span class="line">tcpdump -x -n -v -s 0 -i any src host srcIP and host dstIP and port 21 -w demo.cap</span><br><span class="line">// 环回网口</span><br><span class="line">tcpdump -x -n -v -s 0 -i lo -w demo.cap</span><br><span class="line">// 指定协议类型</span><br><span class="line">tcpdump -x -n -v -s 0 -i any ether proto 56320 -w demo.cap</span><br><span class="line">// 指定物理地址</span><br><span class="line">tcpdump -x -n -v -s 0 -i eth2 not tcp and not udp and ether host macaddr -w demo.cap</span><br><span class="line"></span><br><span class="line">tcpdump -x -n -v -s 0 -i any \(host IP and port 20015 \) or \(host IP \) -w demo.cap</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-n</td><td>对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析</td></tr><tr><td>-v</td><td>当分析和打印的时候，产生详细的输出</td></tr><tr><td>-s len</td><td>设置tcpdump的数据包抓取长度为len，-s 0抓取完整的数据包</td></tr><tr><td>-i interface</td><td>指定tcpdump需要监听的网口，any表示监听所有网络接口</td></tr><tr><td>-w</td><td>将抓包数据输出到文件中而不是标准输出</td></tr><tr><td>ether proto 56320</td><td>指令协议类型</td></tr><tr><td>ether host macaddr</td><td>指定物理地址</td></tr><tr><td>portrange port1-port2</td><td>指定端口范围</td></tr></tbody></table><p>wireshark抓包过滤指定的字节数据     <a href="https://blog.csdn.net/andrewgithub/article/details/103444611">https://blog.csdn.net/andrewgithub/article/details/103444611</a></p><p>data[61:3]==0a:39:00</p><p>data数据报文中，以第61字节开始，之后的3个字节的数据为 0a:39:00</p><h6 id="2-strace">2. strace</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strace -ff -tt -T -o <span class="built_in">log</span> -p 17720</span><br><span class="line">strace -f -tt -T -o <span class="built_in">log</span> -p 35332</span><br><span class="line">strace -ft -o <span class="built_in">log</span> -p 35332</span><br><span class="line">// 跟踪单个线程</span><br><span class="line">strace -tt -T -o strace.log -p pid</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-f</td><td>跟踪子线程</td></tr><tr><td>-ff</td><td>跟踪子线程，每个线程独立文件</td></tr><tr><td>-t</td><td>表示时间精确到秒(每秒记录一次)</td></tr><tr><td>-tt</td><td>表示时间精确到微秒(每微秒记录一次)</td></tr><tr><td>-T</td><td>记录各个系统调用花费的时间，精确到微秒</td></tr><tr><td>-o</td><td>表示将追踪结果输出的一个文件</td></tr><tr><td>-p</td><td>pid</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>arm64常见汇编指令</title>
      <link href="/zhoukaiqi/assembly-arm/"/>
      <url>/zhoukaiqi/assembly-arm/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了arm64常见汇编指令</p><table><thead><tr><th>指令</th><th></th><th>含义</th></tr></thead><tbody><tr><td>mov</td><td>mov x1, x0</td><td>将寄存器x0的值复制给寄存器x1</td></tr><tr><td>movk</td><td>movk x0, #1234, lsl #16</td><td>lsl：向左移位，即x0 = 0x12340000</td></tr><tr><td>stp</td><td>x29, x30, [sp, #-112]</td><td>sp = sp - 112，将x29, x30依次存入sp的位置; <br>x29充当FP寄存器，用于保存上一个sp; <br>x30充当LR寄存器，用来保存函数返回后的下一条执行地址</td></tr><tr><td>ldp</td><td>ldp     x29, x30, [sp], #112</td><td>sp取值赋给x29, sp + 8取值赋给x30, sp = sp + 112</td></tr><tr><td>str</td><td>str     w0, [x29, #40]</td><td>w0寄存器存入x29+40的内存地址</td></tr><tr><td>stur</td><td>stur    wzr, [x29, #93]</td><td>xzr/wzr分别代表8字节/4字节的0, 0x00000000写入x29+93的内存地址; <br/>sturh(2字节)，sturb(1字节)</td></tr><tr><td>add</td><td>add     x0, x29, #0x28</td><td>x29与0x28相加后赋值给x0</td></tr><tr><td>ldr</td><td>ldr     x2, [x1]</td><td>将x1作为地址，取该内存地址的值存入x2寄存器</td></tr><tr><td>eor</td><td>eor     x1, x2, x1</td><td>异或指令, x1 = x2 ^ x1</td></tr><tr><td>cbz</td><td>cbz w0, 0x687f70</td><td>与0相等则跳转到0x687f70</td></tr><tr><td>cbnz</td><td>cbz x1, 0x687f78</td><td>不与0相等则跳转到0x687f78</td></tr></tbody></table><p>保存入参的寄存器：<code>x0 - x7</code> 依次对应第1到第8个参数</p><p>保存返回值的寄存器： <code>x0</code></p><span id="more"></span><p>以demo.c为例，分析arm下的汇编指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FuncC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x900C</span>;</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="string">&#x27;c&#x27;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">40</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="1-完整指令-2">1. 完整指令</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble FuncC</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncC:</span><br><span class="line">   0x0000aaaaaaaaa8d4 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">   0x0000aaaaaaaaa8d8 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">   0x0000aaaaaaaaa8dc &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa8e0 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa8e4 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">   0x0000aaaaaaaaa8e8 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa8ec &lt;+24&gt;:    mov     x1, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa8f0 &lt;+28&gt;:    mov     w0, <span class="comment">#0x900c                     // #36876</span></span><br><span class="line">   0x0000aaaaaaaaa8f4 &lt;+32&gt;:    str     w0, [x29, <span class="comment">#28]</span></span><br><span class="line">   0x0000aaaaaaaaa8f8 &lt;+36&gt;:    mov     x0, <span class="comment">#0x8                        // #8</span></span><br><span class="line">   0x0000aaaaaaaaa8fc &lt;+40&gt;:    bl      0xaaaaaaaaa750 &lt;malloc@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa900 &lt;+44&gt;:    str     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa904 &lt;+48&gt;:    adrp    x0, 0xaaaaaaaaa000</span><br><span class="line">   0x0000aaaaaaaaa908 &lt;+52&gt;:    add     x1, x0, <span class="comment">#0xa98</span></span><br><span class="line">   0x0000aaaaaaaaa90c &lt;+56&gt;:    add     x0, x29, <span class="comment">#0x50</span></span><br><span class="line">   0x0000aaaaaaaaa910 &lt;+60&gt;:    ldr     x2, [x1]</span><br><span class="line">   0x0000aaaaaaaaa914 &lt;+64&gt;:    str     x2, [x0]</span><br><span class="line">   0x0000aaaaaaaaa918 &lt;+68&gt;:    ldur    x1, [x1, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa91c &lt;+72&gt;:    stur    x1, [x0, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa920 &lt;+76&gt;:    stur    wzr, [x29, <span class="comment">#93]</span></span><br><span class="line">   0x0000aaaaaaaaa924 &lt;+80&gt;:    sturh   wzr, [x29, <span class="comment">#97]</span></span><br><span class="line">   0x0000aaaaaaaaa928 &lt;+84&gt;:    strb    wzr, [x29, <span class="comment">#99]</span></span><br><span class="line">   0x0000aaaaaaaaa92c &lt;+88&gt;:    stp     xzr, xzr, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa930 &lt;+92&gt;:    stp     xzr, xzr, [x29, <span class="comment">#56]</span></span><br><span class="line">   0x0000aaaaaaaaa934 &lt;+96&gt;:    str     xzr, [x29, <span class="comment">#72]</span></span><br><span class="line">   0x0000aaaaaaaaa938 &lt;+100&gt;:   mov     w0, <span class="comment">#0x1                        // #1</span></span><br><span class="line">   0x0000aaaaaaaaa93c &lt;+104&gt;:   str     w0, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa940 &lt;+108&gt;:   add     x0, x29, <span class="comment">#0x28</span></span><br><span class="line">   0x0000aaaaaaaaa944 &lt;+112&gt;:   mov     x2, <span class="comment">#0x28                       // #40</span></span><br><span class="line">   0x0000aaaaaaaaa948 &lt;+116&gt;:   mov     w1, <span class="comment">#0x63                       // #99</span></span><br><span class="line">   0x0000aaaaaaaaa94c &lt;+120&gt;:   bl      0xaaaaaaaaa770 &lt;memset@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa950 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa954 &lt;+128&gt;:   bl      0xaaaaaaaaa7b0 &lt;free@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa958 &lt;+132&gt;:   str     xzr, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa95c &lt;+136&gt;:   mov     w0, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa960 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa964 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa968 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa96c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">   0x0000aaaaaaaaa970 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">   0x0000aaaaaaaaa974 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">   0x0000aaaaaaaaa978 &lt;+164&gt;:   b.eq    0xaaaaaaaaa980 &lt;FuncC+172&gt;  // b.none</span><br><span class="line">   0x0000aaaaaaaaa97c &lt;+168&gt;:   bl      0xaaaaaaaaa780 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa980 &lt;+172&gt;:   ldp     x29, x30, [sp], <span class="comment">#112</span></span><br><span class="line">   0x0000aaaaaaaaa984 &lt;+176&gt;:   ret</span><br></pre></td></tr></table></figure><h6 id="2-开栈">2. 开栈</h6><p>sp从0xfffffffff9f0偏移-112字节到0xfffffffff980，先存入x29，再存入x30，同时将sp赋值给x29。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i r x29 x30 sp</span><br><span class="line">x29            0xfffffffff9f0   281474976709104</span><br><span class="line">x30            0xaaaaaaaaa998   187649984473496</span><br><span class="line">sp             0xfffffffff9f0   0xfffffffff9f0</span><br><span class="line">0x0000aaaaaaaaa8d4 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">0x0000aaaaaaaaa8d8 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">(gdb) i r x29 x30 sp</span><br><span class="line">x29            0xfffffffff980   281474976708992</span><br><span class="line">x30            0xaaaaaaaaa998   187649984473496</span><br><span class="line">sp             0xfffffffff980   0xfffffffff980</span><br><span class="line">(gdb) x/8wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0xfffffffff990: 0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure><h6 id="3-入栈时存栈保护canary">3. 入栈时存栈保护canary</h6><p>adrp指令这里不展开。以下指令主要是将栈保护的<code>canary</code>存入栈中，后续出栈前校验。（编译选项：<code>-fstack-protector</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x0000aaaaaaaaa8dc &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">0x0000aaaaaaaaa8e0 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">0x0000aaaaaaaaa8e4 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">0x0000aaaaaaaaa8e8 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">0x0000aaaaaaaaa8ec &lt;+24&gt;:    mov     x1, <span class="comment">#0x0                        // #0</span></span><br><span class="line">(gdb) x/gx <span class="variable">$x0</span></span><br><span class="line">0xfffff7ffd7a8 &lt;__stack_chk_guard&gt;:     0x9af4bd74875a3200</span><br><span class="line">(gdb) x/2wx <span class="variable">$sp</span> + 104</span><br><span class="line">0xfffffffff9e8: 0x875a3200      0x9af4bd74</span><br></pre></td></tr></table></figure><h6 id="4-将0x900c存入x29-28的内存地址，对应代码第3行">4. 将0x900c存入x29+28的内存地址，对应代码第3行</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x0000aaaaaaaaa8f0 &lt;+28&gt;:    mov     w0, <span class="comment">#0x900c                     // #36876</span></span><br><span class="line">0x0000aaaaaaaaa8f4 &lt;+32&gt;:    str     w0, [x29, <span class="comment">#28]</span></span><br><span class="line">(gdb) x/8wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0xfffffffff990: 0x00000000      0x00000000      0x00000000      0x0000900c</span><br></pre></td></tr></table></figure><h6 id="5-申请8字节内存，内存的起始地址存入x29-32的内存地址，对应代码第4行">5. 申请8字节内存，内存的起始地址存入x29+32的内存地址，对应代码第4行</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x0000aaaaaaaaa8f8 &lt;+36&gt;:    mov     x0, <span class="comment">#0x8                        // #8</span></span><br><span class="line">0x0000aaaaaaaaa8fc &lt;+40&gt;:    bl      0xaaaaaaaaa750 &lt;malloc@plt&gt;</span><br><span class="line">0x0000aaaaaaaaa900 &lt;+44&gt;:    str     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">(gdb) i r x0</span><br><span class="line">x0             0xaaaaaaabc260   187649984545376</span><br><span class="line">(gdb) x/12wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0xfffffffff990: 0x00000000      0x00000000      0x00000000      0x0000900c</span><br><span class="line">0xfffffffff9a0: 0xaaabc260      0x0000aaaa      0x00000000      0x00000000</span><br></pre></td></tr></table></figure><h6 id="6-对应代码第5行">6. 对应代码第5行</h6><p>字符串长度是20字节</p><p>前12字节：为了字节对齐，第一次拷贝8字节，偏移到第5字节再拷贝8字节   from <code>ldr     x2, [x1]</code> to <code>ldur    x1, [x1, #5]</code></p><p>第13字节：字符串的结尾需要赋值&quot;\0&quot;  <code>stur    wzr, [x29, #93]</code></p><p>后面7字节：用&quot;\0&quot;补齐</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0x0000aaaaaaaaa904 &lt;+48&gt;:    adrp    x0, 0xaaaaaaaaa000</span><br><span class="line">0x0000aaaaaaaaa908 &lt;+52&gt;:    add     x1, x0, <span class="comment">#0xa98</span></span><br><span class="line">0x0000aaaaaaaaa90c &lt;+56&gt;:    add     x0, x29, <span class="comment">#0x50</span></span><br><span class="line">(gdb) i r <span class="variable">$x0</span></span><br><span class="line">x0             0xfffffffff9d0   281474976709072</span><br><span class="line">(gdb) x/4wx <span class="variable">$x1</span></span><br><span class="line">0xaaaaaaaaaa98: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">(gdb) x/s <span class="variable">$x1</span></span><br><span class="line">0xaaaaaaaaaa98: <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">0x0000aaaaaaaaa910 &lt;+60&gt;:    ldr     x2, [x1]</span><br><span class="line">0x0000aaaaaaaaa914 &lt;+64&gt;:    str     x2, [x0]</span><br><span class="line">(gdb) x/4wx <span class="variable">$sp</span> + 80</span><br><span class="line">0xfffffffff9d0: 0x6c6c6548      0x6f57206f      0x00000000      0x00000000</span><br><span class="line">0x0000aaaaaaaaa918 &lt;+68&gt;:    ldur    x1, [x1, <span class="comment">#5]</span></span><br><span class="line">0x0000aaaaaaaaa91c &lt;+72&gt;:    stur    x1, [x0, <span class="comment">#5]</span></span><br><span class="line">(gdb) x/5wx <span class="variable">$sp</span> + 80</span><br><span class="line">0xfffffffff9d0: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0xfffffffff9e0: 0xf7fffac8</span><br><span class="line">0x0000aaaaaaaaa920 &lt;+76&gt;:    stur    wzr, [x29, <span class="comment">#93]</span></span><br><span class="line">0x0000aaaaaaaaa924 &lt;+80&gt;:    sturh   wzr, [x29, <span class="comment">#97]</span></span><br><span class="line">0x0000aaaaaaaaa928 &lt;+84&gt;:    strb    wzr, [x29, <span class="comment">#99]</span></span><br><span class="line">(gdb) x/5wx <span class="variable">$sp</span> + 80</span><br><span class="line">0xfffffffff9d0: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0xfffffffff9e0: 0x00000000</span><br></pre></td></tr></table></figure><h6 id="7-对应代码第6行">7. 对应代码第6行</h6><p><code>stp     xzr, xzr, [x29, #40]</code> 连续拷贝16字节0到[x29, #40]，可以考虑用SSE指令加速。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x0000aaaaaaaaa92c &lt;+88&gt;:    stp     xzr, xzr, [x29, <span class="comment">#40]</span></span><br><span class="line">0x0000aaaaaaaaa930 &lt;+92&gt;:    stp     xzr, xzr, [x29, <span class="comment">#56]</span></span><br><span class="line">0x0000aaaaaaaaa934 &lt;+96&gt;:    str     xzr, [x29, <span class="comment">#72]</span></span><br><span class="line">0x0000aaaaaaaaa938 &lt;+100&gt;:   mov     w0, <span class="comment">#0x1                        // #1</span></span><br><span class="line">0x0000aaaaaaaaa93c &lt;+104&gt;:   str     w0, [x29, <span class="comment">#40]</span></span><br></pre></td></tr></table></figure><h6 id="8-对应代码第7行">8. 对应代码第7行</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000aaaaaaaaa940 &lt;+108&gt;:   add     x0, x29, <span class="comment">#0x28                        </span></span><br><span class="line">0x0000aaaaaaaaa944 &lt;+112&gt;:   mov     x2, <span class="comment">#0x28                       // #40</span></span><br><span class="line">0x0000aaaaaaaaa948 &lt;+116&gt;:   mov     w1, <span class="comment">#0x63                       // #99</span></span><br><span class="line">0x0000aaaaaaaaa94c &lt;+120&gt;:   bl      0xaaaaaaaaa770 &lt;memset@plt&gt;           </span><br></pre></td></tr></table></figure><h6 id="9-对应代码第8和第9行">9. 对应代码第8和第9行</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0000aaaaaaaaa950 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]           </span></span><br><span class="line">0x0000aaaaaaaaa954 &lt;+128&gt;:   bl      0xaaaaaaaaa7b0 &lt;free@plt&gt;</span><br><span class="line">0x0000aaaaaaaaa958 &lt;+132&gt;:   str     xzr, [x29, <span class="comment">#32]</span></span><br></pre></td></tr></table></figure><h6 id="10-出栈前校验栈保护canary">10. 出栈前校验栈保护canary</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x0000aaaaaaaaa960 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000      </span><br><span class="line">0x0000aaaaaaaaa964 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">0x0000aaaaaaaaa968 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">0x0000aaaaaaaaa96c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">0x0000aaaaaaaaa970 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">0x0000aaaaaaaaa974 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">0x0000aaaaaaaaa978 &lt;+164&gt;:   b.eq    0xaaaaaaaaa980 &lt;FuncC+172&gt;  // b.none</span><br><span class="line">0x0000aaaaaaaaa97c &lt;+168&gt;:   bl      0xaaaaaaaaa780 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><h6 id="11-出栈">11. 出栈</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i r <span class="variable">$x29</span> <span class="variable">$x30</span> <span class="variable">$sp</span></span><br><span class="line">x29            0xfffffffff980   281474976708992</span><br><span class="line">x30            0xaaaaaaaaa958   187649984473432</span><br><span class="line">sp             0xfffffffff980   0xfffffffff980</span><br><span class="line">(gdb) x/4wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0x0000aaaaaaaaa980 &lt;+172&gt;:   ldp     x29, x30, [sp], <span class="comment">#112</span></span><br><span class="line">(gdb) i r <span class="variable">$x29</span> <span class="variable">$x30</span> <span class="variable">$sp</span></span><br><span class="line">x29            0xfffffffff9f0   281474976709104</span><br><span class="line">x30            0xaaaaaaaaa998   187649984473496</span><br><span class="line">sp             0xfffffffff9f0   0xfffffffff9f0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> assembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x86_64模拟arm环境</title>
      <link href="/zhoukaiqi/arm-virtual-machine/"/>
      <url>/zhoukaiqi/arm-virtual-machine/</url>
      
        <content type="html"><![CDATA[<h6 id="1-安装arm交叉编译工具链">1.安装arm交叉编译工具链</h6><p>安装交叉编译工具链 <code>gcc-aarch64-linux-gnu</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure><p>建立软链接，否则后面执行的时候会报动态库找不到的错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/aarch64-linux-gnu/lib/libc.so.6 /lib/libc.so.6</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/aarch64-linux-gnu/lib/ld-linux-aarch64.so.1 /lib/ld-linux-aarch64.so.1</span><br></pre></td></tr></table></figure><span id="more"></span><h6 id="2-安装arm模拟器qemu">2.安装arm模拟器qemu</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br></pre></td></tr></table></figure><p>编译<code>a.out</code>并执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zkq@zkq-vm:~$ aarch64-linux-gnu-gcc main.c</span><br><span class="line">zkq@zkq-vm:~$ file a.out</span><br><span class="line">a.out: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, <span class="keyword">for</span> GNU/Linux 3.7.0, BuildID[sha1]=6ef0ca0c6462e038e589b6e1d52220a680007588, not stripped</span><br><span class="line">zkq@zkq-vm:~$ qemu-aarch64 a.out</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h6 id="3-通过gdb调试arm程序">3.通过gdb调试arm程序</h6><p>gdb调试arm程序的原理：qemu端作为gdb server启动可执行程序，另一端作为gdb client连接gdb server，进行本地远程调试。</p><p>首先安装多平台的gdb工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdb-multiarch</span><br></pre></td></tr></table></figure><p>重新编译示例代码<code>main.c</code>，注意，这次加上了参数<code>--static</code>。加上这个参数后，生成的可执行文件为静态链接的。<strong>如果不加这个参数，gdb调试的时候单步执行功能不正常，符号表也找不到。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc --static -g main.c</span><br></pre></td></tr></table></figure><p>通过下面的命令启动可执行程序<code>a.out</code>, 选项<code>-g</code>指明了gdb的监听端口，这里选择的是1234。该指令运行后，当前窗口会被阻塞住。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-aarch64 -g 1234 a.out</span><br></pre></td></tr></table></figure><p>新开一个命令行窗口，启动gdb client，进入gdb交互界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch a.out</span><br></pre></td></tr></table></figure><p>在gdb交互界面输入以下内容就可以连接到server端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure><p>接下来，就可以正常使用gdb的相关功能调试程序了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x102e8: file main.c, line 5.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:5</span><br><span class="line">5    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>main.c中必须有main函数，否则执行<code>qemu-aarch64 -g 1234 a.out</code>会报<code>Invalid ELF image for this architecture</code></p>]]></content>
      
      
      <categories>
          
          <category> assembly </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>x86_84常见汇编指令</title>
      <link href="/zhoukaiqi/assembly-x86_64/"/>
      <url>/zhoukaiqi/assembly-x86_64/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了x86_84常见汇编指令</p><table><thead><tr><th><strong>指令</strong></th><th></th><th>含义</th></tr></thead><tbody><tr><td>lea</td><td>leaq a(b, c, d), %rax</td><td>先计算地址a + b + c * d，然后把最终地址载到寄存器rax中</td></tr><tr><td>shr</td><td>$0x4, %rdi</td><td>右移：rdi &gt;&gt; 4</td></tr><tr><td>mov</td><td>mov    %rax,-0x10(%rbp)</td><td>将rax载入rbp-16的地址，变型：movb, movq, movl, movq</td></tr><tr><td>movz</td><td>movzwl %dx %eax</td><td>将源操作数做零扩展后，再复制到目的操作数中</td></tr><tr><td>movs</td><td>movswl %dx %eax</td><td>将源操作数做符号扩展后，再复制到目的操作数中</td></tr><tr><td>movaps</td><td>movaps %xmm0, -0x80(%rbp)</td><td>SSE指令，一次移动16字节，<code>要求寄存器地址16字节对齐</code></td></tr><tr><td>xor</td><td>xor    %eax, %eax</td><td>eax清零</td></tr><tr><td>test</td><td>test    %eax, %eax</td><td>eax与0比较是否相等</td></tr><tr><td>nopl</td><td>nopl  0x0(%rax)</td><td>冗余指令，为了字节对齐</td></tr></tbody></table><p>保存入参的寄存器：<code>rdi, rsi, rdx, rcx, r8, r9</code> 依次对应第一、二、三、四、五、六个参数</p><p>保存返回值的寄存器： <code>rax</code></p><span id="more"></span><p>编译选项需添加<code>-fno-omit-frame-pointer</code>，否则rbp不作为栈帧寄存器使用，无法推栈。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -Q --<span class="built_in">help</span>=optimizers -O2 | grep frame</span><br><span class="line">-fomit-frame-pointer                  [enabled]</span><br></pre></td></tr></table></figure><p><font color="#FF0000"> <strong>push rbp的具体实现</strong> </font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsp = rsp - 8</span><br><span class="line">*(unsigned long*)rsp = rbp</span><br></pre></td></tr></table></figure><p><font color="#FF0000"> <strong>callq addr的具体实现</strong> </font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rsp = rsp - 8</span><br><span class="line">*(unsigned long*)rsp = rip + sizeof(inst)</span><br><span class="line">rip = addr</span><br></pre></td></tr></table></figure><p>以demo.c为例，分析x86_64下的汇编指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FuncC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x900C</span>;</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="string">&#x27;c&#x27;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">100</span>); <span class="comment">//这里构造了踩栈，后续展开</span></span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取消栈保护编译选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -g demo.c -o demo</span><br></pre></td></tr></table></figure><h6 id="1-完整指令">1. 完整指令</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disassemble FuncC</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncC:</span><br><span class="line">   0x000055555555471a &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x000055555555471b &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x000055555555471e &lt;+4&gt;:     sub    <span class="variable">$0x60</span>,%rsp</span><br><span class="line">   0x0000555555554722 &lt;+8&gt;:     movl   <span class="variable">$0x900c</span>,-0x4(%rbp)</span><br><span class="line">   0x0000555555554729 &lt;+15&gt;:    mov    <span class="variable">$0x8</span>,%edi</span><br><span class="line">   0x000055555555472e &lt;+20&gt;:    callq  0x5555555545f0 &lt;malloc@plt&gt;</span><br><span class="line">   0x0000555555554733 &lt;+25&gt;:    mov    %rax,-0x10(%rbp)</span><br><span class="line">   0x0000555555554737 &lt;+29&gt;:    movabs <span class="variable">$0x6f57206f6c6c6548</span>,%rax</span><br><span class="line">   0x0000555555554741 &lt;+39&gt;:    mov    <span class="variable">$0x21646c72</span>,%edx</span><br><span class="line">   0x0000555555554746 &lt;+44&gt;:    mov    %rax,-0x30(%rbp)</span><br><span class="line">   0x000055555555474a &lt;+48&gt;:    mov    %rdx,-0x28(%rbp)</span><br><span class="line">   0x000055555555474e &lt;+52&gt;:    movl   <span class="variable">$0x0</span>,-0x20(%rbp)</span><br><span class="line">   0x0000555555554755 &lt;+59&gt;:    movq   <span class="variable">$0x0</span>,-0x60(%rbp)</span><br><span class="line">   0x000055555555475d &lt;+67&gt;:    movq   <span class="variable">$0x0</span>,-0x58(%rbp)</span><br><span class="line">   0x0000555555554765 &lt;+75&gt;:    movq   <span class="variable">$0x0</span>,-0x50(%rbp)</span><br><span class="line">   0x000055555555476d &lt;+83&gt;:    movq   <span class="variable">$0x0</span>,-0x48(%rbp)</span><br><span class="line">   0x0000555555554775 &lt;+91&gt;:    movq   <span class="variable">$0x0</span>,-0x40(%rbp)</span><br><span class="line">   0x000055555555477d &lt;+99&gt;:    lea    -0x60(%rbp),%rax</span><br><span class="line">   0x0000555555554781 &lt;+103&gt;:   mov    <span class="variable">$0x64</span>,%edx</span><br><span class="line">   0x0000555555554786 &lt;+108&gt;:   mov    <span class="variable">$0x63</span>,%esi</span><br><span class="line">   0x000055555555478b &lt;+113&gt;:   mov    %rax,%rdi</span><br><span class="line">   0x000055555555478e &lt;+116&gt;:   callq  0x5555555545e0 &lt;memset@plt&gt;</span><br><span class="line">   0x0000555555554793 &lt;+121&gt;:   mov    -0x10(%rbp),%rax</span><br><span class="line">   0x0000555555554797 &lt;+125&gt;:   mov    %rax,%rdi</span><br><span class="line">   0x000055555555479a &lt;+128&gt;:   callq  0x5555555545c0 &lt;free@plt&gt;</span><br><span class="line">   0x000055555555479f &lt;+133&gt;:   movq   <span class="variable">$0x0</span>,-0x10(%rbp)</span><br><span class="line">   0x00005555555547a7 &lt;+141&gt;:   mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x00005555555547ac &lt;+146&gt;:   leaveq</span><br><span class="line">   0x00005555555547ad &lt;+147&gt;:   retq</span><br></pre></td></tr></table></figure><h6 id="2-push开栈">2. push开栈</h6><p>开栈大小 = 96字节，rsp是栈顶，rbp是栈底。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x000055555555471a &lt;+0&gt;:     push   %rbp</span><br><span class="line">0x000055555555471b &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">0x000055555555471e &lt;+4&gt;:     sub    <span class="variable">$0x60</span>,%rsp</span><br><span class="line">(gdb) i r <span class="variable">$rsp</span> <span class="variable">$rbp</span></span><br><span class="line">rsp            0x7fffffffe330   0x7fffffffe330</span><br><span class="line">rbp            0x7fffffffe390   0x7fffffffe390</span><br></pre></td></tr></table></figure><h6 id="3-将0x900c存入rbp-4的地址，对应代码第3行。">3. 将0x900c存入rbp - 4的地址，对应代码第3行。</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x0000555555554722 &lt;+8&gt;:     movl   <span class="variable">$0x900c</span>,-0x4(%rbp)</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0xf7ffea98      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0xffffffff      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0xf7ffa268      0x00007fff      0xf7ffe710      0x00007fff</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x00000000      0x00000000      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure><h6 id="4-将edi赋值成8，作为malloc的第一个入参。malloc的结果rax存入rbp-16的地址。对应代码第4行。">4. 将edi赋值成8，作为malloc的第一个入参。malloc的结果rax存入rbp-16的地址。对应代码第4行。</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x0000555555554729 &lt;+15&gt;:    mov    <span class="variable">$0x8</span>,%edi</span><br><span class="line">0x000055555555472e &lt;+20&gt;:    callq  0x5555555545f0 &lt;malloc@plt&gt;</span><br><span class="line">0x0000555555554733 &lt;+25&gt;:    mov    %rax,-0x10(%rbp)</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0xf7ffea98      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0xffffffff      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0xf7ffa268      0x00007fff      0xf7ffe710      0x00007fff</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x55756260      0x00005555      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure><h6 id="5-将0x6f57206f6c6c6548存入rax，将0x21646c72存入edx，rax存入rbp-48的地址，rdx存入rbp-40的地址，最后四字节补0，对应代码第5行。">5. 将0x6f57206f6c6c6548存入rax，将0x21646c72存入edx，rax存入rbp-48的地址，rdx存入rbp-40的地址，最后四字节补0，对应代码第5行。</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">48  65  6c  6c  6f  20  57  6f  72  6c  64  21</span><br><span class="line"><span class="string">&#x27;H&#x27;</span> <span class="string">&#x27;e&#x27;</span> <span class="string">&#x27;l&#x27;</span> <span class="string">&#x27;l&#x27;</span> <span class="string">&#x27;o&#x27;</span> <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;W&#x27;</span> <span class="string">&#x27;o&#x27;</span> <span class="string">&#x27;r&#x27;</span> <span class="string">&#x27;l&#x27;</span> <span class="string">&#x27;d&#x27;</span> <span class="string">&#x27;!&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0x0000555555554737 &lt;+29&gt;:    movabs <span class="variable">$0x6f57206f6c6c6548</span>,%rax</span><br><span class="line">0x0000555555554741 &lt;+39&gt;:    mov    <span class="variable">$0x21646c72</span>,%edx</span><br><span class="line">0x0000555555554746 &lt;+44&gt;:    mov    %rax,-0x30(%rbp)</span><br><span class="line">0x000055555555474a &lt;+48&gt;:    mov    %rdx,-0x28(%rbp)</span><br><span class="line">0x000055555555474e &lt;+52&gt;:    movl   <span class="variable">$0x0</span>,-0x20(%rbp)</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0xf7ffea98      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0xffffffff      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x55756260      0x00005555      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure><h6 id="6-从rbp-96的地址开始，依次将连续的40字节设置成0，对应代码第6行。">6. 从rbp-96的地址开始，依次将连续的40字节设置成0，对应代码第6行。</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x0000555555554755 &lt;+59&gt;:    movq   <span class="variable">$0x0</span>,-0x60(%rbp)</span><br><span class="line">0x000055555555475d &lt;+67&gt;:    movq   <span class="variable">$0x0</span>,-0x58(%rbp)</span><br><span class="line">0x0000555555554765 &lt;+75&gt;:    movq   <span class="variable">$0x0</span>,-0x50(%rbp)</span><br><span class="line">0x000055555555476d &lt;+83&gt;:    movq   <span class="variable">$0x0</span>,-0x48(%rbp)</span><br><span class="line">0x0000555555554775 &lt;+91&gt;:    movq   <span class="variable">$0x0</span>,-0x40(%rbp)</span><br><span class="line">0x7fffffffe330: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x55756260      0x00005555      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure><h6 id="7-从rbp-96的地址开始，依次将连续的100字节设置成’c’，对应代码第7行。（这里构造了踩栈）">7. 从rbp-96的地址开始，依次将连续的100字节设置成’c’，对应代码第7行。（这里构造了踩栈）</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0x000055555555477d &lt;+99&gt;:    lea    -0x60(%rbp),%rax</span><br><span class="line">0x0000555555554781 &lt;+103&gt;:   mov    <span class="variable">$0x64</span>,%edx</span><br><span class="line">0x0000555555554786 &lt;+108&gt;:   mov    <span class="variable">$0x63</span>,%esi</span><br><span class="line">0x000055555555478b &lt;+113&gt;:   mov    %rax,%rdi</span><br><span class="line">0x000055555555478e &lt;+116&gt;:   callq  0x5555555545e0 &lt;memset@plt&gt;</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe340: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe350: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe360: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe370: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe380: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe390: 0x63636363      0x00007fff</span><br></pre></td></tr></table></figure><h6 id="8-对应代码第8行，由于构造了踩栈，指针b被踩，free非法指针会异常。">8. 对应代码第8行，由于构造了踩栈，指针b被踩，free非法指针会异常。</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0x0000555555554793 &lt;+121&gt;:   mov    -0x10(%rbp),%rax</span><br><span class="line">0x0000555555554797 &lt;+125&gt;:   mov    %rax,%rdi</span><br><span class="line">0x000055555555479a &lt;+128&gt;:   callq  0x5555555545c0 &lt;free@plt&gt;</span><br><span class="line">(gdb) ni</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">__GI___libc_free (mem=0x6363636363636363) at malloc.c:3113</span><br><span class="line">3113    malloc.c: No such file or directory.</span><br><span class="line">(gdb) i r</span><br><span class="line">rax            0x0      0</span><br><span class="line">rbx            0x0      0</span><br><span class="line">rcx            0x555555756260   93824994337376</span><br><span class="line">rdx            0x64     100</span><br><span class="line">rsi            0x63     99</span><br><span class="line">rdi            0x6363636363636363       7161677110969590627</span><br><span class="line">rbp            0x7fffffffe390   0x7fffffffe390</span><br><span class="line">rsp            0x7fffffffe2c0   0x7fffffffe2c0</span><br><span class="line">r8             0x2      2</span><br><span class="line">r9             0x0      0</span><br><span class="line">r10            0x555555756010   93824994336784</span><br><span class="line">r11            0x0      0</span><br><span class="line">r12            0x6363636363636363       7161677110969590627</span><br><span class="line">r13            0x7fffffffe4d0   140737488348368</span><br><span class="line">r14            0x0      0</span><br><span class="line">r15            0x0      0</span><br><span class="line">rip            0x7ffff7a7994d   0x7ffff7a7994d &lt;__GI___libc_free+61&gt;</span><br><span class="line">eflags         0x10206  [ PF IF RF ]</span><br><span class="line">cs             0x33     51</span><br><span class="line">ss             0x2b     43</span><br><span class="line">ds             0x0      0</span><br><span class="line">es             0x0      0</span><br><span class="line">fs             0x0      0</span><br><span class="line">gs             0x0      0</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  __GI___libc_free (mem=0x6363636363636363) at malloc.c:3113</span></span><br><span class="line"><span class="comment">#1  0x000055555555479f in FuncC () at demo.c:12</span></span><br><span class="line"><span class="comment">#2  0x00005555555547c7 in FuncB () at demo.c:20</span></span><br></pre></td></tr></table></figure><h6 id="9-对应代码第9行">9. 对应代码第9行</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x000055555555479f &lt;+133&gt;:   movq   <span class="variable">$0x0</span>,-0x10(%rbp)</span><br><span class="line">0x00005555555547a7 &lt;+141&gt;:   mov    <span class="variable">$0x0</span>,%eax</span><br></pre></td></tr></table></figure><h6 id="10-eax-rax作为函数的返回值，对应代码第10行">10. eax/rax作为函数的返回值，对应代码第10行</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x00005555555547a7 &lt;+141&gt;:   mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">0x00005555555547ac &lt;+146&gt;:   leaveq</span><br><span class="line">0x00005555555547ad &lt;+147&gt;:   retq</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> assembly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb使用</title>
      <link href="/zhoukaiqi/how-to-use-gdb/"/>
      <url>/zhoukaiqi/how-to-use-gdb/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了gdb的常见用法。</p><span id="more"></span><h6 id="1、入参与返回值">1、入参与返回值</h6><table><thead><tr><th style="text-align:left">CPU</th><th style="text-align:left">入参</th><th style="text-align:left">返回值</th></tr></thead><tbody><tr><td style="text-align:left">x86</td><td style="text-align:left">ebp+8, ebp+12, ebp+16, ebp+20</td><td style="text-align:left">eax</td></tr><tr><td style="text-align:left">x86_64</td><td style="text-align:left">rdi, rsi, rdx, rcx, r8, r9</td><td style="text-align:left">rax</td></tr><tr><td style="text-align:left">arm64</td><td style="text-align:left">x0, x1, x2, x3, x4, x5, x6, x7</td><td style="text-align:left">x0</td></tr></tbody></table><p>返回值需要在执行finish后查看</p><h6 id="2、常见命令">2、常见命令</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gdb -q bin                                   // 启动时不显示提示信息</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint    // 屏蔽某些信号</span><br><span class="line"><span class="built_in">set</span> height 0                                 // 不限制输出行数</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> pretty on                          // 美化结构体打印</span><br><span class="line">i thread                                     // 查看所有线程信息</span><br><span class="line">thread threadno                              // 切换到指定线程</span><br><span class="line">thread apply all bt                          // 查看所有线程栈信息</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;Handle[%u], PtNo[%u]\n&quot;</span>, <span class="variable">$rdi</span>, <span class="variable">$rsi</span>  // 打印信息</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> thread-events off                  // 不显示线程启动和退出信息</span><br><span class="line">call getpid()                                // 获取拉起进程的pid</span><br><span class="line">shell <span class="built_in">date</span> +%H:%M:%S.%N                      // 加shell可以执行linux命令</span><br><span class="line">i r                                          // 查看寄存器信息</span><br><span class="line">generate-core-file                           // 生成core文件</span><br><span class="line">bt n(-n)                                     // 显示栈顶(栈底)的n层栈</span><br><span class="line">x addr                                       // 解析addr对应的函数</span><br><span class="line">x/s str                                      // 显示str对应的字符串</span><br><span class="line">x/nbx                                        // 显示n个单字节</span><br><span class="line">x/nhx                                        // 显示n个双字节</span><br><span class="line">x/nwx                                        // 显示n个4字节</span><br><span class="line">x/ngx                                        // 显示n个8字节</span><br><span class="line">frame n                                      // 切换到第n层栈帧</span><br></pre></td></tr></table></figure><h6 id="3、条件断点">3、条件断点</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x86 32位:  b func <span class="keyword">if</span> *(unsigned int*)(<span class="variable">$ebp</span>+8) == 226 &amp;&amp; *(unsigned int*)(<span class="variable">$ebp</span>+16) == 206</span><br><span class="line">x86 64位:  b func <span class="keyword">if</span> <span class="variable">$rdi</span> == 226 &amp;&amp; <span class="variable">$rdx</span> == 206</span><br><span class="line">arm 64位:  b func <span class="keyword">if</span> <span class="variable">$x0</span> == 226 &amp;&amp; <span class="variable">$x2</span> == 206</span><br><span class="line">线程断点:  b func thread threadno <span class="keyword">if</span> condition</span><br><span class="line">字符断点:  b func <span class="keyword">if</span> *(unsigned char*)(<span class="variable">$ebp</span>+8)==<span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><h6 id="4、查看调用栈">4、查看调用栈</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb attach 10889</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height 0</span><br><span class="line">b func</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">bt</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure><h6 id="5、查看入参和返回值">5、查看入参和返回值</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">gdb attach pid   ----------//进程的pid由ps -ef | grep xxx查询到</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height 0</span><br><span class="line">define oops</span><br><span class="line">bt        ----------// 显示调用栈</span><br><span class="line">i r       ----------// 显示寄存器信息，主要看入参，x86 32位进程看入参要替换成x/8wx <span class="variable">$ebp</span>+8</span><br><span class="line">fin       ----------// 表示执行完当前打断点的函数func</span><br><span class="line">i r       ----------// 在fin之后表示显示返回值，x86，x86_64，arm的返回值依次对应eax,rax,x0</span><br><span class="line">det</span><br><span class="line">q</span><br><span class="line">end</span><br><span class="line">b func    ----------// func即打断点的函数</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">oops</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure><h6 id="6、查看出参">6、查看出参</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">gdb attach `pidof demo`</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> heigh 0</span><br><span class="line">define ops</span><br><span class="line">bt</span><br><span class="line">i r</span><br><span class="line">x/s <span class="variable">$rdi</span></span><br><span class="line">p <span class="variable">$rsi</span></span><br><span class="line"><span class="built_in">set</span> <span class="variable">$a</span>=<span class="variable">$rdx</span></span><br><span class="line">fin</span><br><span class="line">x/5wx <span class="variable">$a</span></span><br><span class="line">x/s <span class="variable">$a</span></span><br><span class="line">p *(unsigned int*)(<span class="variable">$a</span>+16)</span><br><span class="line">det</span><br><span class="line">q</span><br><span class="line">end</span><br><span class="line">b func</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">ops</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure><h6 id="7、在函数func2执行之后再执行函数func1">7、在函数<code>func2</code>执行之后再执行函数<code>func1</code></h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gdb attach `pidof demo`</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height 0</span><br><span class="line">b func1</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">bt</span><br><span class="line">det</span><br><span class="line">q</span><br><span class="line">end</span><br><span class="line"><span class="built_in">disable</span> 1</span><br><span class="line">b func2</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="built_in">enable</span> 1</span><br><span class="line">bt</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure><h6 id="8、扫描core文件">8、扫描core文件</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">define mem_scan</span><br><span class="line">    <span class="built_in">set</span> logging file xxx.txt</span><br><span class="line">    <span class="built_in">set</span> logging on</span><br><span class="line">    <span class="built_in">set</span> logging overwrite on</span><br><span class="line">    <span class="built_in">set</span> height 0</span><br><span class="line">    <span class="built_in">set</span> <span class="built_in">print</span> pretty on</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$g_index</span> = 0</span><br><span class="line">    <span class="keyword">while</span> (xxx)</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;**************************\n&quot;</span></span><br><span class="line">        // 具体扫描实现</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;**************************\n&quot;</span></span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">set</span> logging off</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">mem_scan</span><br></pre></td></tr></table></figure><p>参考：<a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/info-function.html">https://wizardforcel.gitbooks.io/100-gdb-tips/content/info-function.html</a></p>]]></content>
      
      
      <categories>
          
          <category> gdb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
