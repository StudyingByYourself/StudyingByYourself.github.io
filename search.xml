<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>x86_64模拟arm环境</title>
    <url>/zhoukaiqi/eb93f416377a/</url>
    <content><![CDATA[<h6 id="1-安装arm交叉编译工具链">1.安装arm交叉编译工具链</h6>
<p>安装交叉编译工具链 <code>gcc-aarch64-linux-gnu</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>
<p>建立软链接，否则后面执行的时候会报动态库找不到的错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/aarch64-linux-gnu/lib/libc.so.6 /lib/libc.so.6</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/aarch64-linux-gnu/lib/ld-linux-aarch64.so.1 /lib/ld-linux-aarch64.so.1</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h6 id="2-安装arm模拟器qemu">2.安装arm模拟器qemu</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br></pre></td></tr></table></figure>
<p>编译<code>a.out</code>并执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zkq@zkq-vm:~$ aarch64-linux-gnu-gcc main.c</span><br><span class="line">zkq@zkq-vm:~$ file a.out</span><br><span class="line">a.out: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, <span class="keyword">for</span> GNU/Linux 3.7.0, BuildID[sha1]=6ef0ca0c6462e038e589b6e1d52220a680007588, not stripped</span><br><span class="line">zkq@zkq-vm:~$ qemu-aarch64 a.out</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h6 id="3-通过gdb调试arm程序">3.通过gdb调试arm程序</h6>
<p>gdb调试arm程序的原理：qemu端作为gdb server启动可执行程序，另一端作为gdb client连接gdb server，进行本地远程调试。</p>
<p>首先安装多平台的gdb工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gdb-multiarch</span><br></pre></td></tr></table></figure>
<p>重新编译示例代码<code>main.c</code>，注意，这次加上了参数<code>--static</code>。加上这个参数后，生成的可执行文件为静态链接的。<strong>如果不加这个参数，gdb调试的时候单步执行功能不正常，符号表也找不到。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc --static -g main.c</span><br></pre></td></tr></table></figure>
<p>通过下面的命令启动可执行程序<code>a.out</code>, 选项<code>-g</code>指明了gdb的监听端口，这里选择的是1234。该指令运行后，当前窗口会被阻塞住。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-aarch64 -g 1234 a.out</span><br></pre></td></tr></table></figure>
<p>新开一个命令行窗口，启动gdb client，进入gdb交互界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-multiarch a.out</span><br></pre></td></tr></table></figure>
<p>在gdb交互界面输入以下内容就可以连接到server端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>
<p>接下来，就可以正常使用gdb的相关功能调试程序了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x102e8: file main.c, line 5.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:5</span><br><span class="line">5	    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>main.c中必须有main函数，否则执行<code>qemu-aarch64 -g 1234 a.out</code>会报<code>Invalid ELF image for this architecture</code></p>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
  </entry>
  <entry>
    <title>arm64常见汇编指令</title>
    <url>/zhoukaiqi/88508989b720/</url>
    <content><![CDATA[<p>本文介绍了arm64常见汇编指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th></th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov</td>
<td>mov x1, x0</td>
<td>将寄存器x0的值复制给寄存器x1</td>
</tr>
<tr>
<td>movk</td>
<td>movk x0, #1234, lsl #16</td>
<td>lsl：向左移位，即x0 = 0x12340000</td>
</tr>
<tr>
<td>stp</td>
<td>x29, x30, [sp, #-112]</td>
<td>sp = sp - 112，将x29, x30依次存入sp的位置; <br>x29充当FP寄存器，用于保存上一个sp; <br>x30充当LR寄存器，用来保存函数返回后的下一条执行地址</td>
</tr>
<tr>
<td>ldp</td>
<td>ldp     x29, x30, [sp], #112</td>
<td>sp取值赋给x29, sp + 8取值赋给x30, sp = sp + 112</td>
</tr>
<tr>
<td>str</td>
<td>str     w0, [x29, #40]</td>
<td>w0寄存器存入x29+40的内存地址</td>
</tr>
<tr>
<td>stur</td>
<td>stur    wzr, [x29, #93]</td>
<td>xzr/wzr分别代表8字节/4字节的0, 0x00000000写入x29+93的内存地址; <br/>sturh(2字节)，sturb(1字节)</td>
</tr>
<tr>
<td>add</td>
<td>add     x0, x29, #0x28</td>
<td>x29与0x28相加后赋值给x0</td>
</tr>
<tr>
<td>ldr</td>
<td>ldr     x2, [x1]</td>
<td>将x1作为地址，取该内存地址的值存入x2寄存器</td>
</tr>
<tr>
<td>eor</td>
<td>eor     x1, x2, x1</td>
<td>异或指令, x1 = x2 ^ x1</td>
</tr>
<tr>
<td>cbz</td>
<td>cbz w0, 0x687f70</td>
<td>与0相等则跳转到0x687f70</td>
</tr>
<tr>
<td>cbnz</td>
<td>cbz x1, 0x687f78</td>
<td>不与0相等则跳转到0x687f78</td>
</tr>
</tbody>
</table>
<p>保存入参的寄存器：<code>x0 - x7</code> 依次对应第1到第8个参数</p>
<p>保存返回值的寄存器： <code>x0</code></p>
<span id="more"></span>
<p>以demo.c为例，分析arm下的汇编指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FuncC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x900C</span>;</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="string">&#x27;c&#x27;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">40</span>);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="1-完整指令">1. 完整指令</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncC</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncC:</span><br><span class="line">   0x0000aaaaaaaaa8d4 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">   0x0000aaaaaaaaa8d8 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">   0x0000aaaaaaaaa8dc &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa8e0 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa8e4 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">   0x0000aaaaaaaaa8e8 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa8ec &lt;+24&gt;:    mov     x1, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa8f0 &lt;+28&gt;:    mov     w0, <span class="comment">#0x900c                     // #36876</span></span><br><span class="line">   0x0000aaaaaaaaa8f4 &lt;+32&gt;:    str     w0, [x29, <span class="comment">#28]</span></span><br><span class="line">   0x0000aaaaaaaaa8f8 &lt;+36&gt;:    mov     x0, <span class="comment">#0x8                        // #8</span></span><br><span class="line">   0x0000aaaaaaaaa8fc &lt;+40&gt;:    bl      0xaaaaaaaaa750 &lt;malloc@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa900 &lt;+44&gt;:    str     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa904 &lt;+48&gt;:    adrp    x0, 0xaaaaaaaaa000</span><br><span class="line">   0x0000aaaaaaaaa908 &lt;+52&gt;:    add     x1, x0, <span class="comment">#0xa98</span></span><br><span class="line">   0x0000aaaaaaaaa90c &lt;+56&gt;:    add     x0, x29, <span class="comment">#0x50</span></span><br><span class="line">   0x0000aaaaaaaaa910 &lt;+60&gt;:    ldr     x2, [x1]</span><br><span class="line">   0x0000aaaaaaaaa914 &lt;+64&gt;:    str     x2, [x0]</span><br><span class="line">   0x0000aaaaaaaaa918 &lt;+68&gt;:    ldur    x1, [x1, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa91c &lt;+72&gt;:    stur    x1, [x0, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa920 &lt;+76&gt;:    stur    wzr, [x29, <span class="comment">#93]</span></span><br><span class="line">   0x0000aaaaaaaaa924 &lt;+80&gt;:    sturh   wzr, [x29, <span class="comment">#97]</span></span><br><span class="line">   0x0000aaaaaaaaa928 &lt;+84&gt;:    strb    wzr, [x29, <span class="comment">#99]</span></span><br><span class="line">   0x0000aaaaaaaaa92c &lt;+88&gt;:    stp     xzr, xzr, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa930 &lt;+92&gt;:    stp     xzr, xzr, [x29, <span class="comment">#56]</span></span><br><span class="line">   0x0000aaaaaaaaa934 &lt;+96&gt;:    str     xzr, [x29, <span class="comment">#72]</span></span><br><span class="line">   0x0000aaaaaaaaa938 &lt;+100&gt;:   mov     w0, <span class="comment">#0x1                        // #1</span></span><br><span class="line">   0x0000aaaaaaaaa93c &lt;+104&gt;:   str     w0, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa940 &lt;+108&gt;:   add     x0, x29, <span class="comment">#0x28</span></span><br><span class="line">   0x0000aaaaaaaaa944 &lt;+112&gt;:   mov     x2, <span class="comment">#0x28                       // #40</span></span><br><span class="line">   0x0000aaaaaaaaa948 &lt;+116&gt;:   mov     w1, <span class="comment">#0x63                       // #99</span></span><br><span class="line">   0x0000aaaaaaaaa94c &lt;+120&gt;:   bl      0xaaaaaaaaa770 &lt;memset@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa950 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa954 &lt;+128&gt;:   bl      0xaaaaaaaaa7b0 &lt;free@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa958 &lt;+132&gt;:   str     xzr, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa95c &lt;+136&gt;:   mov     w0, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa960 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa964 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa968 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa96c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">   0x0000aaaaaaaaa970 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">   0x0000aaaaaaaaa974 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">   0x0000aaaaaaaaa978 &lt;+164&gt;:   b.eq    0xaaaaaaaaa980 &lt;FuncC+172&gt;  // b.none</span><br><span class="line">   0x0000aaaaaaaaa97c &lt;+168&gt;:   bl      0xaaaaaaaaa780 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa980 &lt;+172&gt;:   ldp     x29, x30, [sp], <span class="comment">#112</span></span><br><span class="line">   0x0000aaaaaaaaa984 &lt;+176&gt;:   ret</span><br></pre></td></tr></table></figure>
<h6 id="2-开栈">2. 开栈</h6>
<p>sp从0xfffffffff9f0偏移-112字节到0xfffffffff980，先存入x29，再存入x30，同时将sp赋值给x29。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) i r x29 x30 sp</span><br><span class="line">x29            0xfffffffff9f0   281474976709104</span><br><span class="line">x30            0xaaaaaaaaa998   187649984473496</span><br><span class="line">sp             0xfffffffff9f0   0xfffffffff9f0</span><br><span class="line">0x0000aaaaaaaaa8d4 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">0x0000aaaaaaaaa8d8 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">(gdb) i r x29 x30 sp</span><br><span class="line">x29            0xfffffffff980   281474976708992</span><br><span class="line">x30            0xaaaaaaaaa998   187649984473496</span><br><span class="line">sp             0xfffffffff980   0xfffffffff980</span><br><span class="line">(gdb) x/8wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0xfffffffff990: 0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>
<h6 id="3-入栈时存栈保护canary">3. 入栈时存栈保护canary</h6>
<p>adrp指令这里不展开。以下指令主要是将栈保护的<code>canary</code>存入栈中，后续出栈前校验。（编译选项：<code>-fstack-protector</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa8dc &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">0x0000aaaaaaaaa8e0 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">0x0000aaaaaaaaa8e4 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">0x0000aaaaaaaaa8e8 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">0x0000aaaaaaaaa8ec &lt;+24&gt;:    mov     x1, <span class="comment">#0x0                        // #0</span></span><br><span class="line">(gdb) x/gx <span class="variable">$x0</span></span><br><span class="line">0xfffff7ffd7a8 &lt;__stack_chk_guard&gt;:     0x9af4bd74875a3200</span><br><span class="line">(gdb) x/2wx <span class="variable">$sp</span> + 104</span><br><span class="line">0xfffffffff9e8: 0x875a3200      0x9af4bd74</span><br></pre></td></tr></table></figure>
<h6 id="4-将0x900c存入x29-28的内存地址，对应代码第3行">4. 将0x900c存入x29+28的内存地址，对应代码第3行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa8f0 &lt;+28&gt;:    mov     w0, <span class="comment">#0x900c                     // #36876</span></span><br><span class="line">0x0000aaaaaaaaa8f4 &lt;+32&gt;:    str     w0, [x29, <span class="comment">#28]</span></span><br><span class="line">(gdb) x/8wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0xfffffffff990: 0x00000000      0x00000000      0x00000000      0x0000900c</span><br></pre></td></tr></table></figure>
<h6 id="5-申请8字节内存，内存的起始地址存入x29-32的内存地址，对应代码第4行">5. 申请8字节内存，内存的起始地址存入x29+32的内存地址，对应代码第4行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa8f8 &lt;+36&gt;:    mov     x0, <span class="comment">#0x8                        // #8</span></span><br><span class="line">0x0000aaaaaaaaa8fc &lt;+40&gt;:    bl      0xaaaaaaaaa750 &lt;malloc@plt&gt;</span><br><span class="line">0x0000aaaaaaaaa900 &lt;+44&gt;:    str     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">(gdb) i r x0</span><br><span class="line">x0             0xaaaaaaabc260   187649984545376</span><br><span class="line">(gdb) x/12wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0xfffffffff990: 0x00000000      0x00000000      0x00000000      0x0000900c</span><br><span class="line">0xfffffffff9a0: 0xaaabc260      0x0000aaaa      0x00000000      0x00000000</span><br></pre></td></tr></table></figure>
<h6 id="6-对应代码第5行">6. 对应代码第5行</h6>
<p>字符串长度是20字节</p>
<p>前12字节：为了字节对齐，第一次拷贝8字节，偏移到第5字节再拷贝8字节   from <code>ldr     x2, [x1]</code> to <code>ldur    x1, [x1, #5]</code></p>
<p>第13字节：字符串的结尾需要赋值&quot;\0&quot;  <code>stur    wzr, [x29, #93]</code></p>
<p>后面7字节：用&quot;\0&quot;补齐</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa904 &lt;+48&gt;:    adrp    x0, 0xaaaaaaaaa000</span><br><span class="line">0x0000aaaaaaaaa908 &lt;+52&gt;:    add     x1, x0, <span class="comment">#0xa98</span></span><br><span class="line">0x0000aaaaaaaaa90c &lt;+56&gt;:    add     x0, x29, <span class="comment">#0x50</span></span><br><span class="line">(gdb) i r <span class="variable">$x0</span></span><br><span class="line">x0             0xfffffffff9d0   281474976709072</span><br><span class="line">(gdb) x/4wx <span class="variable">$x1</span></span><br><span class="line">0xaaaaaaaaaa98: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">(gdb) x/s <span class="variable">$x1</span></span><br><span class="line">0xaaaaaaaaaa98: <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">0x0000aaaaaaaaa910 &lt;+60&gt;:    ldr     x2, [x1]</span><br><span class="line">0x0000aaaaaaaaa914 &lt;+64&gt;:    str     x2, [x0]</span><br><span class="line">(gdb) x/4wx <span class="variable">$sp</span> + 80</span><br><span class="line">0xfffffffff9d0: 0x6c6c6548      0x6f57206f      0x00000000      0x00000000</span><br><span class="line">0x0000aaaaaaaaa918 &lt;+68&gt;:    ldur    x1, [x1, <span class="comment">#5]</span></span><br><span class="line">0x0000aaaaaaaaa91c &lt;+72&gt;:    stur    x1, [x0, <span class="comment">#5]</span></span><br><span class="line">(gdb) x/5wx <span class="variable">$sp</span> + 80</span><br><span class="line">0xfffffffff9d0: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0xfffffffff9e0: 0xf7fffac8</span><br><span class="line">0x0000aaaaaaaaa920 &lt;+76&gt;:    stur    wzr, [x29, <span class="comment">#93]</span></span><br><span class="line">0x0000aaaaaaaaa924 &lt;+80&gt;:    sturh   wzr, [x29, <span class="comment">#97]</span></span><br><span class="line">0x0000aaaaaaaaa928 &lt;+84&gt;:    strb    wzr, [x29, <span class="comment">#99]</span></span><br><span class="line">(gdb) x/5wx <span class="variable">$sp</span> + 80</span><br><span class="line">0xfffffffff9d0: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0xfffffffff9e0: 0x00000000</span><br></pre></td></tr></table></figure>
<h6 id="7-对应代码第6行">7. 对应代码第6行</h6>
<p><code>stp     xzr, xzr, [x29, #40]</code> 连续拷贝16字节0到[x29, #40]，可以考虑用SSE指令加速。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa92c &lt;+88&gt;:    stp     xzr, xzr, [x29, <span class="comment">#40]</span></span><br><span class="line">0x0000aaaaaaaaa930 &lt;+92&gt;:    stp     xzr, xzr, [x29, <span class="comment">#56]</span></span><br><span class="line">0x0000aaaaaaaaa934 &lt;+96&gt;:    str     xzr, [x29, <span class="comment">#72]</span></span><br><span class="line">0x0000aaaaaaaaa938 &lt;+100&gt;:   mov     w0, <span class="comment">#0x1                        // #1</span></span><br><span class="line">0x0000aaaaaaaaa93c &lt;+104&gt;:   str     w0, [x29, <span class="comment">#40]</span></span><br></pre></td></tr></table></figure>
<h6 id="8-对应代码第7行">8. 对应代码第7行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa940 &lt;+108&gt;:   add     x0, x29, <span class="comment">#0x28                        </span></span><br><span class="line">0x0000aaaaaaaaa944 &lt;+112&gt;:   mov     x2, <span class="comment">#0x28                       // #40</span></span><br><span class="line">0x0000aaaaaaaaa948 &lt;+116&gt;:   mov     w1, <span class="comment">#0x63                       // #99</span></span><br><span class="line">0x0000aaaaaaaaa94c &lt;+120&gt;:   bl      0xaaaaaaaaa770 &lt;memset@plt&gt;           </span><br></pre></td></tr></table></figure>
<h6 id="9-对应代码第8和第9行">9. 对应代码第8和第9行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa950 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]           </span></span><br><span class="line">0x0000aaaaaaaaa954 &lt;+128&gt;:   bl      0xaaaaaaaaa7b0 &lt;free@plt&gt;</span><br><span class="line">0x0000aaaaaaaaa958 &lt;+132&gt;:   str     xzr, [x29, <span class="comment">#32]</span></span><br></pre></td></tr></table></figure>
<h6 id="10-出栈前校验栈保护canary">10. 出栈前校验栈保护canary</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000aaaaaaaaa960 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000      </span><br><span class="line">0x0000aaaaaaaaa964 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">0x0000aaaaaaaaa968 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">0x0000aaaaaaaaa96c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">0x0000aaaaaaaaa970 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">0x0000aaaaaaaaa974 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">0x0000aaaaaaaaa978 &lt;+164&gt;:   b.eq    0xaaaaaaaaa980 &lt;FuncC+172&gt;  // b.none</span><br><span class="line">0x0000aaaaaaaaa97c &lt;+168&gt;:   bl      0xaaaaaaaaa780 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure>
<h6 id="11-出栈">11. 出栈</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) i r <span class="variable">$x29</span> <span class="variable">$x30</span> <span class="variable">$sp</span></span><br><span class="line">x29            0xfffffffff980   281474976708992</span><br><span class="line">x30            0xaaaaaaaaa958   187649984473432</span><br><span class="line">sp             0xfffffffff980   0xfffffffff980</span><br><span class="line">(gdb) x/4wx <span class="variable">$sp</span></span><br><span class="line">0xfffffffff980: 0xfffff9f0      0x0000ffff      0xaaaaa998      0x0000aaaa</span><br><span class="line">0x0000aaaaaaaaa980 &lt;+172&gt;:   ldp     x29, x30, [sp], <span class="comment">#112</span></span><br><span class="line">(gdb) i r <span class="variable">$x29</span> <span class="variable">$x30</span> <span class="variable">$sp</span></span><br><span class="line">x29            0xfffffffff9f0   281474976709104</span><br><span class="line">x30            0xaaaaaaaaa998   187649984473496</span><br><span class="line">sp             0xfffffffff9f0   0xfffffffff9f0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>x86_84常见汇编指令</title>
    <url>/zhoukaiqi/1d4d4cadb785/</url>
    <content><![CDATA[<p>本文介绍了x86_84常见汇编指令</p>
<table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th></th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>lea</td>
<td>leaq a(b, c, d), %rax</td>
<td>先计算地址a + b + c * d，然后把最终地址赋值给寄存器rax</td>
</tr>
<tr>
<td>shr</td>
<td>$0x4, %rdi</td>
<td>右移：rdi &gt;&gt; 4</td>
</tr>
<tr>
<td>mov</td>
<td>mov    %rax,-0x10(%rbp)</td>
<td>将rax载入rbp-16的地址，变型：movb, movq, movl, movq</td>
</tr>
<tr>
<td>movz</td>
<td>movzwl %dx %eax</td>
<td>将源操作数做零扩展后，再复制到目的操作数中</td>
</tr>
<tr>
<td>movs</td>
<td>movswl %dx %eax</td>
<td>将源操作数做符号扩展后，再复制到目的操作数中</td>
</tr>
<tr>
<td>movaps</td>
<td>movaps %xmm0, -0x80(%rbp)</td>
<td>SSE指令，一次移动16字节，<code>要求寄存器地址16字节对齐</code></td>
</tr>
<tr>
<td>xor</td>
<td>xor    %eax, %eax</td>
<td>eax清零</td>
</tr>
<tr>
<td>test</td>
<td>test    %eax, %eax</td>
<td>eax与0比较是否相等</td>
</tr>
<tr>
<td>nopl</td>
<td>nopl  0x0(%rax)</td>
<td>冗余指令，为了字节对齐</td>
</tr>
</tbody>
</table>
<p>保存入参的寄存器：<code>rdi, rsi, rdx, rcx, r8, r9</code> 依次对应第一、二、三、四、五、六个参数</p>
<p>保存返回值的寄存器： <code>rax</code></p>
<span id="more"></span>
<p>编译选项需添加<code>-fno-omit-frame-pointer</code>，否则rbp不作为栈帧寄存器使用，无法推栈。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -Q --<span class="built_in">help</span>=optimizers -O2 | grep frame</span><br><span class="line">-fomit-frame-pointer                  [enabled]</span><br></pre></td></tr></table></figure>
<p><font color="#FF0000"> <strong>push rbp的具体实现</strong> </font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsp = rsp - 8</span><br><span class="line">*(unsigned long*)rsp = rbp</span><br></pre></td></tr></table></figure>
<p><font color="#FF0000"> <strong>callq addr的具体实现</strong> </font></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsp = rsp - 8</span><br><span class="line">*(unsigned long*)rsp = rip + sizeof(inst)</span><br><span class="line">rip = addr</span><br></pre></td></tr></table></figure>
<p>以demo.c为例，分析x86_64下的汇编指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FuncC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x900C</span>;</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="string">&#x27;c&#x27;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">100</span>); <span class="comment">//这里构造了踩栈，后续展开</span></span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消栈保护编译选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector -g demo.c -o demo</span><br></pre></td></tr></table></figure>
<h6 id="1-完整指令-2">1. 完整指令</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncC</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncC:</span><br><span class="line">   0x000055555555471a &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x000055555555471b &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x000055555555471e &lt;+4&gt;:     sub    <span class="variable">$0x60</span>,%rsp</span><br><span class="line">   0x0000555555554722 &lt;+8&gt;:     movl   <span class="variable">$0x900c</span>,-0x4(%rbp)</span><br><span class="line">   0x0000555555554729 &lt;+15&gt;:    mov    <span class="variable">$0x8</span>,%edi</span><br><span class="line">   0x000055555555472e &lt;+20&gt;:    callq  0x5555555545f0 &lt;malloc@plt&gt;</span><br><span class="line">   0x0000555555554733 &lt;+25&gt;:    mov    %rax,-0x10(%rbp)</span><br><span class="line">   0x0000555555554737 &lt;+29&gt;:    movabs <span class="variable">$0x6f57206f6c6c6548</span>,%rax</span><br><span class="line">   0x0000555555554741 &lt;+39&gt;:    mov    <span class="variable">$0x21646c72</span>,%edx</span><br><span class="line">   0x0000555555554746 &lt;+44&gt;:    mov    %rax,-0x30(%rbp)</span><br><span class="line">   0x000055555555474a &lt;+48&gt;:    mov    %rdx,-0x28(%rbp)</span><br><span class="line">   0x000055555555474e &lt;+52&gt;:    movl   <span class="variable">$0x0</span>,-0x20(%rbp)</span><br><span class="line">   0x0000555555554755 &lt;+59&gt;:    movq   <span class="variable">$0x0</span>,-0x60(%rbp)</span><br><span class="line">   0x000055555555475d &lt;+67&gt;:    movq   <span class="variable">$0x0</span>,-0x58(%rbp)</span><br><span class="line">   0x0000555555554765 &lt;+75&gt;:    movq   <span class="variable">$0x0</span>,-0x50(%rbp)</span><br><span class="line">   0x000055555555476d &lt;+83&gt;:    movq   <span class="variable">$0x0</span>,-0x48(%rbp)</span><br><span class="line">   0x0000555555554775 &lt;+91&gt;:    movq   <span class="variable">$0x0</span>,-0x40(%rbp)</span><br><span class="line">   0x000055555555477d &lt;+99&gt;:    lea    -0x60(%rbp),%rax</span><br><span class="line">   0x0000555555554781 &lt;+103&gt;:   mov    <span class="variable">$0x64</span>,%edx</span><br><span class="line">   0x0000555555554786 &lt;+108&gt;:   mov    <span class="variable">$0x63</span>,%esi</span><br><span class="line">   0x000055555555478b &lt;+113&gt;:   mov    %rax,%rdi</span><br><span class="line">   0x000055555555478e &lt;+116&gt;:   callq  0x5555555545e0 &lt;memset@plt&gt;</span><br><span class="line">   0x0000555555554793 &lt;+121&gt;:   mov    -0x10(%rbp),%rax</span><br><span class="line">   0x0000555555554797 &lt;+125&gt;:   mov    %rax,%rdi</span><br><span class="line">   0x000055555555479a &lt;+128&gt;:   callq  0x5555555545c0 &lt;free@plt&gt;</span><br><span class="line">   0x000055555555479f &lt;+133&gt;:   movq   <span class="variable">$0x0</span>,-0x10(%rbp)</span><br><span class="line">   0x00005555555547a7 &lt;+141&gt;:   mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">   0x00005555555547ac &lt;+146&gt;:   leaveq</span><br><span class="line">   0x00005555555547ad &lt;+147&gt;:   retq</span><br></pre></td></tr></table></figure>
<h6 id="2-push开栈">2. push开栈</h6>
<p>开栈大小 = 96字节，rsp是栈顶，rbp是栈底。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x000055555555471a &lt;+0&gt;:     push   %rbp</span><br><span class="line">0x000055555555471b &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">0x000055555555471e &lt;+4&gt;:     sub    <span class="variable">$0x60</span>,%rsp</span><br><span class="line">(gdb) i r <span class="variable">$rsp</span> <span class="variable">$rbp</span></span><br><span class="line">rsp            0x7fffffffe330   0x7fffffffe330</span><br><span class="line">rbp            0x7fffffffe390   0x7fffffffe390</span><br></pre></td></tr></table></figure>
<h6 id="3-将0x900c存入rbp-4的地址，对应代码第3行。">3. 将0x900c存入rbp - 4的地址，对应代码第3行。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000555555554722 &lt;+8&gt;:     movl   <span class="variable">$0x900c</span>,-0x4(%rbp)</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0xf7ffea98      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0xffffffff      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0xf7ffa268      0x00007fff      0xf7ffe710      0x00007fff</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x00000000      0x00000000      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure>
<h6 id="4-将edi赋值成8，作为malloc的第一个入参。malloc的结果rax存入rbp-16的地址。对应代码第4行。">4. 将edi赋值成8，作为malloc的第一个入参。malloc的结果rax存入rbp-16的地址。对应代码第4行。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000555555554729 &lt;+15&gt;:    mov    <span class="variable">$0x8</span>,%edi</span><br><span class="line">0x000055555555472e &lt;+20&gt;:    callq  0x5555555545f0 &lt;malloc@plt&gt;</span><br><span class="line">0x0000555555554733 &lt;+25&gt;:    mov    %rax,-0x10(%rbp)</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0xf7ffea98      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0xffffffff      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0xf7ffa268      0x00007fff      0xf7ffe710      0x00007fff</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x55756260      0x00005555      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure>
<h6 id="5-将0x6f57206f6c6c6548存入rax，将0x21646c72存入edx，rax存入rbp-48的地址，rdx存入rbp-40的地址，最后四字节补0，对应代码第5行。">5. 将0x6f57206f6c6c6548存入rax，将0x21646c72存入edx，rax存入rbp-48的地址，rdx存入rbp-40的地址，最后四字节补0，对应代码第5行。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">48  65  6c  6c  6f  20  57  6f  72  6c  64  21</span><br><span class="line"><span class="string">&#x27;H&#x27;</span> <span class="string">&#x27;e&#x27;</span> <span class="string">&#x27;l&#x27;</span> <span class="string">&#x27;l&#x27;</span> <span class="string">&#x27;o&#x27;</span> <span class="string">&#x27; &#x27;</span> <span class="string">&#x27;W&#x27;</span> <span class="string">&#x27;o&#x27;</span> <span class="string">&#x27;r&#x27;</span> <span class="string">&#x27;l&#x27;</span> <span class="string">&#x27;d&#x27;</span> <span class="string">&#x27;!&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000555555554737 &lt;+29&gt;:    movabs <span class="variable">$0x6f57206f6c6c6548</span>,%rax</span><br><span class="line">0x0000555555554741 &lt;+39&gt;:    mov    <span class="variable">$0x21646c72</span>,%edx</span><br><span class="line">0x0000555555554746 &lt;+44&gt;:    mov    %rax,-0x30(%rbp)</span><br><span class="line">0x000055555555474a &lt;+48&gt;:    mov    %rdx,-0x28(%rbp)</span><br><span class="line">0x000055555555474e &lt;+52&gt;:    movl   <span class="variable">$0x0</span>,-0x20(%rbp)</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0xf7ffea98      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0xffffffff      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x55756260      0x00005555      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure>
<h6 id="6-从rbp-96的地址开始，依次将连续的40字节设置成0，对应代码第6行。">6. 从rbp-96的地址开始，依次将连续的40字节设置成0，对应代码第6行。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000555555554755 &lt;+59&gt;:    movq   <span class="variable">$0x0</span>,-0x60(%rbp)</span><br><span class="line">0x000055555555475d &lt;+67&gt;:    movq   <span class="variable">$0x0</span>,-0x58(%rbp)</span><br><span class="line">0x0000555555554765 &lt;+75&gt;:    movq   <span class="variable">$0x0</span>,-0x50(%rbp)</span><br><span class="line">0x000055555555476d &lt;+83&gt;:    movq   <span class="variable">$0x0</span>,-0x48(%rbp)</span><br><span class="line">0x0000555555554775 &lt;+91&gt;:    movq   <span class="variable">$0x0</span>,-0x40(%rbp)</span><br><span class="line">0x7fffffffe330: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe340: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe350: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe360: 0x6c6c6548      0x6f57206f      0x21646c72      0x00000000</span><br><span class="line">0x7fffffffe370: 0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe380: 0x55756260      0x00005555      0x00000000      0x0000900c</span><br><span class="line">0x7fffffffe390: 0xffffe3b0      0x00007fff</span><br></pre></td></tr></table></figure>
<h6 id="7-从rbp-96的地址开始，依次将连续的100字节设置成’c’，对应代码第7行。（这里构造了踩栈）">7. 从rbp-96的地址开始，依次将连续的100字节设置成’c’，对应代码第7行。（这里构造了踩栈）</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x000055555555477d &lt;+99&gt;:    lea    -0x60(%rbp),%rax</span><br><span class="line">0x0000555555554781 &lt;+103&gt;:   mov    <span class="variable">$0x64</span>,%edx</span><br><span class="line">0x0000555555554786 &lt;+108&gt;:   mov    <span class="variable">$0x63</span>,%esi</span><br><span class="line">0x000055555555478b &lt;+113&gt;:   mov    %rax,%rdi</span><br><span class="line">0x000055555555478e &lt;+116&gt;:   callq  0x5555555545e0 &lt;memset@plt&gt;</span><br><span class="line">(gdb) x/26wx <span class="variable">$rsp</span></span><br><span class="line">0x7fffffffe330: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe340: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe350: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe360: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe370: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe380: 0x63636363      0x63636363      0x63636363      0x63636363</span><br><span class="line">0x7fffffffe390: 0x63636363      0x00007fff</span><br></pre></td></tr></table></figure>
<h6 id="8-对应代码第8行，由于构造了踩栈，指针b被踩，free非法指针会异常。">8. 对应代码第8行，由于构造了踩栈，指针b被踩，free非法指针会异常。</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x0000555555554793 &lt;+121&gt;:   mov    -0x10(%rbp),%rax</span><br><span class="line">0x0000555555554797 &lt;+125&gt;:   mov    %rax,%rdi</span><br><span class="line">0x000055555555479a &lt;+128&gt;:   callq  0x5555555545c0 &lt;free@plt&gt;</span><br><span class="line">(gdb) ni</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">__GI___libc_free (mem=0x6363636363636363) at malloc.c:3113</span><br><span class="line">3113    malloc.c: No such file or directory.</span><br><span class="line">(gdb) i r</span><br><span class="line">rax            0x0      0</span><br><span class="line">rbx            0x0      0</span><br><span class="line">rcx            0x555555756260   93824994337376</span><br><span class="line">rdx            0x64     100</span><br><span class="line">rsi            0x63     99</span><br><span class="line">rdi            0x6363636363636363       7161677110969590627</span><br><span class="line">rbp            0x7fffffffe390   0x7fffffffe390</span><br><span class="line">rsp            0x7fffffffe2c0   0x7fffffffe2c0</span><br><span class="line">r8             0x2      2</span><br><span class="line">r9             0x0      0</span><br><span class="line">r10            0x555555756010   93824994336784</span><br><span class="line">r11            0x0      0</span><br><span class="line">r12            0x6363636363636363       7161677110969590627</span><br><span class="line">r13            0x7fffffffe4d0   140737488348368</span><br><span class="line">r14            0x0      0</span><br><span class="line">r15            0x0      0</span><br><span class="line">rip            0x7ffff7a7994d   0x7ffff7a7994d &lt;__GI___libc_free+61&gt;</span><br><span class="line">eflags         0x10206  [ PF IF RF ]</span><br><span class="line">cs             0x33     51</span><br><span class="line">ss             0x2b     43</span><br><span class="line">ds             0x0      0</span><br><span class="line">es             0x0      0</span><br><span class="line">fs             0x0      0</span><br><span class="line">gs             0x0      0</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  __GI___libc_free (mem=0x6363636363636363) at malloc.c:3113</span></span><br><span class="line"><span class="comment">#1  0x000055555555479f in FuncC () at demo.c:12</span></span><br><span class="line"><span class="comment">#2  0x00005555555547c7 in FuncB () at demo.c:20</span></span><br></pre></td></tr></table></figure>
<h6 id="9-对应代码第9行">9. 对应代码第9行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x000055555555479f &lt;+133&gt;:   movq   <span class="variable">$0x0</span>,-0x10(%rbp)</span><br><span class="line">0x00005555555547a7 &lt;+141&gt;:   mov    <span class="variable">$0x0</span>,%eax</span><br></pre></td></tr></table></figure>
<h6 id="10-eax-rax作为函数的返回值，对应代码第10行">10. eax/rax作为函数的返回值，对应代码第10行</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x00005555555547a7 &lt;+141&gt;:   mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">0x00005555555547ac &lt;+146&gt;:   leaveq</span><br><span class="line">0x00005555555547ad &lt;+147&gt;:   retq</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>common-tools</title>
    <url>/zhoukaiqi/c7f5a0752882/</url>
    <content><![CDATA[<p>本文介绍了常见工具的使用</p>
<span id="more"></span>
<h6 id="1-tcpdump">1. tcpdump</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 指定网口</span><br><span class="line">tcpdump -x -n -v -s 0 -i eth2 -w demo.cap</span><br><span class="line">// 指定IP + 端口</span><br><span class="line">tcpdump -x -n -v -s 0 -i any host IP and port 21 -w demo.cap</span><br><span class="line">tcpdump -x -n -v -s 0 -i any src host srcIP and host dstIP and port 21 -w demo.cap</span><br><span class="line">// 环回网口</span><br><span class="line">tcpdump -x -n -v -s 0 -i lo -w demo.cap</span><br><span class="line">// 指定协议类型</span><br><span class="line">tcpdump -x -n -v -s 0 -i any ether proto 56320 -w demo.cap</span><br><span class="line">// 指定物理地址</span><br><span class="line">tcpdump -x -n -v -s 0 -i eth2 not tcp and not udp and ether host macaddr -w demo.cap</span><br><span class="line"></span><br><span class="line">tcpdump -x -n -v -s 0 -i any \(host IP and port 20015 \) or \(host IP \) -w demo.cap</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-n</td>
<td>对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析</td>
</tr>
<tr>
<td>-v</td>
<td>当分析和打印的时候，产生详细的输出</td>
</tr>
<tr>
<td>-s len</td>
<td>设置tcpdump的数据包抓取长度为len，-s 0抓取完整的数据包</td>
</tr>
<tr>
<td>-i interface</td>
<td>指定tcpdump需要监听的网口，any表示监听所有网络接口</td>
</tr>
<tr>
<td>-w</td>
<td>将抓包数据输出到文件中而不是标准输出</td>
</tr>
<tr>
<td>ether proto 56320</td>
<td>指令协议类型</td>
</tr>
<tr>
<td>ether host macaddr</td>
<td>指定物理地址</td>
</tr>
<tr>
<td>portrange port1-port2</td>
<td>指定端口范围</td>
</tr>
</tbody>
</table>
<p>wireshark抓包过滤指定的字节数据     <a href="https://blog.csdn.net/andrewgithub/article/details/103444611">https://blog.csdn.net/andrewgithub/article/details/103444611</a></p>
<p>data[61:3]==0a:39:00</p>
<p>data数据报文中，以第61字节开始，之后的3个字节的数据为 0a:39:00</p>
<h6 id="2-strace">2. strace</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -ff -tt -T -o <span class="built_in">log</span> -p 17720</span><br><span class="line">strace -ft -o <span class="built_in">log</span> -p 35332</span><br><span class="line">// 跟踪单个线程</span><br><span class="line">strace -tt -T -o strace.log -p pid(线程的pid)</span><br><span class="line">// 跟踪整个进程</span><br><span class="line">strace -f -tt -T -o strace.log -p pid(进程的pid)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f</td>
<td>跟踪子线程</td>
</tr>
<tr>
<td>-ff</td>
<td>跟踪子线程，每个线程独立文件</td>
</tr>
<tr>
<td>-t</td>
<td>表示时间精确到秒(每秒记录一次)</td>
</tr>
<tr>
<td>-tt</td>
<td>表示时间精确到微秒(每微秒记录一次)</td>
</tr>
<tr>
<td>-T</td>
<td>记录各个系统调用花费的时间，精确到微秒</td>
</tr>
<tr>
<td>-o</td>
<td>表示将追踪结果输出的一个文件</td>
</tr>
<tr>
<td>-p</td>
<td>pid</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb使用</title>
    <url>/zhoukaiqi/ffde21da3a9c/</url>
    <content><![CDATA[<p>本文介绍了gdb的常见用法。</p>
<span id="more"></span>
<h6 id="1、入参与返回值">1、入参与返回值</h6>
<table>
<thead>
<tr>
<th style="text-align:left">CPU</th>
<th style="text-align:left">入参</th>
<th style="text-align:left">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x86</td>
<td style="text-align:left">ebp+8, ebp+12, ebp+16, ebp+20</td>
<td style="text-align:left">eax</td>
</tr>
<tr>
<td style="text-align:left">x86_64</td>
<td style="text-align:left">rdi, rsi, rdx, rcx, r8, r9</td>
<td style="text-align:left">rax</td>
</tr>
<tr>
<td style="text-align:left">arm64</td>
<td style="text-align:left">x0, x1, x2, x3, x4, x5, x6, x7</td>
<td style="text-align:left">x0</td>
</tr>
</tbody>
</table>
<p>返回值需要在执行finish后查看</p>
<h6 id="2、常见命令">2、常见命令</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb -q bin                                   // 启动时不显示提示信息</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint    // 屏蔽某些信号</span><br><span class="line"><span class="built_in">set</span> height 0                                 // 不限制输出行数</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> pretty on                          // 美化结构体打印</span><br><span class="line">i thread                                     // 查看所有线程信息</span><br><span class="line">thread threadno                              // 切换到指定线程</span><br><span class="line">thread apply all bt                          // 查看所有线程栈信息</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;Handle[%u], PtNo[%u]\n&quot;</span>, <span class="variable">$rdi</span>, <span class="variable">$rsi</span>  // 打印信息</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">print</span> thread-events off                  // 不显示线程启动和退出信息</span><br><span class="line">call getpid()                                // 获取拉起进程的pid</span><br><span class="line">shell <span class="built_in">date</span> +%H:%M:%S.%N                      // 加shell可以执行linux命令</span><br><span class="line">i r                                          // 查看寄存器信息</span><br><span class="line">generate-core-file                           // 生成core文件</span><br><span class="line">bt n(-n)                                     // 显示栈顶(栈底)的n层栈</span><br><span class="line">x addr                                       // 解析addr对应的函数</span><br><span class="line">x/s str                                      // 显示str对应的字符串</span><br><span class="line">x/nbx                                        // 显示n个单字节</span><br><span class="line">x/nhx                                        // 显示n个双字节</span><br><span class="line">x/nwx                                        // 显示n个4字节</span><br><span class="line">x/ngx                                        // 显示n个8字节</span><br><span class="line">frame n                                      // 切换到第n层栈帧</span><br></pre></td></tr></table></figure>
<h6 id="3、条件断点">3、条件断点</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x86 32位:  b func <span class="keyword">if</span> *(unsigned int*)(<span class="variable">$ebp</span>+8) == 226 &amp;&amp; *(unsigned int*)(<span class="variable">$ebp</span>+16) == 206</span><br><span class="line">x86 64位:  b func <span class="keyword">if</span> <span class="variable">$rdi</span> == 226 &amp;&amp; <span class="variable">$rdx</span> == 206</span><br><span class="line">arm 64位:  b func <span class="keyword">if</span> <span class="variable">$x0</span> == 226 &amp;&amp; <span class="variable">$x2</span> == 206</span><br><span class="line">线程断点:  b func thread threadno <span class="keyword">if</span> condition</span><br><span class="line">字符断点:  b func <span class="keyword">if</span> *(unsigned char*)(<span class="variable">$ebp</span>+8)==<span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure>
<h6 id="4、查看调用栈">4、查看调用栈</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb attach 10889</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height 0</span><br><span class="line">b func</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">bt</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h6 id="5、查看入参和返回值">5、查看入参和返回值</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb attach pid   ----------//进程的pid由ps -ef | grep xxx查询到</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height 0</span><br><span class="line">define oops</span><br><span class="line">bt        ----------// 显示调用栈</span><br><span class="line">i r       ----------// 显示寄存器信息，主要看入参，x86 32位进程看入参要替换成x/8wx <span class="variable">$ebp</span>+8</span><br><span class="line">fin       ----------// 表示执行完当前打断点的函数func</span><br><span class="line">i r       ----------// 在fin之后表示显示返回值，x86，x86_64，arm的返回值依次对应eax,rax,x0</span><br><span class="line">det</span><br><span class="line">q</span><br><span class="line">end</span><br><span class="line">b func    ----------// func即打断点的函数</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">oops</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h6 id="6、查看出参">6、查看出参</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb attach `pidof demo`</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> heigh 0</span><br><span class="line">define ops</span><br><span class="line">bt</span><br><span class="line">i r</span><br><span class="line">x/s <span class="variable">$rdi</span></span><br><span class="line">p <span class="variable">$rsi</span></span><br><span class="line"><span class="built_in">set</span> <span class="variable">$a</span>=<span class="variable">$rdx</span></span><br><span class="line">fin</span><br><span class="line">x/5wx <span class="variable">$a</span></span><br><span class="line">x/s <span class="variable">$a</span></span><br><span class="line">p *(unsigned int*)(<span class="variable">$a</span>+16)</span><br><span class="line">det</span><br><span class="line">q</span><br><span class="line">end</span><br><span class="line">b func</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">ops</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h6 id="7、在函数func2执行之后再执行函数func1">7、在函数<code>func2</code>执行之后再执行函数<code>func1</code></h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb attach `pidof demo`</span><br><span class="line">handle SIG35 SIG36 SIGUSR2 nostop noprint</span><br><span class="line"><span class="built_in">set</span> height 0</span><br><span class="line">b func1</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line">bt</span><br><span class="line">det</span><br><span class="line">q</span><br><span class="line">end</span><br><span class="line"><span class="built_in">disable</span> 1</span><br><span class="line">b func2</span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="built_in">enable</span> 1</span><br><span class="line">bt</span><br><span class="line">c</span><br><span class="line">end</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h6 id="8、扫描core文件">8、扫描core文件</h6>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">define mem_scan</span><br><span class="line">    <span class="built_in">set</span> logging file xxx.txt</span><br><span class="line">    <span class="built_in">set</span> logging on</span><br><span class="line">    <span class="built_in">set</span> logging overwrite on</span><br><span class="line">    <span class="built_in">set</span> height 0</span><br><span class="line">    <span class="built_in">set</span> <span class="built_in">print</span> pretty on</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$g_index</span> = 0</span><br><span class="line">    <span class="keyword">while</span> (xxx)</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;**************************\n&quot;</span></span><br><span class="line">        // 具体扫描实现</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;**************************\n&quot;</span></span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">set</span> logging off</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">mem_scan</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/info-function.html">https://wizardforcel.gitbooks.io/100-gdb-tips/content/info-function.html</a></p>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>调用者与被调用者的寄存器优化</title>
    <url>/zhoukaiqi/e89ef2b48b02/</url>
    <content><![CDATA[<p><strong>问题背景</strong></p>
<p>最近遇到了一个少见的热补丁问题，叶子函数(FuncChild)打上热补丁后，进程在调用父函数(FuncFather)时会复位。</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncFather</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncFather:</span><br><span class="line">   <span class="number">0x0000000000687f10</span> &lt;+<span class="number">0</span>&gt;:     adrp   x3, <span class="number">0x1f8e000</span></span><br><span class="line">   <span class="number">0x0000000000687f14</span> &lt;+<span class="number">4</span>&gt;:     stp    x29, x30, [sp, #<span class="number">-32</span>]!</span><br><span class="line">   <span class="number">0x0000000000687f18</span> &lt;+<span class="number">8</span>&gt;:     mov    x4, x2</span><br><span class="line">   <span class="number">0x0000000000687f1c</span> &lt;+<span class="number">12</span>&gt;:    mov    x29, sp</span><br><span class="line">   <span class="number">0x0000000000687f20</span> &lt;+<span class="number">16</span>&gt;:    ldr    x2, [x3, #<span class="number">744</span>]</span><br><span class="line">   <span class="number">0x0000000000687f24</span> &lt;+<span class="number">20</span>&gt;:    mov    x5, x1</span><br><span class="line">   <span class="number">0x0000000000687f28</span> &lt;+<span class="number">24</span>&gt;:    add    x1, x29, #<span class="number">0x17</span></span><br><span class="line">   <span class="number">0x0000000000687f2c</span> &lt;+<span class="number">28</span>&gt;:    ldr    x6, [x2]</span><br><span class="line">   <span class="number">0x0000000000687f30</span> &lt;+<span class="number">32</span>&gt;:    str    x6, [x29, #<span class="number">24</span>]</span><br><span class="line">   <span class="number">0x0000000000687f34</span> &lt;+<span class="number">36</span>&gt;:    mov    x6, #<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000687f38</span> &lt;+<span class="number">40</span>&gt;:    bl     <span class="number">0x687de0</span> &lt;FuncChild&gt;</span><br><span class="line">   <span class="number">0x0000000000687f3c</span> &lt;+<span class="number">44</span>&gt;:    cbz    w0, <span class="number">0x687f70</span> &lt;FuncFather+<span class="number">96</span>&gt;</span><br><span class="line">   <span class="number">0x0000000000687f40</span> &lt;+<span class="number">48</span>&gt;:    ldrb   w0, [x29, #<span class="number">23</span>]</span><br><span class="line">   <span class="number">0x0000000000687f44</span> &lt;+<span class="number">52</span>&gt;:    strb   w0, [x4]</span><br><span class="line">   <span class="number">0x0000000000687f48</span> &lt;+<span class="number">56</span>&gt;:    ldrb   w0, [x5, #<span class="number">25</span>]</span><br><span class="line">   <span class="number">0x0000000000687f4c</span> &lt;+<span class="number">60</span>&gt;:    cmp    w0, #<span class="number">0x0</span></span><br><span class="line">   <span class="number">0x0000000000687f50</span> &lt;+<span class="number">64</span>&gt;:    cset   w0, eq <span class="comment">// eq = none</span></span><br><span class="line">=&gt; <span class="number">0x0000000000687f54</span> &lt;+<span class="number">68</span>&gt;:    ldr    x3, [x3, <span class="number">744</span>]</span><br><span class="line">(gdb) i r x3</span><br><span class="line">x3            <span class="number">0x0000000000018000</span>        <span class="number">0x0000000000018000</span></span><br></pre></td></tr></table></figure>
<p>异常的指令是<code>0x0000000000687f54 &lt;+68&gt;:    ldr    x3, [x3, 744]</code>，x3寄存器是0x18000。</p>
<p>FuncFather在之前读写过x3寄存器的只有<code>0x0000000000687f20 &lt;+16&gt;:    ldr    x2, [x3, #744]</code></p>
<p>所以，即使x3寄存器不可访问，也应该在FuncFather+16指令时出现异常，这里存在了矛盾点。合理的怀疑是FuncChild修改了x3寄存器，从FuncChild的汇编分也证明了这一点。</p>
<p>为什么会出现被调用者复用了调用者的寄存器且不恢复，查询了相关资料予以说明。</p>
<p><strong>相关介绍</strong></p>
<p>对于函数调用，假设存在这样两个函数 funA 和 funB，其中 funA 调用 funB 函数，这里称 funA 为 caller（调用者），funB 为 callee（被调用者），funA 和 funB 都使用了相同的寄存器 R。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e7b7788746c1d6c99e49d84a79c2f8c1_720w.jpg" alt=""></p>
<p>寄存器R被funB修改了，funA再使用相同寄存器R时已经是错误的数据。</p>
<p>如果 funA 在调用 funB 前保存寄存器 R 中的数据，funB 返回后再将数据恢复到 R 中，或者 funB 先保存 R 中原有的数据，然后在返回前恢复，就可以解决这类问题。</p>
<p><strong>唯一的调用约定</strong></p>
<p>那寄存器该由 caller 还是 callee 来保存？这就需要遵循函数的调用约定（call convention），不同的 ABI 和不同的平台，函数的调用约定是不一样的，对于 Linux 来说，它遵循的是 System V ABI 的 call convention，x86_64 平台下函数调用约定有且只有一种，调用者 caller 和被调用者 callee 需要对相应的寄存器进行保存和恢复操作：</p>
<ul>
<li>Caller-save registers : RDI, RSI, RDX, RCX, R8, R9, RAX, R10, R11</li>
<li>Callee-save registers : RBX, RBP, R12, R13, R14, R15</li>
</ul>
<p><strong>调用约定，gcc 它遵守了吗？</strong></p>
<p>设问：当函数实现很简单，只用到了少量寄存器，那没使用到的还需要保存吗？</p>
<p>答案：it depends。根据编译选项决定。</p>
<p>众所周知，GCC 编译器有 -O0、-O1、-O2 和 -Ox 等编译优化选项，优化范围和深度随 x 增大而增大（-O0是不优化，其中隐含的意思是，它会严格遵循 ABI 中的调用约定，对所有使用的寄存器进行保存和恢复）。</p>
<p>Linux 内核选用的都是 -O2 优化。GCC 会选择性的不遵守调用约定，也就是设问里提到的，不需要保存没使用到的寄存器。</p>
<p><strong>当【运行时替换】撞见【调用约定】</strong></p>
<p>GCC 之所以可以做这个优化，是因为 GCC 高屋建瓴，了解程序的执行流。当它知道 callee，caller 的寄存器分配情况，就会大胆且安全地做各种优化。</p>
<p>但是，运行时替换破坏了这个假设，GCC 所掌握的 callee 信息，极有可能是错误的。那么这些优化可能会引发严重问题。这里以一个具体的实例进行详细说明，<strong>（ x86_64 平台）</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译命令：gcc leaf.c -o leaf -O2 -g  (kernel 采用的是 O2 优化选项)</span></span><br><span class="line"><span class="comment">// 执行过程：./leaf</span></span><br><span class="line"><span class="comment">// 编译选项 -fipa-ra</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noinline __attribute__((noinline))</span></span><br><span class="line"></span><br><span class="line">noinline <span class="type">int</span> <span class="title function_">FuncC</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">int</span> <span class="title function_">FuncB</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">int</span> <span class="title function_">NewFuncB</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> FuncC(x * <span class="number">2</span>) * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">int</span> <span class="title function_">FuncA</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">volatile</span> temp = FuncB(x);</span><br><span class="line">    <span class="keyword">return</span> x + temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mprotect传入的地址必须页对齐</span></span><br><span class="line">    <span class="type">void</span> *startAddr = (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)&amp;FuncB &amp; (~<span class="number">0xFFF</span>));</span><br><span class="line">    <span class="keyword">if</span> (mprotect(startAddr, <span class="number">15</span>, PROT_WRITE | PROT_EXEC | PROT_READ)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mprotect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 利用 jump 指令将函数 FuncB 替换为 NewFuncB 函数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pucInst = (<span class="type">unsigned</span> <span class="type">char</span> *)FuncB;</span><br><span class="line">    *pucInst = <span class="number">0xe9</span>; <span class="comment">// 短跳转jmp指令机器码</span></span><br><span class="line">    pucInst++;</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span>*)pucInst = ((<span class="type">unsigned</span> <span class="type">long</span>)&amp;NewFuncB - (<span class="type">unsigned</span> <span class="type">long</span>)&amp;FuncB - <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, FuncA(x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序解释：该程序是对输入的数字进行计算，运行时利用 jump 指令将程序中的函数 b 替换为 newb 函数，即，将 y = x + x 计算过程替换为 y = x + (2x) ^ 3 * x；</li>
<li>程序编译：gcc leaf.c -o leaf -O2 -g，这里我们采用的是与编译内核相同的优化选项 -O2；</li>
<li>程序执行：./leaf，输入参数：4，输出结果：132；</li>
<li>程序错误：132是错误的结果，应该是 130，而且直接调用 newb 函数编译执行的结果是 130。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncA</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncA:</span><br><span class="line">   <span class="number">0x0000000000001260</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x0000000000001264</span> &lt;+<span class="number">4</span>&gt;:     sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">0x0000000000001268</span> &lt;+<span class="number">8</span>&gt;:     callq  <span class="number">0x1220</span> &lt;FuncB&gt;</span><br><span class="line">   <span class="number">0x000000000000126d</span> &lt;+<span class="number">13</span>&gt;:    mov    %eax,<span class="number">0xc</span>(%rsp)</span><br><span class="line">   <span class="number">0x0000000000001271</span> &lt;+<span class="number">17</span>&gt;:    mov    <span class="number">0xc</span>(%rsp),%eax</span><br><span class="line">   <span class="number">0x0000000000001275</span> &lt;+<span class="number">21</span>&gt;:    add    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">0x0000000000001279</span> &lt;+<span class="number">25</span>&gt;:    add    %edi,%eax</span><br><span class="line">   <span class="number">0x000000000000127b</span> &lt;+<span class="number">27</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disassemble FuncB</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncB:</span><br><span class="line">   <span class="number">0x0000000000001220</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x0000000000001224</span> &lt;+<span class="number">4</span>&gt;:     mov    %edi,%eax</span><br><span class="line">   <span class="number">0x0000000000001226</span> &lt;+<span class="number">6</span>&gt;:     retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>当FuncA通过FuncB跳转到NewFuncB后：edi = 2 * edi，返回到FuncA时edi寄存器已经被修改了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncA</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncA:</span><br><span class="line">   <span class="number">0x0000000008001260</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x0000000008001264</span> &lt;+<span class="number">4</span>&gt;:     sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">=&gt; <span class="number">0x0000000008001268</span> &lt;+<span class="number">8</span>&gt;:     callq  <span class="number">0x8001220</span> &lt;FuncB&gt;</span><br><span class="line">   <span class="number">0x000000000800126d</span> &lt;+<span class="number">13</span>&gt;:    mov    %eax,<span class="number">0xc</span>(%rsp)</span><br><span class="line">   <span class="number">0x0000000008001271</span> &lt;+<span class="number">17</span>&gt;:    mov    <span class="number">0xc</span>(%rsp),%eax</span><br><span class="line">   <span class="number">0x0000000008001275</span> &lt;+<span class="number">21</span>&gt;:    add    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">0x0000000008001279</span> &lt;+<span class="number">25</span>&gt;:    add    %edi,%eax</span><br><span class="line">   <span class="number">0x000000000800127b</span> &lt;+<span class="number">27</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) si</span><br><span class="line">(gdb) disassemble FuncB</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function FuncB:</span><br><span class="line">=&gt; <span class="number">0x0000000008001220</span> &lt;+<span class="number">0</span>&gt;:     jmpq   <span class="number">0x8001240</span> &lt;NewFuncB&gt;</span><br><span class="line">   <span class="number">0x0000000008001225</span> &lt;+<span class="number">5</span>&gt;:     clc</span><br><span class="line">   <span class="number">0x0000000008001226</span> &lt;+<span class="number">6</span>&gt;:     retq</span><br><span class="line">(gdb) si</span><br><span class="line">(gdb) disassemble NewFuncB</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function NewFuncB:</span><br><span class="line">=&gt; <span class="number">0x0000000008001240</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x0000000008001244</span> &lt;+<span class="number">4</span>&gt;:     mov    %edi,%edx</span><br><span class="line">   <span class="number">0x0000000008001246</span> &lt;+<span class="number">6</span>&gt;:     lea    (%rdi,%rdi,<span class="number">1</span>),%edi</span><br><span class="line">   <span class="number">0x0000000008001249</span> &lt;+<span class="number">9</span>&gt;:     callq  <span class="number">0x8001230</span> &lt;FuncC&gt;</span><br><span class="line">   <span class="number">0x000000000800124e</span> &lt;+<span class="number">14</span>&gt;:    imul   %edx,%eax</span><br><span class="line">   <span class="number">0x0000000008001251</span> &lt;+<span class="number">17</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">ret = <span class="number">132</span></span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">292</span>) exited normally]</span><br></pre></td></tr></table></figure>
<p>查找相关资料，发现了这个<code> -fipa-ra</code> 选项，可以说它是优化的幕后主使。</p>
<p>如果开启这个选项，callee 中如果没有使用到 caller 使用的寄存器，就没有必要保存这些寄存器，前提是，callee 与 caller 在同一个.c中而且 callee 函数比 caller 先被编译，这样才可能出现前面的优化。如果开启了 -O2 及以上的编译优化选项，则会使能 -fipa-ra 选项，然而，如果开启了 -p 或者 -pg 这些选项，或者，无法明确 callee 所使用的寄存器，-fipa-ra 选项会被禁用。</p>
<p>加上<code>-fno-ipa-ra</code>屏蔽该优化，运行结果正常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xxx@ubuntu:src$ gcc -Q --help=optimizers -O2 | grep fipa-ra</span><br><span class="line">  -fipa-ra                              [enabled]</span><br><span class="line">xxx@ubuntu:src$ gcc leaf.c -o leaf -O2 -g -fno-ipa-ra</span><br><span class="line">xxx@ubuntu:src$ ./leaf</span><br><span class="line">ret = <span class="number">130</span></span><br><span class="line">xxx@ubuntu:src$</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/397027508">https://zhuanlan.zhihu.com/p/397027508</a></p>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>movaps指令引起的复位</title>
    <url>/zhoukaiqi/82d7b7baa849/</url>
    <content><![CDATA[<p>最近定位了一个bolt优化导致进程异常复位的问题。disassemble复位函数发现是运行到movaps指令时挂了。movaps是SSE指令，要求访问的地址是16字节对齐的。由于bolt优化多开了一层8字节的栈，后续的rbp非16字节对齐。当movaps访问非16字节对齐的rbp时，指令异常，进程复位。</p>
<span id="more"></span>
<p>这里忽略bolt优化，只用汇编模拟movaps指令异常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;movaps 0x04(%rdx), %xmm0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x0000000008001129</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x000000000800112d</span> &lt;+<span class="number">4</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x000000000800112e</span> &lt;+<span class="number">5</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000008001131</span> &lt;+<span class="number">8</span>&gt;:     movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">=&gt; <span class="number">0x0000000008001138</span> &lt;+<span class="number">15</span>&gt;:    movaps <span class="number">0x4</span>(%rdx),%xmm0</span><br><span class="line">   <span class="number">0x000000000800113c</span> &lt;+<span class="number">19</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x0000000008001141</span> &lt;+<span class="number">24</span>&gt;:    pop    %rbp</span><br><span class="line">   <span class="number">0x0000000008001142</span> &lt;+<span class="number">25</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) i r rdx</span><br><span class="line">rdx            <span class="number">0x7ffffffee168</span>      <span class="number">140737488281960</span></span><br></pre></td></tr></table></figure>
<p>rdx寄存器是0x7ffffffee168， 0x7ffffffee168+0x4=0x7ffffffee16c不是16字节对齐，所以会出现段错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">main () at demo.c:<span class="number">4</span></span><br><span class="line"><span class="number">4</span>           __asm__ __volatile__ (<span class="string">&quot;movaps 0x04(%rdx), %xmm0&quot;</span>);</span><br><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x0000000008001129</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x000000000800112d</span> &lt;+<span class="number">4</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x000000000800112e</span> &lt;+<span class="number">5</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000008001131</span> &lt;+<span class="number">8</span>&gt;:     movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">=&gt; <span class="number">0x0000000008001138</span> &lt;+<span class="number">15</span>&gt;:    movaps <span class="number">0x4</span>(%rdx),%xmm0</span><br><span class="line">   <span class="number">0x000000000800113c</span> &lt;+<span class="number">19</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x0000000008001141</span> &lt;+<span class="number">24</span>&gt;:    pop    %rbp</span><br><span class="line">   <span class="number">0x0000000008001142</span> &lt;+<span class="number">25</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<p>如果给rdx寄存器减去12字节，使得rdx+4是16字节对齐的，则能正常执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">   <span class="number">0x0000000008001129</span> &lt;+<span class="number">0</span>&gt;:     endbr64</span><br><span class="line">   <span class="number">0x000000000800112d</span> &lt;+<span class="number">4</span>&gt;:     push   %rbp</span><br><span class="line">   <span class="number">0x000000000800112e</span> &lt;+<span class="number">5</span>&gt;:     mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x0000000008001131</span> &lt;+<span class="number">8</span>&gt;:     movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">=&gt; <span class="number">0x0000000008001138</span> &lt;+<span class="number">15</span>&gt;:    movaps <span class="number">0x4</span>(%rdx),%xmm0</span><br><span class="line">   <span class="number">0x000000000800113c</span> &lt;+<span class="number">19</span>&gt;:    mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x0000000008001141</span> &lt;+<span class="number">24</span>&gt;:    pop    %rbp</span><br><span class="line">   <span class="number">0x0000000008001142</span> &lt;+<span class="number">25</span>&gt;:    retq</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) i r $rdx</span><br><span class="line">rdx            <span class="number">0x7ffffffee168</span>      <span class="number">140737488281960</span></span><br><span class="line">(gdb) <span class="built_in">set</span> $rdx = $rdx - <span class="number">12</span></span><br><span class="line">(gdb) i r $rdx</span><br><span class="line">rdx            <span class="number">0x7ffffffee15c</span>      <span class="number">140737488281948</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Inferior <span class="number">1</span> (process <span class="number">396</span>) exited normally]</span><br></pre></td></tr></table></figure>
<p>补充：movups	<code>u表示不必16字节对齐，替换成a表示必须16字节对齐。</code></p>
<p>参考：<a href="https://blog.csdn.net/u010659887/article/details/113802005">https://blog.csdn.net/u010659887/article/details/113802005</a></p>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>栈保护canary机制与__stack_chk_fail</title>
    <url>/zhoukaiqi/b0bd912f2458/</url>
    <content><![CDATA[<h5 id="栈保护canary机制">栈保护canary机制</h5>
<p>canary机制原理：在函数被调用之后，立即在栈帧中插入一个随机数，函数执行完在返回之前，检查这个随机数是否改变来判断是否存在栈溢出。</p>
<span id="more"></span>
<h5 id="构造-stack-chk-fail">构造__stack_chk_fail</h5>
<p>以demo.c为例，编译命令<code>gcc demo.c -fstack-protector -fno-omit-frame-pointer -fPIC -g -o demo</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FuncDemo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x900C</span>;</span><br><span class="line">    <span class="type">void</span> *b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>));</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="string">&#x27;c&#x27;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">100</span>); <span class="comment">// 踩栈</span></span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    b = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FuncDemo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整汇编</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncDemo</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncDemo:</span><br><span class="line">   0x0000aaaaaaaaa884 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">   0x0000aaaaaaaaa888 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">   0x0000aaaaaaaaa88c &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa890 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa894 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">   0x0000aaaaaaaaa898 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa89c &lt;+24&gt;:    mov     x1, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa8a0 &lt;+28&gt;:    mov     w0, <span class="comment">#0x900c                     // #36876</span></span><br><span class="line">   0x0000aaaaaaaaa8a4 &lt;+32&gt;:    str     w0, [x29, <span class="comment">#28]</span></span><br><span class="line">   0x0000aaaaaaaaa8a8 &lt;+36&gt;:    mov     x0, <span class="comment">#0x8                        // #8</span></span><br><span class="line">   0x0000aaaaaaaaa8ac &lt;+40&gt;:    bl      0xaaaaaaaaa710 &lt;malloc@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa8b0 &lt;+44&gt;:    str     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa8b4 &lt;+48&gt;:    adrp    x0, 0xaaaaaaaaa000</span><br><span class="line">   0x0000aaaaaaaaa8b8 &lt;+52&gt;:    add     x1, x0, <span class="comment">#0x9f0</span></span><br><span class="line">   0x0000aaaaaaaaa8bc &lt;+56&gt;:    add     x0, x29, <span class="comment">#0x50</span></span><br><span class="line">   0x0000aaaaaaaaa8c0 &lt;+60&gt;:    ldr     x2, [x1]</span><br><span class="line">   0x0000aaaaaaaaa8c4 &lt;+64&gt;:    str     x2, [x0]</span><br><span class="line">   0x0000aaaaaaaaa8c8 &lt;+68&gt;:    ldur    x1, [x1, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa8cc &lt;+72&gt;:    stur    x1, [x0, <span class="comment">#5]</span></span><br><span class="line">   0x0000aaaaaaaaa8d0 &lt;+76&gt;:    stur    wzr, [x29, <span class="comment">#93]</span></span><br><span class="line">   0x0000aaaaaaaaa8d4 &lt;+80&gt;:    sturh   wzr, [x29, <span class="comment">#97]</span></span><br><span class="line">   0x0000aaaaaaaaa8d8 &lt;+84&gt;:    strb    wzr, [x29, <span class="comment">#99]</span></span><br><span class="line">   0x0000aaaaaaaaa8dc &lt;+88&gt;:    stp     xzr, xzr, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa8e0 &lt;+92&gt;:    stp     xzr, xzr, [x29, <span class="comment">#56]</span></span><br><span class="line">   0x0000aaaaaaaaa8e4 &lt;+96&gt;:    str     xzr, [x29, <span class="comment">#72]</span></span><br><span class="line">   0x0000aaaaaaaaa8e8 &lt;+100&gt;:   mov     w0, <span class="comment">#0x1                        // #1</span></span><br><span class="line">   0x0000aaaaaaaaa8ec &lt;+104&gt;:   str     w0, [x29, <span class="comment">#40]</span></span><br><span class="line">   0x0000aaaaaaaaa8f0 &lt;+108&gt;:   add     x0, x29, <span class="comment">#0x28</span></span><br><span class="line">   0x0000aaaaaaaaa8f4 &lt;+112&gt;:   mov     x2, <span class="comment">#0x64                       // #100</span></span><br><span class="line">   0x0000aaaaaaaaa8f8 &lt;+116&gt;:   mov     w1, <span class="comment">#0x63                       // #99</span></span><br><span class="line">   0x0000aaaaaaaaa8fc &lt;+120&gt;:   bl      0xaaaaaaaaa730 &lt;memset@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa900 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa904 &lt;+128&gt;:   bl      0xaaaaaaaaa770 &lt;free@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa908 &lt;+132&gt;:   str     xzr, [x29, <span class="comment">#32]</span></span><br><span class="line">   0x0000aaaaaaaaa90c &lt;+136&gt;:   mov     w0, <span class="comment">#0x0                        // #0</span></span><br><span class="line">   0x0000aaaaaaaaa910 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa914 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa918 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa91c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">   0x0000aaaaaaaaa920 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">   0x0000aaaaaaaaa924 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">   0x0000aaaaaaaaa928 &lt;+164&gt;:   b.eq    0xaaaaaaaaa930 &lt;FuncDemo+172&gt;  // b.none</span><br><span class="line">   0x0000aaaaaaaaa92c &lt;+168&gt;:   bl      0xaaaaaaaaa740 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x0000aaaaaaaaa930 &lt;+172&gt;:   ldp     x29, x30, [sp], <span class="comment">#112</span></span><br><span class="line">   0x0000aaaaaaaaa934 &lt;+176&gt;:   ret</span><br></pre></td></tr></table></figure>
<h6 id="1-先通过反汇编找到canary在栈上的存放地址">1. 先通过反汇编找到canary在栈上的存放地址</h6>
<p>canary的值是<code>0x4c597894f2014f00</code>，存入sp + 104的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) disassemble FuncDemo</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncDemo:</span><br><span class="line">   0x0000aaaaaaaaa884 &lt;+0&gt;:     stp     x29, x30, [sp, <span class="comment">#-112]!</span></span><br><span class="line">   0x0000aaaaaaaaa888 &lt;+4&gt;:     mov     x29, sp</span><br><span class="line">   0x0000aaaaaaaaa88c &lt;+8&gt;:     adrp    x0, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa890 &lt;+12&gt;:    ldr     x0, [x0, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa894 &lt;+16&gt;:    ldr     x1, [x0]</span><br><span class="line">   0x0000aaaaaaaaa898 &lt;+20&gt;:    str     x1, [x29, <span class="comment">#104]</span></span><br><span class="line">(gdb) i r x0 x1</span><br><span class="line">x0             0xfffff7ffd7a8   281474842482600</span><br><span class="line">x1             0x4c597894f2014f00       5501561000920436480</span><br><span class="line">(gdb) x/2wx <span class="variable">$x0</span></span><br><span class="line">0xfffff7ffd7a8 &lt;__stack_chk_guard&gt;:     0xf2014f00      0x4c597894</span><br><span class="line">(gdb) x/2wx <span class="variable">$sp</span> + 104</span><br><span class="line">0xfffffffffa38: 0xf2014f00      0x4c597894</span><br></pre></td></tr></table></figure>
<h6 id="2-执行完代码第7行">2. 执行完代码第7行</h6>
<p>memset越界，将栈中保存的canary值踩成了’c’</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   0x0000aaaaaaaaa8fc &lt;+120&gt;:   bl      0xaaaaaaaaa730 &lt;memset@plt&gt;</span><br><span class="line">=&gt; 0x0000aaaaaaaaa900 &lt;+124&gt;:   ldr     x0, [x29, <span class="comment">#32]</span></span><br><span class="line">(gdb) x/2wx <span class="variable">$sp</span> + 104</span><br><span class="line">0xfffffffffa38: 0x63636363      0x63636363</span><br></pre></td></tr></table></figure>
<h6 id="3-继续执行">3. 继续执行</h6>
<p>从栈中取出保存的canary值与原来的canary值比较，不相等则说明有踩栈，跳转到__stack_chk_fail并抛出异常信号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   0x0000aaaaaaaaa910 &lt;+140&gt;:   adrp    x1, 0xaaaaaaaba000</span><br><span class="line">   0x0000aaaaaaaaa914 &lt;+144&gt;:   ldr     x1, [x1, <span class="comment">#4064]</span></span><br><span class="line">   0x0000aaaaaaaaa918 &lt;+148&gt;:   ldr     x2, [x29, <span class="comment">#104]</span></span><br><span class="line">   0x0000aaaaaaaaa91c &lt;+152&gt;:   ldr     x1, [x1]</span><br><span class="line">   0x0000aaaaaaaaa920 &lt;+156&gt;:   eor     x1, x2, x1</span><br><span class="line">   0x0000aaaaaaaaa924 &lt;+160&gt;:   cmp     x1, <span class="comment">#0x0</span></span><br><span class="line">   0x0000aaaaaaaaa928 &lt;+164&gt;:   b.eq    0xaaaaaaaaa930 &lt;FuncDemo+172&gt;  // b.none</span><br><span class="line">   0x0000aaaaaaaaa92c &lt;+168&gt;:   bl      0xaaaaaaaaa740 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Program received signal SIGABRT, Aborted.</span><br><span class="line">__GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51</span><br><span class="line">51      ../sysdeps/unix/sysv/linux/raise.c: No such file or directory.</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51</span></span><br><span class="line"><span class="comment">#1  0x0000fffff7eaa974 in __GI_abort () at abort.c:79</span></span><br><span class="line"><span class="comment">#2  0x0000fffff7ee372c in __libc_message (action=do_abort,</span></span><br><span class="line">    <span class="built_in">fmt</span>=<span class="built_in">fmt</span>@entry=0xfffff7fa3350 <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>)</span><br><span class="line">    at ../sysdeps/posix/libc_fatal.c:181</span><br><span class="line"><span class="comment">#3  0x0000fffff7f583c4 in __GI___fortify_fail_abort (</span></span><br><span class="line">    need_backtrace=need_backtrace@entry=<span class="literal">false</span>,</span><br><span class="line">    msg=msg@entry=0xfffff7fa3328 <span class="string">&quot;stack smashing detected&quot;</span>)</span><br><span class="line">    at fortify_fail.c:33</span><br><span class="line"><span class="comment">#4  0x0000fffff7f58378 in __stack_chk_fail () at stack_chk_fail.c:29</span></span><br><span class="line"><span class="comment">#5  0x0000aaaaaaaaa930 in FuncDemo () at demo.c:15</span></span><br><span class="line"><span class="comment">#6  0x0000aaaaaaaaa944 in main () at demo.c:19</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>x86_64推栈原理与实现</title>
    <url>/zhoukaiqi/e578d0eceb35/</url>
    <content><![CDATA[<p>本文介绍了x86_64推栈原理和具体代码实现。</p>
<span id="more"></span>
<h4 id="推栈原理">推栈原理</h4>
<p>x86_64推栈需要添加编译选项<code>-fno-omit-frame-pointer</code>，否则rbp不作为栈帧寄存器使用，无法正确推栈。</p>
<p><img src="https://s1.daohangmao.net/2022/06/26/62b7cdf3eb89f.png" alt=""></p>
<p>开栈（从高地址到低地址）：当函数A callq 函数B时，会先将函数A的下一条指令存入rsp(即后续返回到A函数的地址)。而调用到函数B后，会将函数A的寄存器rbp存入rsp并且将rsp赋值给rbp。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// callq addr的具体实现</span><br><span class="line">rsp = rsp - 8</span><br><span class="line">*(unsigned long*)rsp = rip + sizeof(inst)</span><br><span class="line">rip = addr</span><br><span class="line"></span><br><span class="line">// push rbp的具体实现</span><br><span class="line">rsp = rsp - 8</span><br><span class="line">*(unsigned long*)rsp = rbp</span><br><span class="line"></span><br><span class="line">// 函数的入口指令</span><br><span class="line">(gdb) disassemble FuncC</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> FuncC:</span><br><span class="line">   0x000055555555471a &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x000055555555471b &lt;+1&gt;:     mov    %rsp,%rbp</span><br></pre></td></tr></table></figure>
<p>推栈（从低地址到高地址）：根据上述的压栈规则，可以得到推栈公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">preRbp = *(<span class="type">unsigned</span> <span class="type">long</span>*)rbp;</span><br><span class="line">funcAddr = *(<span class="type">unsigned</span> <span class="type">long</span>*)(rbp + <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<h4 id="代码实现推栈">代码实现推栈</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GetRbp() (&#123; \</span></span><br><span class="line"><span class="meta">    unsigned long rbp; \</span></span><br><span class="line"><span class="meta">    __asm__ __volatile__ (<span class="string">&quot;movq %%rbp,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(rbp)); \</span></span><br><span class="line"><span class="meta">    rbp; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetCurrentStackBase</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *stackBegin, <span class="type">unsigned</span> <span class="type">long</span> *stackBase)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_getattr_np(tid, &amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *pStackAddr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">size_t</span> stackSize = <span class="number">0</span>;</span><br><span class="line">        (<span class="type">void</span>)pthread_attr_getstack(&amp;attr, &amp;pStackAddr, (<span class="type">size_t</span> *)(&amp;stackSize));</span><br><span class="line">        (<span class="type">void</span>)pthread_attr_destroy(&amp;attr);</span><br><span class="line">        *stackBegin = (<span class="type">unsigned</span> <span class="type">long</span>)pStackAddr;</span><br><span class="line">        *stackBase = (<span class="type">unsigned</span> <span class="type">long</span>)pStackAddr + stackSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *stackBegin = <span class="number">0</span>;</span><br><span class="line">    *stackBase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsInvalidAddr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> instAddr, <span class="type">unsigned</span> <span class="type">long</span> begin, <span class="type">unsigned</span> <span class="type">long</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instAddr &lt;= begin &amp;&amp; instAddr &gt;= end &amp;&amp; (instAddr &amp; <span class="number">3</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BackTrace</span><span class="params">(<span class="type">void</span> **buffer, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *<span class="built_in">array</span> = *(<span class="type">unsigned</span> <span class="type">long</span> **)buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulRbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stackBegin;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stackBase;</span><br><span class="line">    ulRbp = GetRbp();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = <span class="number">0xfaceface</span>; <span class="comment">// 赋予无效值</span></span><br><span class="line">    &#125;</span><br><span class="line">    GetCurrentStackBase(&amp;stackBegin, &amp;stackBase);</span><br><span class="line">    <span class="keyword">if</span> (IsInvalidAddr(ulRbp, stackBegin, stackBase)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> stackDepth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> preUlRbp = ulRbp;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> instAddr = ulRbp + <span class="number">8</span>;</span><br><span class="line">        ulRbp = *(<span class="type">unsigned</span> <span class="type">long</span> *)ulRbp;</span><br><span class="line">        <span class="keyword">if</span> (IsInvalidAddr(instAddr, stackBegin, stackBase) </span><br><span class="line">            || IsInvalidAddr(ulRbp, preUlRbp, stackBase)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[stackDepth] = *(<span class="type">unsigned</span> <span class="type">long</span> *)instAddr;</span><br><span class="line">        stackDepth++;</span><br><span class="line">    &#125; <span class="keyword">while</span>(stackDepth &lt; size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试demo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc backtrace.c -lpthread -rdynamic -m64 -mmanual-endbr -g -D_GNU_SOURCE -o backtrace</span></span><br><span class="line"><span class="comment">// backtrace_symbols only works if link with -rdynamic</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noinline __attribute__((noinline))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GetRbp() (&#123; \</span></span><br><span class="line"><span class="meta">    unsigned long rbp; \</span></span><br><span class="line"><span class="meta">    __asm__ __volatile__ (<span class="string">&quot;movq %%rbp,%0&quot;</span>:<span class="string">&quot;=r&quot;</span>(rbp)); \</span></span><br><span class="line"><span class="meta">    rbp; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetCurrentStackBase</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *stackBegin, <span class="type">unsigned</span> <span class="type">long</span> *stackBase)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_getattr_np(tid, &amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *pStackAddr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">size_t</span> stackSize = <span class="number">0</span>;</span><br><span class="line">        (<span class="type">void</span>)pthread_attr_getstack(&amp;attr, &amp;pStackAddr, (<span class="type">size_t</span> *)(&amp;stackSize));</span><br><span class="line">        (<span class="type">void</span>)pthread_attr_destroy(&amp;attr);</span><br><span class="line">        *stackBegin = (<span class="type">unsigned</span> <span class="type">long</span>)pStackAddr;</span><br><span class="line">        *stackBase = (<span class="type">unsigned</span> <span class="type">long</span>)pStackAddr + stackSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *stackBegin = <span class="number">0</span>;</span><br><span class="line">    *stackBase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsInvalidAddr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> instAddr, <span class="type">unsigned</span> <span class="type">long</span> begin, <span class="type">unsigned</span> <span class="type">long</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> instAddr &lt;= begin &amp;&amp; instAddr &gt;= end &amp;&amp; (instAddr &amp; <span class="number">3</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BackTrace</span><span class="params">(<span class="type">void</span> **buffer, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *<span class="built_in">array</span> = *(<span class="type">unsigned</span> <span class="type">long</span> **)buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ulRbp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stackBegin;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stackBase;</span><br><span class="line">    ulRbp = GetRbp();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = <span class="number">0xfaceface</span>; <span class="comment">// 赋予无效值</span></span><br><span class="line">    &#125;</span><br><span class="line">    GetCurrentStackBase(&amp;stackBegin, &amp;stackBase);</span><br><span class="line">    <span class="keyword">if</span> (IsInvalidAddr(ulRbp, stackBegin, stackBase)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> stackDepth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> preUlRbp = ulRbp;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> instAddr = ulRbp + <span class="number">8</span>;</span><br><span class="line">        ulRbp = *(<span class="type">unsigned</span> <span class="type">long</span> *)ulRbp;</span><br><span class="line">        <span class="keyword">if</span> (IsInvalidAddr(instAddr, stackBegin, stackBase) </span><br><span class="line">            || IsInvalidAddr(ulRbp, preUlRbp, stackBase)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[stackDepth] = *(<span class="type">unsigned</span> <span class="type">long</span> *)instAddr;</span><br><span class="line">        stackDepth++;</span><br><span class="line">    &#125; <span class="keyword">while</span>(stackDepth &lt; size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> <span class="title function_">FuncC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *buffer;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">4</span>;</span><br><span class="line">    buffer = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) * size);</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call malloc(%ld) failed\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) * size);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>)BackTrace((<span class="type">void</span> **)&amp;buffer, size);</span><br><span class="line">    <span class="comment">// backtrace_symbols only works if link with -rdynamic</span></span><br><span class="line">    <span class="type">char</span> **symbolName = backtrace_symbols((<span class="type">void</span> *)buffer, size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&lt;------0x%016lx(%s)\n&quot;</span>, buffer[i], symbolName[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    buffer = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> <span class="title function_">FuncB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    FuncC();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noinline <span class="type">void</span> <span class="title function_">FuncA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    FuncB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FuncA();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zkq@ubuntu:src$ gcc backtrace.c -lpthread -rdynamic -m64 -mmanual-endbr -g -D_GNU_SOURCE -o backtrace</span><br><span class="line">zkq@ubuntu:src$ ./backtrace</span><br><span class="line">&lt;-----<span class="number">-0x00007fb4ffeab52a</span>(./backtrace(FuncC+<span class="number">0x6f</span>) [<span class="number">0x7fb4ffeab52a</span>])</span><br><span class="line">&lt;-----<span class="number">-0x00007fb4ffeab5d6</span>(./backtrace(FuncB+<span class="number">0x19</span>) [<span class="number">0x7fb4ffeab5d6</span>])</span><br><span class="line">&lt;-----<span class="number">-0x00007fb4ffeab5f2</span>(./backtrace(FuncA+<span class="number">0x19</span>) [<span class="number">0x7fb4ffeab5f2</span>])</span><br><span class="line">&lt;-----<span class="number">-0x00007fb4ffeab603</span>(./backtrace(main+<span class="number">0xe</span>) [<span class="number">0x7fb4ffeab603</span>])</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>线程爆栈引起的复位</title>
    <url>/zhoukaiqi/761b5f08fe29/</url>
    <content><![CDATA[<p>近期遇到了多次线程爆栈问题，即线程栈的设置太小，被调用函数开栈到了另一个段空间，另一个段不可读写引起了异常。</p>
<span id="more"></span>
<p>下面构造了一个线程爆栈。线程的栈大小是16k，线程内的函数定义了多个局部大数组，会超过16k。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 16384</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FuncB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2000</span>] = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FuncA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">2000</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    FuncB();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ThreadWork</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FuncA();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_attr_init failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_attr_setstacksize(&amp;attr, STACK_SIZE);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_attr_setstacksize failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid, &amp;attr, (<span class="type">void</span> *)ThreadWork, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;call pthread_create failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：<code>gcc pthread.c -lpthread -g -mmanual-endbr -o pthread</code></p>
<p>异常复位的指令是<code>orq    $0x0,(%rsp)</code>，查询rbp、rsp的值分别是0x7fffff571f70和0x7fffff570f70</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Thread <span class="number">2</span> <span class="string">&quot;pthread&quot;</span> received signal SIGSEGV, Segmentation fault.</span><br><span class="line">[Switching to Thread <span class="number">0x7fffff574700</span> (LWP <span class="number">221</span>)]</span><br><span class="line"><span class="number">0x00000000080011f4</span> in <span class="title function_">FuncB</span> <span class="params">()</span> at pthread.c:9</span><br><span class="line">9       &#123;</span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00000000080011f4</span> in <span class="title function_">FuncB</span> <span class="params">()</span> at pthread.c:9</span><br><span class="line">#1  0x0000000008001298 in <span class="title function_">FuncA</span> <span class="params">()</span> at pthread.c:17</span><br><span class="line">#2  0x00000000080012c5 in <span class="title function_">ThreadWork</span> <span class="params">(arg=<span class="number">0x0</span>)</span> at pthread.c:25</span><br><span class="line">#3  0x00007fffff795609 in <span class="title function_">start_thread</span> <span class="params">(arg=&lt;optimized out&gt;)</span> at pthread_create.c:477</span><br><span class="line">#4  0x00007fffff6af133 in <span class="title function_">clone</span> <span class="params">()</span> at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span><br><span class="line"><span class="params">(gdb)</span> x/10i FuncB</span><br><span class="line">   0x80011e9 &lt;FuncB&gt;:   push   %rbp</span><br><span class="line">   0x80011ea &lt;FuncB+1&gt;: mov    %rsp,%rbp</span><br><span class="line">   0x80011ed &lt;FuncB+4&gt;: sub    $0x1000,%rsp</span><br><span class="line">=&gt; <span class="number">0x80011f4</span> &lt;FuncB+<span class="number">11</span>&gt;:        orq    $<span class="number">0x0</span>,(%rsp)</span><br><span class="line">   <span class="number">0x80011f9</span> &lt;FuncB+<span class="number">16</span>&gt;:        sub    $<span class="number">0xf50</span>,%rsp</span><br><span class="line">   <span class="number">0x8001200</span> &lt;FuncB+<span class="number">23</span>&gt;:        mov    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">   <span class="number">0x8001209</span> &lt;FuncB+<span class="number">32</span>&gt;:        mov    %rax,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">   <span class="number">0x800120d</span> &lt;FuncB+<span class="number">36</span>&gt;:        xor    %eax,%eax</span><br><span class="line">   <span class="number">0x800120f</span> &lt;FuncB+<span class="number">38</span>&gt;:        lea    <span class="number">-0x1f50</span>(%rbp),%rdx</span><br><span class="line">   <span class="number">0x8001216</span> &lt;FuncB+<span class="number">45</span>&gt;:        mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">(gdb) i r rbp rsp</span><br><span class="line">rbp            <span class="number">0x7fffff571f70</span>      <span class="number">0x7fffff571f70</span></span><br><span class="line">rsp            <span class="number">0x7fffff570f70</span>      <span class="number">0x7fffff570f70</span></span><br></pre></td></tr></table></figure>
<p>查看maps表，rbp所在的段可读可写，但rsp(即rbp-0x1000)所在的段不可读写，所以会异常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) shell cat /proc/<span class="number">217</span>/maps | grep <span class="number">7f</span>ffff57</span><br><span class="line"><span class="number">7f</span>ffff570000<span class="number">-7f</span>ffff571000 ---p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br><span class="line"><span class="number">7f</span>ffff571000<span class="number">-7f</span>ffff575000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
